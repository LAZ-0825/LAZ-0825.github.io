{
    "version": "https://jsonfeed.org/version/1",
    "title": "LAZ的小站 • All posts by \"算法作业\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/passages/Leetcode-632-%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/",
            "url": "http://example.com/passages/Leetcode-632-%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/",
            "title": "Leetcode-632-最小区间",
            "date_published": "2022-02-17T04:12:53.000Z",
            "content_html": "<p>132</p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/Leetcode-218-%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/passages/Leetcode-218-%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/",
            "title": "Leetcode-218-天际线问题",
            "date_published": "2022-02-17T04:12:01.000Z",
            "content_html": "<p>321</p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/Leetcode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90/",
            "url": "http://example.com/passages/Leetcode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90/",
            "title": "Leetcode-1226-哲学家进餐",
            "date_published": "2022-02-06T10:29:25.000Z",
            "content_html": "<h1 id=\"leetcode-1226-哲学家进餐\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-1226-哲学家进餐\">#</a> Leetcode 1226. 哲学家进餐</h1>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h2>\n<p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p>\n<p>所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p>\n<p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p>\n<p>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/23/an_illustration_of_the_dining_philosophers_problem.png\" alt=\"\"></p>\n<p>问题描述和图片来自维基百科 <a href=\"https://en.wikipedia.org/wiki/Dining_philosophers_problem\">https://en.wikipedia.org/wiki/Dining_philosophers_problem</a></p>\n<p>哲学家从 <strong>0</strong> 到 <strong>4</strong> 按 <strong>顺时针</strong> 编号。请实现函数  <code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code> ：</p>\n<ul>\n<li>\n<p><code>philosopher</code>  哲学家的编号。</p>\n</li>\n<li>\n<p><code>pickLeftFork</code>  和  <code>pickRightFork</code>  表示拿起左边或右边的叉子。</p>\n</li>\n<li>\n<p><code>eat</code>  表示吃面。</p>\n</li>\n<li>\n<p><code>putLeftFork</code>  和  <code>putRightFork</code>  表示放下左边或右边的叉子。</p>\n</li>\n<li>\n<p>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。</p>\n</li>\n</ul>\n<p>给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。</p>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = <span class=\"number\">1</span></span><br><span class=\"line\">输出：[[<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>],[<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>],[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],[<span class=\"number\">4</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>],[<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>],[<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>],[<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>],[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>],[<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>],[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">n 表示每个哲学家需要进餐的次数。</span><br><span class=\"line\">输出数组描述了叉子的控制和进餐的调用，它的格式如下：</span><br><span class=\"line\">output[i] = [a, b, c] (<span class=\"number\">3</span>个整数)</span><br><span class=\"line\"></span><br><span class=\"line\">- a 哲学家编号。</span><br><span class=\"line\">- b 指定叉子：&#123;<span class=\"number\">1</span> : 左边, <span class=\"number\">2</span> : 右边&#125;.</span><br><span class=\"line\">- c 指定行为：&#123;<span class=\"number\">1</span> : 拿起, <span class=\"number\">2</span> : 放下, <span class=\"number\">3</span> : 吃面&#125;。</span><br><span class=\"line\">  如 [<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>] 表示 <span class=\"number\">4</span> 号哲学家拿起了右边的叉子。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= n &lt;= 60</code></li>\n</ul>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/the-dining-philosophers\">https://leetcode-cn.com/problems/the-dining-philosophers</a><br>\n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>​\t\t** 本题要求 (题意)：** 设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p>\n<p>​\t\t刚开始的话，简单了解到了信号量  <code>Semaphore</code>  的用法，并写了一个感觉不是很切合题意的解决方法（一个一个吃）。</p>\n<p>​\t\t之后又简单学习了  <code>synchronized</code>  的用法 (详见上一篇博客)，并按照  <code>synchronized</code>  的限制思路来写了一个  <code>synchronized</code>  修饰类内方法的解决方法（感觉也不是很符合题意）。</p>\n<h3 id=\"semaphore\"><a class=\"markdownIt-Anchor\" href=\"#semaphore\">#</a> Semaphore</h3>\n<p>​\t\t  <code>Semaphore</code>  可以控制同一时间访问资源的线程总数，通过  <code>acquire()</code>  和  <code>release()</code>  来获取和释放信号量从而实现对线程数量的控制。所以我们在解体的时候可以通过限制线程总数为 1 的方法来实现一个一个吃的暴力解决办法。</p>\n<p><code>Semaphore semaphore = new Semaphore(1);</code>   -&gt; 限制线程总数为 1（只有一个信号量）</p>\n<p><code>semaphore.acquire(1);</code>   -&gt; 获取一个信号量，并将信号量数量 - 1</p>\n<p><code>semaphore.release(1);</code>   -&gt; 释放一个信号量，并将信号量数量 + 1</p>\n<h3 id=\"synchronized\"><a class=\"markdownIt-Anchor\" href=\"#synchronized\">#</a> synchronized</h3>\n<p>​\t\t被  <code>synchronized</code>  修饰的代码同一时间只能被一个作用的对象访问，  <code>synchronized</code>  修饰的位置不同，相对应的作用对象不同。例如：</p>\n<p>​\t\t  <code>synchronized</code>  修饰一个普通方法： -&gt; 作用对象为调用这个方法的对象。</p>\n<p>​\t\t  <code>synchronized</code>  修饰一个  <code>static</code>  方法： -&gt; 作用对象为这个类的所有对象。</p>\n<p>由于本题中使用的是  <code>DiningPhilosophers</code>  类的同一个对象，所以两种方法均可（不过个人感觉还是  <code>synchronized</code>  修饰一个普通方法）好一些。</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<h3 id=\"semaphore-2\"><a class=\"markdownIt-Anchor\" href=\"#semaphore-2\">#</a> Semaphore</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiningPhilosophers</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiningPhilosophers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 限制线程总数为1（只有一个信号量）</span></span><br><span class=\"line\">    Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// call the run() method of any runnable to execute its code</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">wantsToEat</span><span class=\"params\">(<span class=\"keyword\">int</span> philosopher,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           Runnable pickLeftFork,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           Runnable pickRightFork,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           Runnable eat,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           Runnable putLeftFork,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           Runnable putRightFork)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 一个一个吃</span></span><br><span class=\"line\">        semaphore.acquire(<span class=\"number\">1</span>); <span class=\"comment\">// 获取一个信号量，并将信号量数量 - 1</span></span><br><span class=\"line\">        pickLeftFork.run();</span><br><span class=\"line\">        pickRightFork.run();</span><br><span class=\"line\">        eat.run();</span><br><span class=\"line\">        putLeftFork.run();</span><br><span class=\"line\">        putRightFork.run();</span><br><span class=\"line\">        semaphore.release(<span class=\"number\">1</span>); <span class=\"comment\">// 释放一个信号量，并将信号量数量 + 1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3.bmp.ovh/imgs/2022/02/f412682f61fb2cf2.png\" alt=\"\"></p>\n<h3 id=\"synchronized-2\"><a class=\"markdownIt-Anchor\" href=\"#synchronized-2\">#</a> synchronized</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于 i 号哲学家，需要获取 [i, i%5] 号筷子。但是获取筷子之前需要让synchronized获取到对象</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiningPhilosophers</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiningPhilosophers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// call the run() method of any runnable to execute its code</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于本题中使用的是DiningPhilosophers类的同一个对象，所以该方法可以是普通方法也可以是static方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">wantsToEat</span><span class=\"params\">(<span class=\"keyword\">int</span> philosopher,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           Runnable pickLeftFork,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           Runnable pickRightFork,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           Runnable eat,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           Runnable putLeftFork,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           Runnable putRightFork)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        pickLeftFork.run();</span><br><span class=\"line\">        pickRightFork.run();</span><br><span class=\"line\">        eat.run();</span><br><span class=\"line\">        putLeftFork.run();</span><br><span class=\"line\">        putRightFork.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3.bmp.ovh/imgs/2022/02/a1b53eabd78d26cd.png\" alt=\"\"></p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> 题目总结</h2>\n<p>​\t\t在思路上，我解决本体的方法大体上是每次只允许一个人访问资源，通过  <code>Semaphore</code>  限制进程数量和  <code>synchronized</code>  修饰方法来实现，个人感觉这两种解法不是很符合题意，但是其他的方法还未学会，只能先这样解题了。</p>\n<p>​\t\t还是有很多东西需要学习的呜呜呜 (菜鸡嘤嘤～~ ~ doge)</p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/Java%E4%B8%ADSynchronized%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%89/",
            "url": "http://example.com/passages/Java%E4%B8%ADSynchronized%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%89/",
            "title": "Java中Synchronized的用法（简单介绍）",
            "date_published": "2022-01-27T12:00:38.000Z",
            "content_html": "<h1 id=\"简单介绍\"><a class=\"markdownIt-Anchor\" href=\"#简单介绍\">#</a> 简单介绍</h1>\n<h3 id=\"synchronized-是java中的关键字是一种同步锁-它修饰的对象有以下几种\"><a class=\"markdownIt-Anchor\" href=\"#synchronized-是java中的关键字是一种同步锁-它修饰的对象有以下几种\">#</a>  <code>synchronized</code>  是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种：</h3>\n<p>1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号  <code>&#123;&#125;</code>  括起来的代码，作用的对象是调用这个代码块的对象；<br>\n　　2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；<br>\n　　3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；<br>\n　　4. 修改一个类，其作用的范围是  <code>synchronized</code>  后面括号括起来的部分，作用主的对象是这个类的所有对象。</p>\n<h1 id=\"修饰一个代码块\"><a class=\"markdownIt-Anchor\" href=\"#修饰一个代码块\">#</a> 修饰一个代码块</h1>\n<p>1、一个线程访问一个对象中的  <code>synchronized(this)</code>  同步代码块时，其他试图访问该对象的线程将被阻塞。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.wbg;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">kt</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;使用关键字synchronized&quot;</span>);</span><br><span class=\"line\">        SyncThread syncThread = <span class=\"keyword\">new</span> SyncThread();</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(syncThread, <span class=\"string\">&quot;SyncThread1&quot;</span>);</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(syncThread, <span class=\"string\">&quot;SyncThread2&quot;</span>);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SyncThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;线程名:&quot;</span>+Thread.currentThread().getName() + <span class=\"string\">&quot;:&quot;</span> + (count++));</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用关键字-synchronized-运行结果\"><a class=\"markdownIt-Anchor\" href=\"#使用关键字-synchronized-运行结果\">#</a> 使用关键字  <code>synchronized</code>  运行结果</h2>\n<p><img src=\"https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813202814267-1084435693.png\" alt=\"img\"></p>\n<h2 id=\"不使用关键字-synchronized-运行结果\"><a class=\"markdownIt-Anchor\" href=\"#不使用关键字-synchronized-运行结果\">#</a> 不使用关键字  <code>synchronized</code>  运行结果</h2>\n<p><img src=\"https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813215801141-1864858293.png\" alt=\"img\"></p>\n<p>当两个并发线程 (  <code>thread1</code>  和  <code>thread2</code>  ) 访问同一个对象 (  <code>syncThread</code>  ) 中的  <code>synchronized</code>  代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。  <code>Thread1</code>  和  <code>thread2</code>  是互斥的，因为在执行  <code>synchronized</code>  代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。<br>\n我们再把  <code>SyncThread</code>  的调用稍微改一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;使用关键字synchronized每次调用进行new SyncThread()&quot;</span>);</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread( <span class=\"keyword\">new</span> SyncThread(), <span class=\"string\">&quot;SyncThread1&quot;</span>);</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread( <span class=\"keyword\">new</span> SyncThread(), <span class=\"string\">&quot;SyncThread2&quot;</span>);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行结果\"><a class=\"markdownIt-Anchor\" href=\"#运行结果\">#</a> 运行结果</h2>\n<p><img src=\"https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813220831864-787748019.png\" alt=\"img\"></p>\n<p>为什么上面的例子中  <code>thread1</code>  和  <code>thread2</code>  同时在执行。这是因为  <code>synchronized</code>  只锁定对象，每个对象只有一个锁（  <code>lock</code>  ）与之相关联，而上面的代码等同于下面这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;使用关键字synchronized每次调用进行new SyncThread()&quot;</span>);</span><br><span class=\"line\">        SyncThread syncThread1 = <span class=\"keyword\">new</span> SyncThread();</span><br><span class=\"line\">        SyncThread syncThread2 = <span class=\"keyword\">new</span> SyncThread();</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(syncThread1, <span class=\"string\">&quot;SyncThread1&quot;</span>);</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(syncThread2, <span class=\"string\">&quot;SyncThread2&quot;</span>);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这时创建了两个  <code>SyncThread</code>  的对象  <code>syncThread1</code>  和  <code>syncThread2</code>  ，线程  <code>thread1</code>  执行的是  <code>syncThread1</code>  对象中的  <code>synchronized</code>  代码 (  <code>run</code>  )，而线程  <code>thread2</code>  执行的是  <code>syncThread2</code>  对象中的  <code>synchronized</code>  代码 (  <code>run</code>  )；我们知道  <code>synchronized</code>  锁定的是对象，这时会有两把锁分别锁定  <code>syncThread1</code>  对象和  <code>syncThread2</code>  对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。</p>\n<h2 id=\"二-当一个线程访问对象的一个-synchronizedthis-同步代码块时另一个线程仍然可以访问该对象中的非-synchronizedthis-同步代码块\"><a class=\"markdownIt-Anchor\" href=\"#二-当一个线程访问对象的一个-synchronizedthis-同步代码块时另一个线程仍然可以访问该对象中的非-synchronizedthis-同步代码块\">#</a> 二、当一个线程访问对象的一个  <code>synchronized(this)</code>  同步代码块时，另一个线程仍然可以访问该对象中的非  <code>synchronized(this)</code>  同步代码块。</h2>\n<h3 id=\"多个线程访问-synchronized-和非-synchronized-代码块\"><a class=\"markdownIt-Anchor\" href=\"#多个线程访问-synchronized-和非-synchronized-代码块\">#</a> 多个线程访问  <code>synchronized</code>  和非  <code>synchronized</code>  代码块</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;使用关键字synchronized&quot;</span>);</span><br><span class=\"line\">        Mthreads mt=<span class=\"keyword\">new</span> Mthreads();</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(mt, <span class=\"string\">&quot;mt1&quot;</span>);</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(mt, <span class=\"string\">&quot;mt2&quot;</span>);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mthreads</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Mthreads</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">countAdd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i ++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;:&quot;</span> + (count++));</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//非synchronized代码块，未对count进行读写操作，所以可以不用synchronized</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i ++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; count:&quot;</span> + count);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String threadName = Thread.currentThread().getName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (threadName.equals(<span class=\"string\">&quot;mt1&quot;</span>)) &#123;</span><br><span class=\"line\">            countAdd();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (threadName.equals(<span class=\"string\">&quot;mt2&quot;</span>)) &#123;</span><br><span class=\"line\">            printCount();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行结果-2\"><a class=\"markdownIt-Anchor\" href=\"#运行结果-2\">#</a> 运行结果</h3>\n<p><img src=\"https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813222142309-231904508.png\" alt=\"img\"></p>\n<p>上面代码中  <code>countAdd</code>  是一个  <code>synchronized</code>  的，  <code>printCount</code>  是非  <code>synchronized</code>  的。从上面的结果中可以看出一个线程访问一个对象的  <code>synchronized</code>  代码块时，别的线程可以访问该对象的非  <code>synchronized</code>  代码块而不受阻塞。</p>\n<h1 id=\"修饰一个方法\"><a class=\"markdownIt-Anchor\" href=\"#修饰一个方法\">#</a> 修饰一个方法</h1>\n<p><code>Synchronized</code>  修饰一个方法很简单，就是在方法的前面加  <code>synchronized</code>  ，  <code>public synchronized void method()&#123;&#125;</code>  ;   <code>synchronized</code>  修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。如将的  <code>run</code>  方法改成如下的方式，实现的效果一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   System.out.println(<span class=\"string\">&quot;线程名:&quot;</span>+Thread.currentThread().getName() + <span class=\"string\">&quot;:&quot;</span> + (count++));</span><br><span class=\"line\">                   Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">               &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                   e.printStackTrace();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813222952717-956438905.png\" alt=\"img\"></p>\n<h2 id=\"synchronized-作用于整个方法的写法\"><a class=\"markdownIt-Anchor\" href=\"#synchronized-作用于整个方法的写法\">#</a>  <code>Synchronized</code>  作用于整个方法的写法。</h2>\n<p>写法一:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// todo</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>写法二:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。</p>\n<p>在用  <code>synchronized</code>  修饰方法时要注意以下要点：</p>\n<p><strong> <code>synchronized</code>  关键字不能继承。</strong><br>\n虽然可以使用  <code>synchronized</code>  来定义方法，但  <code>synchronized</code>  并不属于方法定义的一部分，因此，  <code>synchronized</code>  关键字不能被继承。如果在父类中的某个方法使用了  <code>synchronized</code>  关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上  <code>synchronized</code>  关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下：<br>\n在子类方法中加上  <code>synchronized</code>  关键字</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lass Parent &#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在子类方法中调用父类的同步方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">super</span>.method();   &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p><font color=Red>在定义接口方法时不能使用 synchronized 关键字。</font></p>\n<p><font color=Red>构造方法不能使用 synchronized 关键字，但可以使用 synchronized 代码块来进行同步。</font></p>\n<h1 id=\"修饰一个静态的方法\"><a class=\"markdownIt-Anchor\" href=\"#修饰一个静态的方法\">#</a> 修饰一个静态的方法</h1>\n<p><code>Synchronized</code>  也可修饰一个静态方法，用法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们知道静态方法是属于类的而不属于对象的。同样的，  <code>synchronized</code>  修饰的静态方法锁定的是这个类的所有对象。</p>\n<h2 id=\"synchronized-修饰静态方法\"><a class=\"markdownIt-Anchor\" href=\"#synchronized-修饰静态方法\">#</a>  <code>synchronized</code>  修饰静态方法</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.wbg;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">kt</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;使用关键字静态synchronized&quot;</span>);</span><br><span class=\"line\">        SyncThread syncThread = <span class=\"keyword\">new</span> SyncThread();</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(syncThread, <span class=\"string\">&quot;SyncThread1&quot;</span>);</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(syncThread, <span class=\"string\">&quot;SyncThread2&quot;</span>);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SyncThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i ++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;:&quot;</span> + (count++));</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        method();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行结果-3\"><a class=\"markdownIt-Anchor\" href=\"#运行结果-3\">#</a> 运行结果</h2>\n<p><img src=\"https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813224017511-578390484.png\" alt=\"img\"></p>\n<p><code>syncThread1</code>  和  <code>syncThread2</code>  是  <code>SyncThread</code>  的两个对象，但在  <code>thread1</code>  和  <code>thread2</code>  并发执行时却保持了线程同步。这是因为  <code>run</code>  中调用了静态方法  <code>method</code>  ，而静态方法是属于类的，所以  <code>syncThread1</code>  和  <code>syncThread2</code>  相当于用了同一把锁。这与使用关键字  <code>synchronized</code>  运行结果相同</p>\n<h1 id=\"修饰一个类\"><a class=\"markdownIt-Anchor\" href=\"#修饰一个类\">#</a> 修饰一个类</h1>\n<p><code>Synchronized</code>  还可作用于一个类，用法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.wbg;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">kt</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;使用ClassName&quot;</span>);</span><br><span class=\"line\">        SyncThread syncThread = <span class=\"keyword\">new</span> SyncThread();</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(syncThread, <span class=\"string\">&quot;SyncThread1&quot;</span>);</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(syncThread, <span class=\"string\">&quot;SyncThread2&quot;</span>);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassName</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(ClassName.class) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SyncThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(SyncThread.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i ++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;:&quot;</span> + (count++));</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        method();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行结果-4\"><a class=\"markdownIt-Anchor\" href=\"#运行结果-4\">#</a> 运行结果</h2>\n<p><img src=\"https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813224557391-772452008.png\" alt=\"img\"></p>\n<p>效果和上面  <code>synchronized</code>  修饰静态方法是一样的，  <code>synchronized</code>  作用于一个类  <code>T</code>  时，是给这个类  <code>T</code>  加锁，  <code>T</code>  的所有对象用的是同一把锁。</p>\n<h1 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>1、 无论  <code>synchronized</code>  关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果  <code>synchronized</code>  作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。<br>\n2、每个对象只有一个锁（  <code>lock</code>  ）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。<br>\n3、实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</p>\n<p>原文链接：<a href=\"https://www.cnblogs.com/weibanggang/p/9470718.html\">Java 中 Synchronized 的用法（简单介绍）</a></p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/Leetcode-208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91/",
            "url": "http://example.com/passages/Leetcode-208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91/",
            "title": "Leetcode-208-实现Trie(前缀树)",
            "date_published": "2022-01-21T04:43:37.000Z",
            "content_html": "<h1 id=\"leetcode-208-实现-trie-前缀树\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-208-实现-trie-前缀树\">#</a> Leetcode 208. 实现 Trie (前缀树)</h1>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h2>\n<p><a href=\"https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin\">Trie</a>（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>\n<p>请你实现 Trie 类：</p>\n<ul>\n<li><code>Trie()</code>  初始化前缀树对象。</li>\n<li><code>void insert(String word)</code>  向前缀树中插入字符串 <code> word</code> 。</li>\n<li><code>boolean search(String word) </code>  如果字符串  <code>word</code>  在前缀树中，返回  <code>true</code>  （即，在检索之前已经插入）；否则，返回  <code>false</code>  。</li>\n<li><code>boolean startsWith(String prefix)</code>  如果之前已经插入的字符串  <code>word</code>   的前缀之一为  <code>prefix</code>  ，返回  <code>true</code>  ；否则，返回  <code>false</code> 。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入</span><br><span class=\"line\">[<span class=\"string\">&quot;Trie&quot;</span>, <span class=\"string\">&quot;insert&quot;</span>, <span class=\"string\">&quot;search&quot;</span>, <span class=\"string\">&quot;search&quot;</span>, <span class=\"string\">&quot;startsWith&quot;</span>, <span class=\"string\">&quot;insert&quot;</span>, <span class=\"string\">&quot;search&quot;</span>]</span><br><span class=\"line\">[[], [<span class=\"string\">&quot;apple&quot;</span>], [<span class=\"string\">&quot;apple&quot;</span>], [<span class=\"string\">&quot;app&quot;</span>], [<span class=\"string\">&quot;app&quot;</span>], [<span class=\"string\">&quot;app&quot;</span>], [<span class=\"string\">&quot;app&quot;</span>]]</span><br><span class=\"line\">输出</span><br><span class=\"line\">[null, null, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>, null, <span class=\"literal\">true</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">解释</span><br><span class=\"line\">Trie trie = <span class=\"keyword\">new</span> <span class=\"built_in\">Trie</span>();</span><br><span class=\"line\">trie.<span class=\"built_in\">insert</span>(<span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">trie.<span class=\"built_in\">search</span>(<span class=\"string\">&quot;apple&quot;</span>);   <span class=\"comment\">// 返回 True</span></span><br><span class=\"line\">trie.<span class=\"built_in\">search</span>(<span class=\"string\">&quot;app&quot;</span>);     <span class=\"comment\">// 返回 False</span></span><br><span class=\"line\">trie.<span class=\"built_in\">startsWith</span>(<span class=\"string\">&quot;app&quot;</span>); <span class=\"comment\">// 返回 True</span></span><br><span class=\"line\">trie.<span class=\"built_in\">insert</span>(<span class=\"string\">&quot;app&quot;</span>);</span><br><span class=\"line\">trie.<span class=\"built_in\">search</span>(<span class=\"string\">&quot;app&quot;</span>);     <span class=\"comment\">// 返回 True</span></span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>\n<li><code>word</code>  和  <code>prefix </code>  仅由小写英文字母组成</li>\n<li><code>insert</code>  、 <code>search</code>  和  <code>startsWith</code>  调用次数<strong>总计</strong>不超过  <code>3 * 104 </code>  次</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/implement-trie-prefix-tree\">https://leetcode-cn.com/problems/implement-trie-prefix-tree</a><br>\n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>​\t\t有百度百科可知（连接已上方给出），字典树是一种树形结构，每个节点只储存一个字符，且为节点不存储字符，我认为它是一种可以按照路径存储字符串的数据结构。</p>\n<p>​\t\t现在我们需要将一些单词（只有小写英文字母）存储在字典树里面，我们就在字典树里面的每个节点中创建一个大小为 26 的对象数组  <code>Trie* next[26]</code>  （  <code>该数组中的26个位置分别对应26个小写英文字母</code>  ），同时我们创建一个用来提取字符编号的基准  <code>Base</code>  （  <code>const char Base='a';</code>  ，  <code>编号 = 字符 - Base</code>  ），将计算出的编号作为访问对象数组的索引。</p>\n<p>​\t\t当我们向字典树中添加一个单词是，只需要一个字符一层的遍历字典树的节点，如果未找到包含该字符的节点，则新建一个节点并将字符放入；若找到了存放该字符的节点，则指向该节点并继续向下一层字符遍历；直到遍历完该单词的最后一个字母时，将该节点的  <code>isWord</code>  值改为  <code>true</code>  ，标示着这里是一个单词的结尾。</p>\n<p>​\t\t当我们在字典树中查找一个单词时，与添加步骤相同，也是一直向下遍历，区别是当遍历时未找到对应的字符时需要返回  <code>false</code>  来表示未找到需要查找的单词；并且在查找到最后一个字符后，返回该字符的  <code>isWord</code>  来表示是否查找成功。</p>\n<p>​\t\t当我们在字典树中进行前缀匹配操作时，步骤跟查找一个单词的步骤基本相同，区别就是在查找到最后一个字符后直接返回  <code>true</code>  即可（因为在前缀匹配的条件下，只要找到了最后一个字符，就证明肯定有以该字符串为前缀的单词，这个单词的最小值就是前缀本身）。</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> Base=<span class=\"string\">&#x27;a&#x27;</span>; <span class=\"comment\">// 后续作为基准来提取字符的编号（编号 = 字符 - Base）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isWord; <span class=\"comment\">// 作为表示是否为单词结尾的tag</span></span><br><span class=\"line\">    Trie* next[<span class=\"number\">26</span>]; <span class=\"comment\">// 子节点（分别对应26个英文字母，通过Base得到索引来使用）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Trie</span>() &#123;</span><br><span class=\"line\">        isWord = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(next, <span class=\"number\">0</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(next)); <span class=\"comment\">// 初始化数组（内容都为0）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 插入单词</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(string word)</span> </span>&#123;</span><br><span class=\"line\">        Trie* node = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : word) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node-&gt;next[c - Base] == <span class=\"literal\">NULL</span>) &#123; <span class=\"comment\">// 如果没有对应的子节点的话，就new一个来用</span></span><br><span class=\"line\">                node-&gt;next[c - Base] = <span class=\"keyword\">new</span> <span class=\"built_in\">Trie</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node = node-&gt;next[c - Base]; <span class=\"comment\">// 指向下一个子节点（指向下一个字母）</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        node-&gt;isWord = <span class=\"literal\">true</span>; <span class=\"comment\">// 修改tag表示此处是一个单词的结尾</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 查找单词</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(string word)</span> </span>&#123;</span><br><span class=\"line\">        Trie* node = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历匹配字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : word) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向下匹配</span></span><br><span class=\"line\">            node = node-&gt;next[c - Base];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 未匹配到最后一个字符，返回false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 匹配到了最后一个字符，返回该字符的isWord</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node-&gt;isWord;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 前缀匹配</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">startsWith</span><span class=\"params\">(string prefix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 跟查找操作类似，只是不需要判断最后一个字符结点的isWord，因为既然能匹配到最后一个字符，那后面一定有单词是以它为前缀的。（至少是以该字符串为单词）</span></span><br><span class=\"line\">        Trie* node = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : prefix) &#123;</span><br><span class=\"line\">            node = node-&gt;next[c-<span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your Trie object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * 您的Trie对象将被实例化并按如下方式调用：</span></span><br><span class=\"line\"><span class=\"comment\"> * Trie* obj = new Trie();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj-&gt;insert(word);</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3.bmp.ovh/imgs/2022/01/774864f87352f82c.png\" alt=\"\"></p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2022/01/2b72d6e4e876f9c6.png\" alt=\"\"></p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> 题目总结</h2>\n<p>​\t\t在本题中，我们需要实现字典树，字典树是一种特殊的树形结构，由于储存的字符只有小写英文字母，所以可以用对象数组  <code>Trie* next[26]</code>  来存储。同时因为一个节点只能存放一个字符，使得我肯可以一个字符一层的去查找，而  <code>isWord</code>  给予了判断该字符是否为一个单词结尾的依据；插入，查找，前缀匹配三个操作都是依托上面所实现的东西来进行的。三种操作的相同点就是都要进行多次按照字符的遍历，不同点在于对于未找到对应字符的处理以及相同情况下的返回值不同。</p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/Leetcode-133-%E5%85%8B%E9%9A%86%E5%9B%BE/",
            "url": "http://example.com/passages/Leetcode-133-%E5%85%8B%E9%9A%86%E5%9B%BE/",
            "title": "Leetcode-133-克隆图",
            "date_published": "2022-01-20T08:17:02.000Z",
            "content_html": "<h1 id=\"leetcode-133克隆图\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-133克隆图\">#</a> Leetcode 133. 克隆图</h1>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h2>\n<p>给你无向<a href=\"https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin\">连通</a>图中一个节点的引用，请你返回该图的<a href=\"https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin\">深拷贝</a>（克隆）。</p>\n<p>图中的每个节点都包含它的值  <code>val</code> （ <code>int</code> ） 和其邻居的列表（ <code>list[Node]</code> ）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Node&gt; neighbors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>测试用例格式：</strong></p>\n<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（ <code>val = 1</code> ），第二个节点值为 2（ <code>val = 2</code> ），以此类推。该图在测试用例中使用邻接列表表示。</p>\n<p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p>\n<p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：adjList = [[<span class=\"number\">2</span>,<span class=\"number\">4</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">4</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>]]</span><br><span class=\"line\">输出：[[<span class=\"number\">2</span>,<span class=\"number\">4</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">4</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">图中有 <span class=\"number\">4</span> 个节点。</span><br><span class=\"line\">节点 <span class=\"number\">1</span> 的值是 <span class=\"number\">1</span>，它有两个邻居：节点 <span class=\"number\">2</span> 和 <span class=\"number\">4</span> 。</span><br><span class=\"line\">节点 <span class=\"number\">2</span> 的值是 <span class=\"number\">2</span>，它有两个邻居：节点 <span class=\"number\">1</span> 和 <span class=\"number\">3</span> 。</span><br><span class=\"line\">节点 <span class=\"number\">3</span> 的值是 <span class=\"number\">3</span>，它有两个邻居：节点 <span class=\"number\">2</span> 和 <span class=\"number\">4</span> 。</span><br><span class=\"line\">节点 <span class=\"number\">4</span> 的值是 <span class=\"number\">4</span>，它有两个邻居：节点 <span class=\"number\">1</span> 和 <span class=\"number\">3</span> 。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：adjList = [[]]</span><br><span class=\"line\">输出：[[]]</span><br><span class=\"line\">解释：输入包含一个空列表。该图仅仅只有一个值为 <span class=\"number\">1</span> 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：adjList = []</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：adjList = [[<span class=\"number\">2</span>],[<span class=\"number\">1</span>]]</span><br><span class=\"line\">输出：[[<span class=\"number\">2</span>],[<span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ol>\n<li>节点数不超过 100 。</li>\n<li>每个节点值  <code>Node.val</code>  都是唯一的， <code>1 &lt;= Node.val &lt;= 100</code> 。</li>\n<li>无向图是一个<a href=\"https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%9B%BE/1680528?fr=aladdin\">简单图</a>，这意味着图中没有重复的边，也没有自环。</li>\n<li>由于图是无向的，如果节点 <code>p</code>  是节点 <code>q</code>  的邻居，那么节点  <code>q </code> 也必须是节点  <code>p </code> 的邻居。</li>\n<li>图是连通图，你可以从给定节点访问到所有节点。</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/clone-graph\">https://leetcode-cn.com/problems/clone-graph</a><br>\n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>​\t\t对一个图进行深拷贝时，我们可以对它进行遍历，并在遍历时进行拷贝，最后得到该图的深拷贝结果。</p>\n<p>​\t\t通过一个节点遍历一个连通图的有效方法为<a href=\"https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2?fromtitle=%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86&amp;fromid=9796166\">深度优先遍历 (DFS)</a> 和<a href=\"https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2?fromtitle=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86&amp;fromid=9796192\">广度优先遍历 (BFS)</a>。(层序遍历不适合无向图)</p>\n<p>​\t\t我们知道，无向图中，若 A、B 两点相连，则可以从 A 连接 B 也可以从 B 连接 A，这一点使得我们在使用深度优先遍历和广度优先遍历克隆 (深拷贝) 一个无向图时需要对结点进行标记，来代表它们是否已经被克隆过。</p>\n<p>​\t\t关于这一点的解决，最开始时想对每一个节点加一个 <code>tag</code>  来表示是否已经克隆过，后来发现不太行；之后也尝试了使用队列、栈和列表来实现 <code>tag</code> ，也没有达到想要的效果，最后选取了 ** <code>哈希表HashMap</code> ** 来实现对克隆的记录。</p>\n<p>​\t\t在 HashMap 中， <code>key</code> / <code>value</code>  分别为 <strong> <code>原始图节点</code>  / <code>克隆图节点</code> </strong>，这样表示比较清晰且便于查找 (也做过储存节点值 / 克隆图节点，但不如上文方法清晰)。我们从给定节点开始对图进行遍历。如果某个节点已经被访问过，则返回其克隆图中的对应节点 (查找 HashMap)。如果当前访问的节点不在哈希表中，则创建它的克隆节点并存储在哈希表中。<strong>注意：<strong>在需要递归的时候，克隆节点并保存在哈希表中的操作</strong>需要放在进入递归之前</strong>，不然有可能在递归中遇到相同的节点，陷入死循环 (再次遍历此节点)。</p>\n<p>​\t\t<strong>递归操作：<strong>在递归时，会递归每个节点的邻接点，递归次数由邻接点数量决定，每一次都返回对应邻接点的克隆节点 (注意：克隆前需要先</strong>判断该点是否已经被克隆过</strong>)，最后返回这些克隆节点的列表，放入对应克隆节点的邻接表中，这样就可以克隆给定的节点和其邻接点。</p>\n<h3 id=\"1深度优先遍历递归\"><a class=\"markdownIt-Anchor\" href=\"#1深度优先遍历递归\">#</a> 1. 深度优先遍历（递归）</h3>\n<p>​\t\t通过递归实现深度优先遍历，在遍历的中间对节点进行克隆并将克隆节点保存在哈希表中（<strong>注意克隆保存和进入递归的先后</strong>）</p>\n<h3 id=\"2广度优先遍历栈\"><a class=\"markdownIt-Anchor\" href=\"#2广度优先遍历栈\">#</a> 2. 广度优先遍历（栈）</h3>\n<p>​\t\t用栈实现广度优先遍历，这种做法不需要递归，但仍需要在遍历的中间对节点进行克隆并将克隆节点保存在哈希表中</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<h3 id=\"1深度优先遍历递归-2\"><a class=\"markdownIt-Anchor\" href=\"#1深度优先遍历递归-2\">#</a> 1. 深度优先遍历（递归）</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">public:</span></span><br><span class=\"line\"><span class=\"comment\">    int val;</span></span><br><span class=\"line\"><span class=\"comment\">    vector&lt;Node*&gt; neighbors;</span></span><br><span class=\"line\"><span class=\"comment\">    Node() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = 0;</span></span><br><span class=\"line\"><span class=\"comment\">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    Node(int _val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">        neighbors = _neighbors;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//定义一个哈希表来记录访问过的节点以及克隆过的节点</span></span><br><span class=\"line\">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class=\"line\">    <span class=\"function\">Node* <span class=\"title\">cloneGraph</span><span class=\"params\">(Node* node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(visited.<span class=\"built_in\">find</span>(node) != visited.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> visited[node];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 新建克隆节点并储存</span></span><br><span class=\"line\">        Node* cloneNode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(node -&gt; val);</span><br><span class=\"line\">        visited[node] = cloneNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> neighbor : node -&gt; neighbors) </span><br><span class=\"line\">            cloneNode -&gt; neighbors.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">cloneGraph</span>(neighbor));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> cloneNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"ac截图\"><a class=\"markdownIt-Anchor\" href=\"#ac截图\">#</a> AC 截图：</h5>\n<p><img src=\"https://s3.bmp.ovh/imgs/2022/01/585d97e015a7a791.png\" alt=\"\"></p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2022/01/e1246a181a6aed25.png\" alt=\"\"></p>\n<h3 id=\"2广度优先遍历栈-2\"><a class=\"markdownIt-Anchor\" href=\"#2广度优先遍历栈-2\">#</a> 2. 广度优先遍历（栈）</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">public:</span></span><br><span class=\"line\"><span class=\"comment\">    int val;</span></span><br><span class=\"line\"><span class=\"comment\">    vector&lt;Node*&gt; neighbors;</span></span><br><span class=\"line\"><span class=\"comment\">    Node() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = 0;</span></span><br><span class=\"line\"><span class=\"comment\">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    Node(int _val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">        neighbors = _neighbors;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class=\"line\">    <span class=\"function\">Node* <span class=\"title\">cloneGraph</span><span class=\"params\">(Node* node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 新建克隆节点并储存</span></span><br><span class=\"line\">        Node* cloneNode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(node -&gt; val);</span><br><span class=\"line\">        visited[node] = cloneNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 新建队列</span></span><br><span class=\"line\">        queue&lt;Node*&gt; que;</span><br><span class=\"line\">        <span class=\"comment\">// 节点入队</span></span><br><span class=\"line\">        que.<span class=\"built_in\">push</span>(node);</span><br><span class=\"line\">        <span class=\"comment\">// 如果队列不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!que.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取队首并出栈</span></span><br><span class=\"line\">            Node* temp = que.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> neighbor : temp -&gt; neighbors)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(visited.<span class=\"built_in\">find</span>(neighbor) == visited.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 新建克隆节点并入栈</span></span><br><span class=\"line\">                    visited[neighbor] = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(neighbor -&gt; val);</span><br><span class=\"line\">                    que.<span class=\"built_in\">push</span>(neighbor);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//更新克隆节点的邻居列表（在哈希表中找到该克隆节点并更新克隆节点的邻居列表）</span></span><br><span class=\"line\">                visited[temp] -&gt; neighbors.<span class=\"built_in\">push_back</span>(visited[neighbor]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cloneNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"ac截图-2\"><a class=\"markdownIt-Anchor\" href=\"#ac截图-2\">#</a> AC 截图：</h5>\n<p><img src=\"https://s3.bmp.ovh/imgs/2022/01/585d97e015a7a791.png\" alt=\"\"></p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2022/01/01cedf0345728be0.png\" alt=\"\"></p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> 题目总结</h2>\n<p>​\t\t做完这个题之后，我感觉主要思路就是对该图进行遍历并同时深拷贝，无论哪种遍历方法都需要给节点打上 tag 来标志该节点是否被克隆过（通过哈希表实现）。在深度优先遍历中使用递归时需要注意操作的先后顺序（克隆保存和进入递归的先后），否则会陷入死循环；广度优先遍历则不需要担心这一点。</p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/",
            "url": "http://example.com/passages/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/",
            "title": "最大正方形",
            "date_published": "2021-08-12T02:11:41.000Z",
            "content_html": "<h1 id=\"最大正方形\"><a class=\"markdownIt-Anchor\" href=\"#最大正方形\">#</a> <strong>最大正方形</strong></h1>\n<p>​\t\t大一 -&gt; 大二暑期算法作业</p>\n<p>​\t\t<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>\n<h2 id=\"看到题目的感想\"><a class=\"markdownIt-Anchor\" href=\"#看到题目的感想\">#</a> <strong>看到题目的感想</strong></h2>\n<p>​\t\t寻找最大正方形是小时候经常玩的一种游戏，说是可以锻炼观察力与判断力什么的，现在也会有家长带着小孩玩这个游戏，不过不是很多。</p>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> <strong>题目描述</strong></h2>\n<p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>\n<p>示例 1：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg\" alt=\"\"></p>\n<p>输入：matrix = [[“1”,“0”,“1”,“0”,“0”],[“1”,“0”,“1”,“1”,“1”],[“1”,“1”,“1”,“1”,“1”],[“1”,“0”,“0”,“1”,“0”]]<br>\n 输出：4</p>\n<p>示例 2：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg\" alt=\"\"></p>\n<p>输入：matrix = [[“0”,“1”],[“1”,“0”]]<br>\n 输出：1</p>\n<p>示例 3：</p>\n<p>输入：matrix = [[“0”]]<br>\n 输出：0</p>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/maximal-square\">https://leetcode-cn.com/problems/maximal-square</a><br>\n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"题目解答\"><a class=\"markdownIt-Anchor\" href=\"#题目解答\">#</a> <strong>题目解答</strong></h2>\n<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>\n<h3 id=\"1-暴力计算\"><a class=\"markdownIt-Anchor\" href=\"#1-暴力计算\">#</a> 1、<strong>暴力计算</strong></h3>\n<h4 id=\"1解题思路\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路\">#</a> <strong>（1）解题思路</strong></h4>\n<p>语言描述不是很棒，大家凑活看叭，┭┮﹏┭┮</p>\n<p>想了想，暴力计算是最简单直观的做法，具体做法如下：</p>\n<ol>\n<li>遍历矩阵中的元素，当遇到 1 时，将该元素作为正方形的左上角的位置。</li>\n<li>确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围 - 不能超出矩阵的行和列），在该范围内寻找只包含 1 的最大正方形；</li>\n<li>每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 1。（方便起见，需要先判断选取的点的右下角的点是否为 1。若不是，则跳出本次循环并储存当前的最大正方形，找到下一个元素是 1 的节点作为左上角点，重复 2、3 步；若是，则判断下一行和右一列的其他元素是否都为 1 <strong>（注：这里不是下一行右一列的所有元素，而是初始左上角和以当前点为右下角的正方形的范围内的点，如下图）</strong> ，若不都为 1，则跳出本次循环并储存当前的最大正方形，找到下一个元素是 1 的节点作为左上角点，重复 2、3 步；若都为 1，则继续第 3 步）。</li>\n</ol>\n<h4 id=\"2代码\"><a class=\"markdownIt-Anchor\" href=\"#2代码\">#</a> <strong>（2）代码</strong></h4>\n<p><strong>配合题目链接食用</strong></p>\n<h5 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\">#</a> java</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maximalSquare</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSide = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"keyword\">null</span> || matrix.length == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 没有矩阵或矩阵大小为0时</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> maxSide;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = matrix.length, columns = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; columns; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) &#123; <span class=\"comment\">// 遇到一个 1 作为正方形的左上角</span></span><br><span class=\"line\">                    maxSide = Math.max(maxSide, <span class=\"number\">1</span>); <span class=\"comment\">// 更新可能的最大正方形边长</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> currentMaxSide = Math.min(rows - i, columns - j); <span class=\"comment\">// 当前最大正方形边长</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt; currentMaxSide; k++) &#123; <span class=\"comment\">// 判断新增的一行一列是否均为 1</span></span><br><span class=\"line\">                        <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (matrix[i + k][j + k] == <span class=\"string\">&#x27;0&#x27;</span>) &#123; <span class=\"comment\">// 判断右下角的点</span></span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt; k; m++) &#123; <span class=\"comment\">// 判断下一行右一列</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (matrix[i + k][j + m] == <span class=\"string\">&#x27;0&#x27;</span> || matrix[i + m][j + k] == <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">                                flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (flag) &#123; <span class=\"comment\">// 若判断都是1，则更新，不是则退出本次循环，寻找下一个左上角</span></span><br><span class=\"line\">                            maxSide = Math.max(maxSide, k + <span class=\"number\">1</span>); <span class=\"comment\">// 更新可能的最大正方形边长</span></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSquare = maxSide * maxSide;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSquare;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/185126/31/21226/19810/61284443E0d3f0dfd/b2db3058f56d7f8b.png\" alt=\"image-20210827093335340.png\"></p>\n<h4 id=\"3总结\"><a class=\"markdownIt-Anchor\" href=\"#3总结\">#</a> <strong>（3）总结</strong></h4>\n<p>​\t\t暴力的思路比其他方法简单（但是我的描述可能会有些不顺畅），但是效率不高。</p>\n<h3 id=\"2-dp算法动态规划来自题解\"><a class=\"markdownIt-Anchor\" href=\"#2-dp算法动态规划来自题解\">#</a> <strong>2、dp 算法（动态规划）（来自题解）</strong></h3>\n<p>​\t\t又一次见到了动态规划，还是有无从下手的感觉。</p>\n<h4 id=\"1解题思路-2\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路-2\">#</a> <strong>（1）解题思路</strong></h4>\n<p>​\t\t方法一虽然直观，但是时间复杂度太高，有没有办法降低时间复杂度呢？</p>\n<p>可以使用动态规划降低时间复杂度。我们用 dp (i,j) 表示以 (i,j) 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp (i,j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p>\n<p>那么如何计算 dp 中的每个元素值呢？对于每个位置 (i,j)，检查在矩阵中该位置的值：</p>\n<ul>\n<li>\n<p>如果该位置的值是 0，则 dp (i,j)=0，因为当前位置不可能在由 1 组成的正方形中；</p>\n</li>\n<li>\n<p>如果该位置的值是 11，则 dp (i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p>\n<p>​\tdp(i,j) = min( dp(i−1,j) , dp(i−1,j−1) , dp(i,j−1) ) + 1</p>\n<p>如果读者对这个状态转移方程感到不解，<a href=\"https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-2/\">可以参考 1277. 统计全为 1 的正方形子矩阵的官方题解</a>，其中给出了详细的证明。</p>\n</li>\n</ul>\n<p>此外，还需要考虑边界条件。如果 i 和 j 中至少有一个为 0，则以位置 (i, j)(i,j) 为右下角的最大正方形的边长只能是 11，因此 dp (i,j)=1。</p>\n<p>以下用一个例子具体说明。原始矩阵如下。</p>\n<p>0 1 1 1 0<br>\n1 1 1 1 0<br>\n0 1 1 1 1<br>\n0 1 1 1 1<br>\n0 0 1 1 1<br>\n 对应的 dp 值如下。</p>\n<p>0 1 1 1 0<br>\n1 1 2 2 0<br>\n0 1 2 3 1<br>\n0 1 2 3 2<br>\n0 0 1 2 3</p>\n<p>下图也给出了计算 dp 值的过程。</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/221/221_fig1.png\" alt=\"\"></p>\n<h4 id=\"2代码-2\"><a class=\"markdownIt-Anchor\" href=\"#2代码-2\">#</a> <strong>（2）代码</strong></h4>\n<p><strong>配合题目链接食用</strong></p>\n<h5 id=\"java-2\"><a class=\"markdownIt-Anchor\" href=\"#java-2\">#</a> Java</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maximalSquare</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSide = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"keyword\">null</span> || matrix.length == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> maxSide;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = matrix.length, columns = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[rows][columns];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; columns; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        dp[i][j] = Math.min(Math.min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]), dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSquare = maxSide * maxSide;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSquare;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode-Solution</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<h5 id=\"c\"><a class=\"markdownIt-Anchor\" href=\"#c\">#</a> C++</h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximalSquare</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSide = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = matrix.<span class=\"built_in\">size</span>(), columns = matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(rows, vector&lt;<span class=\"keyword\">int</span>&gt;(columns));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; columns; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        dp[i][j] = <span class=\"built_in\">min</span>(<span class=\"built_in\">min</span>(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]), dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    maxSide = <span class=\"built_in\">max</span>(maxSide, dp[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSquare = maxSide * maxSide;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSquare;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode-Solution</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<h4 id=\"3总结-2\"><a class=\"markdownIt-Anchor\" href=\"#3总结-2\">#</a> <strong>（3）总结</strong></h4>\n<p>​\t\t动态规划解题的思想还需要学习，现在还上不了手。</p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> <strong>题目总结</strong></h2>\n<p>​\t\t这次的题目是数最大正方形，暴力方法还是最先考虑到的，之后菜知道动态规划也可以解决。（动态规划现在还属实不会）</p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/passages/%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/",
            "title": "太平洋大西洋水流问题",
            "date_published": "2021-08-05T11:30:57.000Z",
            "content_html": "<h1 id=\"太平洋大西洋水流问题\"><a class=\"markdownIt-Anchor\" href=\"#太平洋大西洋水流问题\">#</a> 太平洋大西洋水流问题</h1>\n<p>​\t\t大一 -&gt; 大二暑期算法作业</p>\n<p>​\t\t<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>\n<h2 id=\"看到题目的感想\"><a class=\"markdownIt-Anchor\" href=\"#看到题目的感想\">#</a> 看到题目的感想</h2>\n<p>​\t\t刚看到这个题目的时候感觉他不是很熟悉，没有见过类似的题目，也没有见过类似的场景，感觉有点意思。</p>\n<p>​\t\t题目不算很长，但感觉难度不小。</p>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h2>\n<p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。</p>\n<p><strong>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</strong></p>\n<p>请找出那些水流<strong>既可以</strong>流动到 “太平洋”，<strong>又能</strong>流动到 “大西洋” 的陆地单元的坐标。</p>\n<p>提示：</p>\n<p>输出坐标的<strong>顺序不重要</strong><br>\n m 和 n 都<strong>小于 150</strong></p>\n<p>示例：</p>\n<p>给定下面的 5x5 矩阵:</p>\n<dl>\n<dt>太平洋～~   ~   ~   ~</dt>\n<dd>1   2   2   3  (5) /</dd>\n<dd>3   2   3  (4) (4) /</dd>\n<dd>2   4  (5)  3   1  /</dd>\n<dd>(6) (7)  1   4   5  /</dd>\n<dd>(5)  1   1   2   4  /</dd>\n</dl>\n<p>​            /    /    /    /    /   大西洋</p>\n<p>返回:</p>\n<p>[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元). （序号先左后上）</p>\n<h2 id=\"题目解答\"><a class=\"markdownIt-Anchor\" href=\"#题目解答\">#</a> 题目解答</h2>\n<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>\n<h3 id=\"逆流而上\"><a class=\"markdownIt-Anchor\" href=\"#逆流而上\">#</a> 逆流而上</h3>\n<p>​\t\t最开始的名字叫<strong>逆着水流向上找</strong>，后面才想起来有<strong>逆流而上</strong>这个成语，才改了名字。</p>\n<p>​\t\t最开始浮现的思路是想暴力解题，后来发现暴力解题太过于麻烦，效率也不高，索性就放弃了。之后才有的现在这个想法。</p>\n<h3 id=\"1解题思路\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路\">#</a> （1）解题思路</h3>\n<p>​\t\t本题找的是<strong>能够让水流留到两片水域</strong>的陆地单元的位置坐标，那么既然水能过去，那我们反过来找，<strong>分别找到两个水域的水能流到的地方，之后取交集</strong>，就得到了我们想要的答案。</p>\n<h3 id=\"2代码\"><a class=\"markdownIt-Anchor\" href=\"#2代码\">#</a> （2）代码</h3>\n<p><strong>配合题目链接食用</strong></p>\n<h4 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\">#</a> Java</h4>\n<p><strong>注：这个代码在 idea 上可以正常运行，但在力扣上会有报错。报错如下：</strong></p>\n<p>error: incompatible types: List&lt;int[]&gt; cannot be converted to List&lt;List<Integer>&gt; [in <strong>Driver</strong>.java]</p>\n<p>List&lt;List<Integer>&gt; ret = new Solution().pacificAtlantic(param_1);</p>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/197276/28/5074/29323/612842a4E395ba9f9/a2ea88eb469c810c.png\" alt=\"image-20210827093245188.png\"></p>\n<p><strong>List &amp; ArrayList：<a href=\"https://www.jianshu.com/p/25aa92f8d681\">https://www.jianshu.com/p/25aa92f8d681</a> 来源：简书</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">public</span> List&lt;<span class=\"keyword\">int</span>[]&gt; pacificAtlantic(<span class=\"keyword\">int</span>[][] matrix) &#123;</span><br><span class=\"line\">                List&lt;<span class=\"keyword\">int</span>[]&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(); <span class=\"comment\">// 储存最终数据</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> m = matrix.length; <span class=\"comment\">// 获取矩阵一边的长度</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(m &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ret; <span class=\"comment\">// 矩阵大小为0时</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> n = matrix[<span class=\"number\">0</span>].length; <span class=\"comment\">// 获取矩阵另一边的长度</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span>[][] Pacific = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[m][n]; <span class=\"comment\">// 太平洋的</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span>[][] Atlantic = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[m][n]; <span class=\"comment\">// 大西洋的</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123; <span class=\"comment\">// 递归判断一条边</span></span><br><span class=\"line\">                    dfs(matrix, i, <span class=\"number\">0</span>, Pacific, matrix[i][<span class=\"number\">0</span>]);</span><br><span class=\"line\">                    dfs(matrix, i, n-<span class=\"number\">1</span>, Atlantic, matrix[i][n-<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123; <span class=\"comment\">// 递归判断另一条边</span></span><br><span class=\"line\">                    dfs(matrix, <span class=\"number\">0</span>, i, Pacific, matrix[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">                    dfs(matrix, m-<span class=\"number\">1</span>, i, Atlantic, matrix[m-<span class=\"number\">1</span>][i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123; <span class=\"comment\">// 取交集得到最终结果</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j)</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(Pacific[i][j] &amp;&amp; Atlantic[i][j])</span><br><span class=\"line\">                            ret.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i, j&#125;); <span class=\"comment\">// 放入数据</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret; <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] m, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">boolean</span>[][] visited, <span class=\"keyword\">int</span> pre)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 超出边界 或 判断过是可以的 或 不能继续向上流动，则返回</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span> || x &gt;= m.length || y &gt;= m[<span class=\"number\">0</span>].length || visited[x][y] || m[x][y] &lt; pre)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                visited[x][y] = <span class=\"keyword\">true</span>; <span class=\"comment\">// 可以向上流</span></span><br><span class=\"line\">                dfs(m, x+<span class=\"number\">1</span>, y, visited, m[x][y]); <span class=\"comment\">// 递归判断相邻行或列</span></span><br><span class=\"line\">                dfs(m, x-<span class=\"number\">1</span>, y, visited, m[x][y]); <span class=\"comment\">// 递归判断相邻行或列</span></span><br><span class=\"line\">                dfs(m, x, y+<span class=\"number\">1</span>, visited, m[x][y]); <span class=\"comment\">// 递归判断相邻行或列</span></span><br><span class=\"line\">                dfs(m, x, y-<span class=\"number\">1</span>, visited, m[x][y]); <span class=\"comment\">// 递归判断相邻行或列</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3总结\"><a class=\"markdownIt-Anchor\" href=\"#3总结\">#</a> （3）总结</h3>\n<p>​\t\t这个解题思路来看的话感觉还是可以的，就是会有一些<strong>奇怪的 bug</strong>，不知道怎么肥四。</p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> 题目总结</h2>\n<p>​\t\t这个题目难度比之前的大一些，不好做，包括写的时候也查了一些资料（<strong>运用不熟练</strong>），好在最后搞出来了（虽然有一些奇怪的 bug）。</p>\n<p>​\t\t（<strong>递归真香</strong>）</p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/",
            "url": "http://example.com/passages/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/",
            "title": "罗马数字转整数",
            "date_published": "2021-07-24T00:49:38.000Z",
            "content_html": "<h1 id=\"罗马数字转整数\"><a class=\"markdownIt-Anchor\" href=\"#罗马数字转整数\">#</a> 罗马数字转整数</h1>\n<p>​\t\t大一 -&gt; 大二暑期算法作业</p>\n<p>​\t\t<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>\n<h2 id=\"看到题目的想法\"><a class=\"markdownIt-Anchor\" href=\"#看到题目的想法\">#</a> 看到题目的想法</h2>\n<p>​\t\t这个题目看起来挺有意思的，但是好像不好解。</p>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h2>\n<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>数值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>I</td>\n<td>1</td>\n</tr>\n<tr>\n<td>V</td>\n<td>5</td>\n</tr>\n<tr>\n<td>X</td>\n<td>10</td>\n</tr>\n<tr>\n<td>L</td>\n<td>50</td>\n</tr>\n<tr>\n<td>C</td>\n<td>100</td>\n</tr>\n<tr>\n<td>D</td>\n<td>500</td>\n</tr>\n<tr>\n<td>M</td>\n<td>1000</td>\n</tr>\n</tbody>\n</table>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<ol>\n<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>\n<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li>\n<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>\n</ol>\n<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>\n<p><strong>示例 1:</strong></p>\n<p>输入: “III”<br>\n 输出: 3</p>\n<p><strong>示例 2:</strong></p>\n<p>输入: “IV”<br>\n 输出: 4</p>\n<p><strong>示例 3:</strong></p>\n<p>输入: “IX”<br>\n 输出: 9</p>\n<p><strong>示例 4:</strong></p>\n<p>输入: “LVIII”<br>\n 输出: 58</p>\n<p>解释: L = 50, V= 5, III = 3.</p>\n<p><strong>示例 5:</strong></p>\n<p>输入: “MCMXCIV”<br>\n 输出: 1994<br>\n 解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>\n<p><strong>提示：</strong></p>\n<ol>\n<li>1 &lt;= s.length &lt;= 15</li>\n<li>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)</li>\n<li>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内</li>\n<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>\n<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>\n<li>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/roman-to-integer\">https://leetcode-cn.com/problems/roman-to-integer</a><br>\n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"题目解答\"><a class=\"markdownIt-Anchor\" href=\"#题目解答\">#</a> 题目解答</h2>\n<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>\n<h3 id=\"1暴力解题\"><a class=\"markdownIt-Anchor\" href=\"#1暴力解题\">#</a> 1. 暴力解题</h3>\n<h4 id=\"1解题思路\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路\">#</a> （1）解题思路</h4>\n<p>​\t\t想了想还是选择了暴力解题（<strong>比较简单</strong>。</p>\n<p>​\t\t将特殊情况转为另一个<strong>不在   I， V， X， L，C，D 和 M</strong>  中的单独的字母；再重新挨个求和。</p>\n<h4 id=\"2-代码\"><a class=\"markdownIt-Anchor\" href=\"#2-代码\">#</a> （2） 代码</h4>\n<p>​\t\t<strong>配合题目链接食用</strong></p>\n<p><strong>C++</strong></p>\n<p><strong>earse：</strong><a href=\"https://www.cnblogs.com/ylwn817/articles/1967689.html\">C++ 中 string erase 函数的使用 (转载) - jackdesk - 博客园 (cnblogs.com)</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++) <span class=\"comment\">// 将特殊情况转换</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;I&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;V&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;H&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;I&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;X&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;J&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;X&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;L&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;O&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;X&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;Q&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;C&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;D&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;C&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;M&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;B&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++) <span class=\"comment\">// 挨个求和</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">switch</span></span>(s[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;I&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;V&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">5</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;X&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">10</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;L&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">50</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;C&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">100</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;D&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">500</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;M&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">1000</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;H&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">4</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;J&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">9</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;O&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">40</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Q&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">90</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;A&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">400</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;B&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">900</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/177610/31/20874/22139/612842cbEa0f226ee/d8b14650ce07f5ff.png\" alt=\"image-20210827092938870.png\"></p>\n<h4 id=\"3总结\"><a class=\"markdownIt-Anchor\" href=\"#3总结\">#</a> （3）总结</h4>\n<p>​\t\t暴力计算的方法想起来并不复杂，但是写起来麻烦（重复、相似比较多），而且代码的性能也不高，所以还是不建议采用暴力算法。</p>\n<h3 id=\"2模拟来自题解\"><a class=\"markdownIt-Anchor\" href=\"#2模拟来自题解\">#</a> 2. 模拟（来自题解）</h3>\n<p>​\t\t很巧妙的一种方法，看完之后情不自禁的妙了起来。</p>\n<p>​\t\t<strong>妙<sub>啊</sub>～</strong></p>\n<p><strong>官方题解：<a href=\"https://leetcode-cn.com/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/\">https://leetcode-cn.com/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/</a></strong></p>\n<h4 id=\"1解题思路-2\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路-2\">#</a> （1）解题思路</h4>\n<p>** 通常情况下，罗马数字中小的数字在大的数字的右边。** 若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。</p>\n<p>例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。</p>\n<p>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，<strong>若一个数字右侧的数字比它大，则将该数字的符号取反。</strong></p>\n<p>例如 XIV 可视作 X−I+V=10−1+5=14。</p>\n<h4 id=\"2代码\"><a class=\"markdownIt-Anchor\" href=\"#2代码\">#</a> （2）代码</h4>\n<p>这里用到了<strong> map</strong> 这个东西，可以看看</p>\n<h5 id=\"c\"><a class=\"markdownIt-Anchor\" href=\"#c\">#</a> C++</h5>\n<p><strong>C++map： <a href=\"https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html\">https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html</a>  来源：某 C ++ 文档</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    map&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; symbolValues = &#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;I&#x27;</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;V&#x27;</span>, <span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;X&#x27;</span>, <span class=\"number\">10</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;L&#x27;</span>, <span class=\"number\">50</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"number\">100</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;D&#x27;</span>, <span class=\"number\">500</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;M&#x27;</span>, <span class=\"number\">1000</span>&#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> value = symbolValues[s[i]];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; n - <span class=\"number\">1</span> &amp;&amp; value &lt; symbolValues[s[i + <span class=\"number\">1</span>]]) &#123;</span><br><span class=\"line\">                ans -= value;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans += value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/196645/13/19919/22179/612842e5E892666a7/8ed9cac439b0d859.png\" alt=\"image-20210827093012125.png\"></p>\n<h5 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\">#</a> Java</h5>\n<p><strong>java map：<a href=\"https://blog.csdn.net/qq_29373285/article/details/81487594\">https://blog.csdn.net/qq_29373285/article/details/81487594</a></strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    Map&lt;Character, Integer&gt; symbolValues = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;I&#x27;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;V&#x27;</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;X&#x27;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;L&#x27;</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;D&#x27;</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;M&#x27;</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> value = symbolValues.get(s.charAt(i));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; n - <span class=\"number\">1</span> &amp;&amp; value &lt; symbolValues.get(s.charAt(i + <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                ans -= value;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans += value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/196645/13/19919/22179/612842e5E892666a7/8ed9cac439b0d859.png\" alt=\"image-20210827093028025.png\"></p>\n<h4 id=\"3总结-2\"><a class=\"markdownIt-Anchor\" href=\"#3总结-2\">#</a> （3）总结</h4>\n<p>​\t\t很巧妙地方法，是我没想到的，很棒。</p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> 题目总结</h2>\n<p>​\t\t听题解说是很经典的字符串匹配的题目，感觉很有意思，就是没有想到巧妙地方法。需要再接再厉。</p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/%E7%88%AC%E6%A5%BC%E6%A2%AF/",
            "url": "http://example.com/passages/%E7%88%AC%E6%A5%BC%E6%A2%AF/",
            "title": "爬楼梯",
            "date_published": "2021-07-19T07:24:26.000Z",
            "content_html": "<h1 id=\"爬楼梯\"><a class=\"markdownIt-Anchor\" href=\"#爬楼梯\">#</a> 爬楼梯</h1>\n<p>​\t\t大一 -&gt; 大二暑期算法作业</p>\n<p>​\t\t<strong>本文档中有对动态规划的解读（来自题解）</strong></p>\n<p>​\t\t<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>\n<h2 id=\"看到题目的想法\"><a class=\"markdownIt-Anchor\" href=\"#看到题目的想法\">#</a> 看到题目的想法</h2>\n<p>​\t\t这是一道比较经典的题目，之前好像见过类似的题目，所以上手还是有一些思路的。</p>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h2>\n<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p><strong>注意</strong>：给定 n 是一个正整数。</p>\n<p><strong>示例 1：</strong></p>\n<p>输入： 2<br>\n 输出： 2<br>\n 解释： 有两种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶</li>\n<li>2 阶</li>\n</ol>\n<p><strong>示例 2：</strong></p>\n<p>输入： 3<br>\n 输出： 3<br>\n 解释： 有三种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶 + 1 阶</li>\n<li>1 阶 + 2 阶</li>\n<li>2 阶 + 1 阶</li>\n<li></li>\n</ol>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/climbing-stairs\">https://leetcode-cn.com/problems/climbing-stairs</a><br>\n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"题目解答\"><a class=\"markdownIt-Anchor\" href=\"#题目解答\">#</a> 题目解答</h2>\n<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>\n<h3 id=\"1动态规划\"><a class=\"markdownIt-Anchor\" href=\"#1动态规划\">#</a> 1. 动态规划</h3>\n<h4 id=\"1解题思路\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路\">#</a> （1）解题思路</h4>\n<p>​       刚开始事项用递归写一下的，后来发现递归会超时，于是选用了动态规划。</p>\n<p>​       这是一道典型的动态规划题，<strong>由于每步只能走一或两阶台阶，所以到达这一阶的方法数是 跨一阶到达 + 跨两阶到达</strong>。所以走到第一阶有一种方法，走到第二阶有两种方法，<strong>从第三阶开始</strong>，每一阶的方法数等于前两阶的方法数的代数和（跨一阶到达 + 跨两阶到达）（ps：可以用数组储存，但没必要，因为我们需要的是最终结果。</p>\n<p>​       （有斐波那契那味了。</p>\n<h4 id=\"2代码\"><a class=\"markdownIt-Anchor\" href=\"#2代码\">#</a> （2）代码</h4>\n<p>​\t\t由于思路比较简单，也是顺利的写出了代码。（<strong>配合题目链接食用</strong>）</p>\n<h5 id=\"c\"><a class=\"markdownIt-Anchor\" href=\"#c\">#</a> C++</h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123; <span class=\"comment\">// 遍历计算直到算出想要的结果</span></span><br><span class=\"line\">            p = q; </span><br><span class=\"line\">            q = r; </span><br><span class=\"line\">            r = p + q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r; <span class=\"comment\">// 返回想要的结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img14.360buyimg.com/ddimg/jfs/t1/178109/1/21048/19824/612843b1Ebbddf701/64ca411d00d898bb.png\" alt=\"image-20210827092530062.png\"></p>\n<h5 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\">#</a> Java</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123; <span class=\"comment\">// 遍历计算直到算出想要的结果</span></span><br><span class=\"line\">            p = q; </span><br><span class=\"line\">            q = r; </span><br><span class=\"line\">            r = p + q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r; <span class=\"comment\">// 返回想要的结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img13.360buyimg.com/ddimg/jfs/t1/192688/38/20306/19931/612843c8Ead5d61e5/fbbd50516680a252.png\" alt=\"image-20210827092554179.png\"></p>\n<h5 id=\"c-2\"><a class=\"markdownIt-Anchor\" href=\"#c-2\">#</a> C</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123; <span class=\"comment\">// 遍历计算直到算出想要的结果</span></span><br><span class=\"line\">        p = q;</span><br><span class=\"line\">        q = r;</span><br><span class=\"line\">        r = p + q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r; <span class=\"comment\">// 返回想要的结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/181789/27/21163/20033/612843d9E4033bcc2/15eb1d8b958eb431.png\" alt=\"image-20210827092619237.png\"></p>\n<h4 id=\"3总结\"><a class=\"markdownIt-Anchor\" href=\"#3总结\">#</a> （3）总结</h4>\n<p>​\t\t这样直接计算的方法思路很简单，但是问题是计算的结果无法保留，用一次就要重新计算一次，十分的不方便。</p>\n<h3 id=\"2斐波那契数列\"><a class=\"markdownIt-Anchor\" href=\"#2斐波那契数列\">#</a> 2. 斐波那契数列</h3>\n<h4 id=\"1解题思路-2\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路-2\">#</a> （1）解题思路</h4>\n<p>​\t\t不难看出，此题的数据就是我们熟悉的<strong>斐波那契数列</strong>，因此我们可以<strong>借助斐波那契数列的通项公式</strong>来快速算出我们想要的结果（前一种解发是从头计算出来的，台阶数较大时效率低  。</p>\n<p>​\t\t这种方法简单粗暴，就是通项公式不好记。</p>\n<p>​\t\t通项公式的推导过程就不写了，可以去题解里面看一下。+</p>\n<p><strong>题目链接（去看官方题解）：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/\">https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</a></strong></p>\n<h4 id=\"2代码-2\"><a class=\"markdownIt-Anchor\" href=\"#2代码-2\">#</a> （2）代码</h4>\n<h5 id=\"c-3\"><a class=\"markdownIt-Anchor\" href=\"#c-3\">#</a> C++</h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> sqrt5 = <span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> fibn = <span class=\"built_in\">pow</span>((<span class=\"number\">1</span> + sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>) - <span class=\"built_in\">pow</span>((<span class=\"number\">1</span> - sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>); <span class=\"comment\">// 斐波那契数列通项公式</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)<span class=\"built_in\">round</span>(fibn / sqrt5); <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/186997/39/20254/20066/612843eaE3f9c5968/88a470ca748a910b.png\" alt=\"image-20210827092637917.png\"></p>\n<h5 id=\"java-2\"><a class=\"markdownIt-Anchor\" href=\"#java-2\">#</a> Java</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> sqrt5 = Math.sqrt(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> fibn = Math.pow((<span class=\"number\">1</span> + sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>) - Math.pow((<span class=\"number\">1</span> - sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>); <span class=\"comment\">// 斐波那契数列通项公式</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) Math.round(fibn / sqrt5); <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img13.360buyimg.com/ddimg/jfs/t1/197749/9/5098/19966/612843f7E025f4b3d/8647b6a5672410fd.png\" alt=\"image-20210827092704192.png\"></p>\n<h5 id=\"c-4\"><a class=\"markdownIt-Anchor\" href=\"#c-4\">#</a> C</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> sqrt5 = <span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> fibn = <span class=\"built_in\">pow</span>((<span class=\"number\">1</span> + sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>) - <span class=\"built_in\">pow</span>((<span class=\"number\">1</span> - sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>); <span class=\"comment\">// 斐波那契数列通项公式</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) round(fibn / sqrt5); <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img12.360buyimg.com/ddimg/jfs/t1/197249/18/5090/19858/61284418E58cc0b79/4adf3d43edded4c7.png\" alt=\"image-20210827092720313.png\"></p>\n<h4 id=\"3总结-2\"><a class=\"markdownIt-Anchor\" href=\"#3总结-2\">#</a> （3）总结</h4>\n<p>​\t\t这种解决办法方便快捷，也不会浪费多余的时间空间来计算，比较好用。<strong>（缺点就是通项公式并不容易记住）</strong></p>\n<h3 id=\"3矩阵快速幂来自题解\"><a class=\"markdownIt-Anchor\" href=\"#3矩阵快速幂来自题解\">#</a> 3. 矩阵快速幂（来自题解）</h3>\n<h4 id=\"1解题思路-代码\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路-代码\">#</a> （1）解题思路 + 代码</h4>\n<p>​\t\t说实话，行看到这种方法的时候<strong>感觉回到了线性代数的课堂上</strong>，又是熟悉的矩阵操作，让人头疼</p>\n<p>​\t\t具体的解题思路和代码就不搬过来了，可以去<strong>官方题解</strong>下查看。</p>\n<p><strong>题目链接（去看官方题解）：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/\">https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</a></strong></p>\n<h4 id=\"2总结\"><a class=\"markdownIt-Anchor\" href=\"#2总结\">#</a> （2）总结</h4>\n<p>​\t\t<strong>利用矩阵运算解题</strong>的方法还是没见过的，对我来说比较新奇，还需要认真的研究研究。</p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> 题目总结</h2>\n<p>​\t\t这道题的难度中规中矩，但也会有很奇妙很方便的解决方案，也让我知道了<strong>运用矩阵运算来解题</strong>的方法，很棒。</p>\n<h2 id=\"拓展动态规划摘自题解\"><a class=\"markdownIt-Anchor\" href=\"#拓展动态规划摘自题解\">#</a> 拓展（动态规划）（摘自题解）</h2>\n<p>​\t\t<strong>本部分附带原作者对本题的总结</strong></p>\n<p>不少同学对动态规划还处于朦胧状态，我特意<strong>录了一期视频</strong>，讲一讲<strong>动态规划解题方法论</strong>，这里详细介绍了动规五部曲，相信结合本篇题解，会对你学习动态规划有所帮助。</p>\n<p><strong>视频链接：<a href=\"https://www.bilibili.com/video/BV13Q4y197Wg\">https://www.bilibili.com/video/BV13Q4y197Wg</a>)</strong></p>\n<p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目 AC 之后，都不太清楚 dp [i] 表示的是什么。</p>\n<p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中。</strong></p>\n<p>状态转移公式（递推公式）是很重要，但动规<strong>不仅仅只有</strong>递推公式。</p>\n<p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>\n<ol>\n<li>确定 dp 数组（dp table）以及下标的含义</li>\n<li>确定递推公式</li>\n<li>dp 数组如何初始化</li>\n<li>确定遍历顺序</li>\n<li>举例推导 dp 数组</li>\n</ol>\n<p>一些同学可能想<strong>为什么要先确定递推公式，然后在考虑初始化</strong>呢？</p>\n<p><strong>因为一些情况是递推公式决定了 dp 数组要如何初始化！</strong></p>\n<p>后面的讲解中我都是围绕着这五点来进行讲解。</p>\n<p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p>\n<p>其实 确定递推公式 仅仅是解题里的一步而已！</p>\n<p>一些同学知道递推公式，但搞不清楚 dp 数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p>\n<p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p>\n<h3 id=\"动态规划应该如何debug\"><a class=\"markdownIt-Anchor\" href=\"#动态规划应该如何debug\">#</a> 动态规划应该如何 debug</h3>\n<p>相信动规的题目，很大部分同学都是这样做的。</p>\n<p>看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp 数组的初始化，递归公式，遍历顺序，处于一种黑盒的理解状态。</p>\n<p><strong>写动规题目，代码出问题很正常！</strong></p>\n<p><strong>找问题的最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p>\n<p>一些同学对于 dp 的学习是黑盒的状态，就是不清楚 dp 数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。</p>\n<p>这是一个很不好的习惯！</p>\n<p><strong>做动规的题目，写代码之前一定要把状态转移在 dp 数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。</strong></p>\n<p>然后再写代码，如果代码没通过就打印 dp 数组，看看是不是和自己预先推导的哪里不一样。</p>\n<p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p>\n<p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p>\n<p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了。</strong></p>\n<p>这也是我为什么在动规五步曲里强调推导 dp 数组的重要性。</p>\n<p>举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？</p>\n<p>发出这样的问题之前，其实可以自己先思考这三个问题：</p>\n<ul>\n<li>这道题目我举例推导状态转移公式了么？</li>\n<li>我打印 dp 数组的日志了么？</li>\n<li>打印出来了 dp 数组和我想的一样么？</li>\n</ul>\n<p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历 dp 数组的顺序。</p>\n<p>然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。</p>\n<p><strong>注意这里不是说不让大家问问题哈， 而是说问问题之前要有自己的思考，问题要问到点子上！</strong></p>\n<p><strong>大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！</strong></p>\n<p>如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。</p>\n<p>所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何 debug。</p>\n<p>动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。</p>\n<p>在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的 01 背包，leetcode 上的题目都是 01 背包的应用，而没有纯 01 背包的问题，那么就需要在把对应的理论知识讲解一下。</p>\n<p>大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。</p>\n<p>这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容，大家要重视起来哈。</p>\n<h3 id=\"原作者对本题总结\"><a class=\"markdownIt-Anchor\" href=\"#原作者对本题总结\">#</a> 原作者对本题总结</h3>\n<p>这道题目和动态规划：斐波那契数题目基本是一样的，但是会发现本题相比动态规划：斐波那契数难多了，为什么呢？</p>\n<p>关键是 动态规划：斐波那契数 题目描述就已经把动规五部曲里的递归公式和如何初始化都给出来了，剩下几部曲也自然而然的推出来了。</p>\n<p>而本题，就需要逐个分析了，大家现在应该初步感受出关于动态规划，你该了解这些！里给出的动规五部曲了。</p>\n<p>简单题是用来掌握方法论的，例如昨天斐波那契的题目够简单了吧，但昨天和今天可以使用一套方法分析出来的，这就是方法论！</p>\n<p>所以不要轻视简单题，那种凭感觉就刷过去了，其实和没掌握区别不大，只有掌握方法论并说清一二三，才能触类旁通，举一反三哈！</p>\n<h3 id=\"原作者的题目解答\"><a class=\"markdownIt-Anchor\" href=\"#原作者的题目解答\">#</a> 原作者的题目解答</h3>\n<p><strong>原作者的题目解答：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/solution/dai-ma-sui-xiang-lu-dong-tai-gui-hua-jin-y1hw/\">https://leetcode-cn.com/problems/climbing-stairs/solution/dai-ma-sui-xiang-lu-dong-tai-gui-hua-jin-y1hw/</a></strong></p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/",
            "url": "http://example.com/passages/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/",
            "title": "二叉树的中序遍历",
            "date_published": "2021-07-15T02:43:29.000Z",
            "content_html": "<h1 id=\"二叉树的中序遍历\"><a class=\"markdownIt-Anchor\" href=\"#二叉树的中序遍历\">#</a> 二叉树的中序遍历</h1>\n<p>​\t\t大一 -&gt; 大二暑期算法作业</p>\n<p>​\t\t<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>\n<h2 id=\"看到题目的感想\"><a class=\"markdownIt-Anchor\" href=\"#看到题目的感想\">#</a> 看到题目的感想</h2>\n<p>​\t\t被离散数学<strong>折磨</strong>之后看见树就会想到离散数学，虽然学习离散数学的时候老师<strong>教过中序遍历</strong>，但是看到这个题的时候还是<strong>没有想起来</strong>中序遍历是个啥，索性就去搜索了一下（快进到被老师打死）。</p>\n<p>​\t\t附上百度百科链接：</p>\n<p>​\t\t<strong>中序遍历：<a href=\"https://baike.baidu.com/item/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86\">https://baike.baidu.com/item/ 中序遍历</a></strong></p>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h2>\n<p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" alt=\"img\"></p>\n<p>输入：root = [1,null,2,3]<br>\n 输出：[1,3,2]</p>\n<p><strong>示例 2：</strong></p>\n<p>输入：root = []<br>\n 输出：[]</p>\n<p><strong>示例 3：</strong></p>\n<p>输入：root = [1]<br>\n 输出：[1]</p>\n<p><strong>示例 4：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg\" alt=\"img\"></p>\n<p>输入：root = [1,2]<br>\n 输出：[2,1]</p>\n<p><strong>示例 5：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg\" alt=\"img\"></p>\n<p>输入：root = [1,null,2]<br>\n 输出：[1,2]</p>\n<p>提示：</p>\n<p>树中节点数目在范围 [0, 100] 内<br>\n - 100 &lt;= Node.val &lt;= 100</p>\n<p>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal\">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a></p>\n<h2 id=\"题目解答\"><a class=\"markdownIt-Anchor\" href=\"#题目解答\">#</a> 题目解答</h2>\n<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>\n<h3 id=\"1递归算法\"><a class=\"markdownIt-Anchor\" href=\"#1递归算法\">#</a> 1. 递归算法</h3>\n<p>利用递归的思想解题也是老朋友了，在之前的算法题里面有过接触，所以并不是很难理解。</p>\n<h4 id=\"1解题思路\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路\">#</a> （1）解题思路</h4>\n<p>​\t\t在解题的时候，了解到了一个名叫 <strong>vector</strong> 的东西，可以理解为 C++ 和 Java 中的一种动态数组。记得第一次听到这个名词的时候还是在翁恺老师的《C 语言程序设计》这门课上听到的，想想还真是怀念。（跑远了</p>\n<p>附上一些链接（<strong>配合梯子一起食用</strong>）：</p>\n<p><strong>vector：内存在堆上</strong></p>\n<p>​    <strong>注意：vector 每添加一次都会把之前的全复制一遍，所以效率并不高。</strong></p>\n<p>​    <strong>1）</strong> <strong><a href=\"https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-160\">https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-160</a>  来源：Microsoft C++、C 和汇编程序文档</strong></p>\n<p>​    <strong>2） <a href=\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/package-summary.html\">https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/package-summary.html</a>  来源：Java 官方文档里的包（纯英文比较难顶</strong></p>\n<p>​    <strong>3） <a href=\"https://baike.baidu.com/item/Vector/3330482\">https://baike.baidu.com/item/Vector/3330482</a> 来源：百度百科</strong></p>\n<p>​    <strong>4） <a href=\"https://www.w3cschool.cn/cpp/cpp-i6da2pq0.html\">https://www.w3cschool.cn/cpp/cpp-i6da2pq0.html</a>  来源：某不知名 C++ 教程</strong></p>\n<p>​    <strong>《C 语言程序设计》：<a href=\"https://www.icourse163.org/learn/ZJU-9001?tid=9001#/learn/announce\">https://www.icourse163.org/learn/ZJU-9001?tid=9001#/learn/announce</a>  来源：中国大学 MOOC</strong></p>\n<p>​\t\t本题可以通过递归思想对给出的二叉树的<strong>左子树、根节点、右子树依次进行遍历（中序遍历）</strong>，并将各个数据存放在设置好的 vector<int>中（由于 vector 是<strong>动态分配内存</strong>的，所以比用担心大小会不够用），最后即可得到该二叉树的中序遍历。</p>\n<h4 id=\"2代码\"><a class=\"markdownIt-Anchor\" href=\"#2代码\">#</a> （2）代码</h4>\n<p>​\t\t解题代码如下（<strong>配合题目链接食用</strong>）：</p>\n<h5 id=\"c\"><a class=\"markdownIt-Anchor\" href=\"#c\">#</a> <strong>C++</strong></h5>\n<p><strong>有一种比较好用的 C++ 容器，比 vector 好用，只是不能自增。（本题未使用）</strong></p>\n<p><strong>array：内存在栈上</strong></p>\n<p><strong>array： <a href=\"http://c.biancheng.net/view/6688.html\">http://c.biancheng.net/view/6688.html</a> 来源：C 语言中文网</strong></p>\n<p><strong>array： <a href=\"https://www.bilibili.com/video/BV18b4y1X7EB?from=search&amp;seid=11718690349134275715\">https://www.bilibili.com/video/BV18b4y1X7EB?from=search&amp;seid=11718690349134275715</a> 来源：哔哩哔哩（是一个油管的小哥哥，讲的很棒，圈粉了）</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode* root, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root) &#123; <span class=\"comment\">// 如果碰到空节点，说明该部分遍历已完成，return出去</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root-&gt;left, res); <span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">        res.<span class=\"built_in\">push_back</span>(root-&gt;val); <span class=\"comment\">// 将该节点的值增加在动态数组末尾</span></span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root-&gt;right, res); <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; res; <span class=\"comment\">// 新建一个int类型的vector,用来存放遍历结果</span></span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root, res); <span class=\"comment\">// 从根节点root开始遍历，依次放入值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res; <span class=\"comment\">// 返回遍历结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><img src=\"https://img12.360buyimg.com/ddimg/jfs/t1/178612/13/21226/22498/61284220E9e541099/4f61f1de25898a99.png\" alt=\"image-20210827092120481.png\"></li>\n</ul>\n<h5 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\">#</a> <strong>Java</strong></h5>\n<p>List &amp; ArrayList 是 Java 中的一种列表。</p>\n<p><strong>List &amp; ArrayList：<a href=\"https://www.jianshu.com/p/25aa92f8d681\">https://www.jianshu.com/p/25aa92f8d681</a> 来源：简书</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(); <span class=\"comment\">// 新建Integer的List来存放数值</span></span><br><span class=\"line\">        inorder(root, res); <span class=\"comment\">// 从根节点root开始遍历，依次将数值放入</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res; <span class=\"comment\">// 返回遍历结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 如果碰到空节点，说明该部分遍历已完成，return出去</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inorder(root.left, res); <span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">        res.add(root.val); <span class=\"comment\">// 将该节点的值增加在末尾</span></span><br><span class=\"line\">        inorder(root.right, res); <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img14.360buyimg.com/ddimg/jfs/t1/200702/31/3771/22855/6128423eE4f6965f0/3afc9e3dfe9a422d.png\" alt=\"image-20210827092151479.png\"></p>\n<h5 id=\"c来自题解\"><a class=\"markdownIt-Anchor\" href=\"#c来自题解\">#</a> <strong>C（来自题解）</strong></h5>\n<p>（C 语言中的动态数组不会玩，于是把题解拿过来）</p>\n<p><strong>C 语言动态数组 <a href=\"https://www.runoob.com/w3cnote/c-dynamic-array.html\">https://www.runoob.com/w3cnote/c-dynamic-array.html</a> 来源：菜鸟教程</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span>* res, <span class=\"keyword\">int</span>* resSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    inorder(root-&gt;left, res, resSize);</span><br><span class=\"line\">    res[(*resSize)++] = root-&gt;val;</span><br><span class=\"line\">    inorder(root-&gt;right, res, resSize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">inorderTraversal</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* res = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">501</span>);</span><br><span class=\"line\">    *returnSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    inorder(root, res, returnSize);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode-Solution</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<h4 id=\"3总结\"><a class=\"markdownIt-Anchor\" href=\"#3总结\">#</a> （3）总结</h4>\n<p>​\t\t利用递归思想来解题还是比较舒服的，也很好用，适合我这种菜鸡。</p>\n<h3 id=\"2迭代算法\"><a class=\"markdownIt-Anchor\" href=\"#2迭代算法\">#</a> 2. 迭代算法</h3>\n<p><strong>关于迭代算法的基本思想：</strong></p>\n<p><strong>迭代算法 <a href=\"https://www.cnblogs.com/cs-whut/p/11024564.html\">https://www.cnblogs.com/cs-whut/p/11024564.html</a> 来源：博客园</strong></p>\n<p>​\t\t迭代算法之前没有接触过，上手有点看不懂。</p>\n<h4 id=\"1解题思路-2\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路-2\">#</a> （1）解题思路</h4>\n<p>​\t\t通过迭代 + 栈模型来清楚的展现解题流程（题解中有动画展示，配合食用比较好理解）。</p>\n<h4 id=\"2代码-2\"><a class=\"markdownIt-Anchor\" href=\"#2代码-2\">#</a> （2）代码</h4>\n<p>​\t\t解题代码如下（<strong>配合题目链接食用</strong>）：</p>\n<h5 id=\"c-2\"><a class=\"markdownIt-Anchor\" href=\"#c-2\">#</a> <strong>C++</strong></h5>\n<p>C++ 的栈：</p>\n<p><strong>stack <a href=\"http://c.biancheng.net/view/478.html\">http://c.biancheng.net/view/478.html</a> 来源：C 语言中文网</strong></p>\n<p><strong>stack <a href=\"https://www.apiref.com/cpp-zh/cpp/container/stack.html\">https://www.apiref.com/cpp-zh/cpp/container/stack.html</a> 来源：C++ 文档</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; res; <span class=\"comment\">// 新建一个int类型的vector,用来存放遍历结果</span></span><br><span class=\"line\">        stack&lt;TreeNode*&gt; stk; <span class=\"comment\">// 新建栈</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"literal\">nullptr</span> || !stk.<span class=\"built_in\">empty</span>()) &#123; <span class=\"comment\">// 节点有数值 或 栈不为空</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 当节点有值时</span></span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(root); <span class=\"comment\">// 数据入栈</span></span><br><span class=\"line\">                root = root-&gt;left; <span class=\"comment\">// 访问左子树</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stk.<span class=\"built_in\">top</span>(); <span class=\"comment\">// 找到栈顶数据的节点</span></span><br><span class=\"line\">            <span class=\"comment\">// top()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</span></span><br><span class=\"line\">            stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"comment\">// pop()：弹出栈顶元素。</span></span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(root-&gt;val); <span class=\"comment\">// 在vector末尾添加当前节点数据</span></span><br><span class=\"line\">            root = root-&gt;right; <span class=\"comment\">// 访问右子树</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res; <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img13.360buyimg.com/ddimg/jfs/t1/191173/7/19840/22319/6128425eE22b3e07d/1ca7845e69631535.png\" alt=\"image-20210827092218700.png\"></p>\n<h5 id=\"java-2\"><a class=\"markdownIt-Anchor\" href=\"#java-2\">#</a> <strong>Java</strong></h5>\n<p>Java 的栈：</p>\n<p><strong>Deque： <a href=\"https://www.jianshu.com/p/d78a7c982edb\">https://www.jianshu.com/p/d78a7c982edb</a> 来源：简书</strong></p>\n<p><strong>stack：</strong>**</p>\n<p><strong>（1） <a href=\"https://www.javatpoint.com/java-stack\">https://www.javatpoint.com/java-stack</a>  来源：某 Java 文档</strong></p>\n<p><strong>（2） <a href=\"https://blog.csdn.net/YQYnsmile/article/details/78457539\">https://blog.csdn.net/YQYnsmile/article/details/78457539</a>  来源：屑 C 某某 N</strong></p>\n<p><strong>（3） <a href=\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Stack.html\">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Stack.html</a>  来源：某全英文 Java 文档</strong></p>\n<p>Deque 可以作为堆栈（LIFO 后进先出），此接口优于传统 Stack 类的使用。</p>\n<p><strong>Stack 和 Deque 方法的比较</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">栈方法</th>\n<th style=\"text-align:center\">等效 Deque 方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">push(e)</td>\n<td style=\"text-align:center\">addFirst(e)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">pop()</td>\n<td style=\"text-align:center\">removeFirst()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">peek()</td>\n<td style=\"text-align:center\">peekFirst()</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(); <span class=\"comment\">// 新建List来保存数据</span></span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stk = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;(); <span class=\"comment\">// 新建栈</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span> || !stk.isEmpty()) &#123; <span class=\"comment\">// 节点有数值 或 栈不为空</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 节点有数值时</span></span><br><span class=\"line\">                stk.push(root); <span class=\"comment\">// 将数据放入栈</span></span><br><span class=\"line\">                root = root.left; <span class=\"comment\">// 访问左子树</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stk.pop(); <span class=\"comment\">// pop()：弹出栈顶元素。</span></span><br><span class=\"line\">            res.add(root.val); <span class=\"comment\">// 在List末尾添加当前节点数据</span></span><br><span class=\"line\">            root = root.right; <span class=\"comment\">// 访问右子树</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res; <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img13.360buyimg.com/ddimg/jfs/t1/177616/31/21117/22717/6128427aE9968827a/f401017322512ef0.png\" alt=\"image-20210827092339328.png\"></p>\n<h5 id=\"c来自题解-2\"><a class=\"markdownIt-Anchor\" href=\"#c来自题解-2\">#</a> <strong>C</strong>（来自题解）</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">inorderTraversal</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</span><br><span class=\"line\">    *returnSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* res = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">501</span>);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>** <span class=\"title\">stk</span> =</span> <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TreeNode*) * <span class=\"number\">501</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (root != <span class=\"literal\">NULL</span> || top &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            stk[top++] = root;</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root = stk[--top];</span><br><span class=\"line\">        res[(*returnSize)++] = root-&gt;val;</span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode-Solution</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<h4 id=\"3总结-2\"><a class=\"markdownIt-Anchor\" href=\"#3总结-2\">#</a> （3）总结</h4>\n<p>​\t\t利用迭代算法来解题的思想还没有怎么接触过没上手感觉比较难。（<strong>还是递归香</strong>    <strong>确信</strong>）</p>\n<h3 id=\"3morris-中序遍历来自题解\"><a class=\"markdownIt-Anchor\" href=\"#3morris-中序遍历来自题解\">#</a> 3.Morris 中序遍历（来自题解）</h3>\n<p>​\t\t这个就是真的闻所未闻了，看了题解，决定搬过来</p>\n<h4 id=\"1思路与算法\"><a class=\"markdownIt-Anchor\" href=\"#1思路与算法\">#</a> （1）思路与算法</h4>\n<ol>\n<li>\n<p><strong>Morris 遍历算法</strong>是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O (1) O (1)。</p>\n<p><strong>Morris 遍历算法</strong>整体步骤如下（假设当前遍历到的节点为 xx）：</p>\n</li>\n<li>\n<p>如果 xx 无左孩子，先将 xx 的值加入答案数组，再访问 xx 的右孩子，即 x  =  x . right。<br>\n如果 xx 有左孩子，则找到 xx 左子树上最右的节点（<strong>即左子树中序遍历的最后一个节点，xx 在中序遍历中的前驱节点</strong>），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。</p>\n<ul>\n<li>如果 predecessor 的右孩子为空，则将其右孩子指向 xx，然后访问 xx 的左孩子，即  x  =  x . left。</li>\n<li>如果 predecessor 的右孩子不为空，则此时其右孩子指向 xx，说明我们已经遍历完 xx 的左子树，我们将 predecessor 的右孩子置空，将 xx 的值加入答案数组，然后访问 xx 的右孩子，即  x  =  x . right。</li>\n</ul>\n</li>\n<li>\n<p>重复上述操作，直至访问完整棵树。</p>\n<p>4. 其实整个过程我们就多做一步：假设当前遍历到的节点为 xx，将 xx 的左子树中最右边的节点的右孩子指向 xx，这样在左子树遍历完成后我们通过这个指向走回了 xx，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p>\n</li>\n</ol>\n<h4 id=\"2代码-3\"><a class=\"markdownIt-Anchor\" href=\"#2代码-3\">#</a> （2）代码</h4>\n<p><strong>题解链接： <a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/\">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</a> 来源：力扣</strong></p>\n<p>​\t\t不想搬运代码了，就给出了链接。<strong>Morris 中序遍历</strong>是题解中的第三种解法，题解带有动画教程，可以看看。</p>\n<h4 id=\"3总结-3\"><a class=\"markdownIt-Anchor\" href=\"#3总结-3\">#</a> （3）总结</h4>\n<p>​\t\t一种没听过的中序遍历算法，搬运题解来的。（主要还是太菜了没玩明白）</p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> 题目总结</h2>\n<p>​\t\t此次题目中，出现了<strong>递归算法、迭代算法、Morris 遍历算法</strong>三种解题思路。</p>\n<p>​\t\t总的来说，还是递归较好理解，写起来难度稍微低一些；迭代算法初次了解，试了试水；Morris 遍历算法第一次见，还是看题解叭（还是人菜）。</p>\n",
            "tags": [
                "算法作业"
            ]
        }
    ]
}