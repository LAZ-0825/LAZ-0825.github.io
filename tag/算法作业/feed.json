{
    "version": "https://jsonfeed.org/version/1",
    "title": "LAZ的小站 • All posts by \"算法作业\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/passages/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/",
            "url": "http://example.com/passages/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/",
            "title": "最大正方形",
            "date_published": "2021-08-12T02:11:41.000Z",
            "content_html": "<h1 id=\"最大正方形\"><a class=\"markdownIt-Anchor\" href=\"#最大正方形\">#</a> <strong>最大正方形</strong></h1>\n<p>​\t\t大一 -&gt; 大二暑期算法作业</p>\n<p>​\t\t<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>\n<h2 id=\"看到题目的感想\"><a class=\"markdownIt-Anchor\" href=\"#看到题目的感想\">#</a> <strong>看到题目的感想</strong></h2>\n<p>​\t\t寻找最大正方形是小时候经常玩的一种游戏，说是可以锻炼观察力与判断力什么的，现在也会有家长带着小孩玩这个游戏，不过不是很多。</p>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> <strong>题目描述</strong></h2>\n<p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>\n<p>示例 1：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg\" alt=\"\"></p>\n<p>输入：matrix = [[“1”,“0”,“1”,“0”,“0”],[“1”,“0”,“1”,“1”,“1”],[“1”,“1”,“1”,“1”,“1”],[“1”,“0”,“0”,“1”,“0”]]<br>\n 输出：4</p>\n<p>示例 2：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg\" alt=\"\"></p>\n<p>输入：matrix = [[“0”,“1”],[“1”,“0”]]<br>\n 输出：1</p>\n<p>示例 3：</p>\n<p>输入：matrix = [[“0”]]<br>\n 输出：0</p>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/maximal-square\">https://leetcode-cn.com/problems/maximal-square</a><br>\n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"题目解答\"><a class=\"markdownIt-Anchor\" href=\"#题目解答\">#</a> <strong>题目解答</strong></h2>\n<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>\n<h3 id=\"1-暴力计算\"><a class=\"markdownIt-Anchor\" href=\"#1-暴力计算\">#</a> 1、<strong>暴力计算</strong></h3>\n<h4 id=\"1解题思路\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路\">#</a> <strong>（1）解题思路</strong></h4>\n<p>语言描述不是很棒，大家凑活看叭，┭┮﹏┭┮</p>\n<p>想了想，暴力计算是最简单直观的做法，具体做法如下：</p>\n<ol>\n<li>遍历矩阵中的元素，当遇到 1 时，将该元素作为正方形的左上角的位置。</li>\n<li>确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围 - 不能超出矩阵的行和列），在该范围内寻找只包含 1 的最大正方形；</li>\n<li>每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 1。（方便起见，需要先判断选取的点的右下角的点是否为 1。若不是，则跳出本次循环并储存当前的最大正方形，找到下一个元素是 1 的节点作为左上角点，重复 2、3 步；若是，则判断下一行和右一列的其他元素是否都为 1 <strong>（注：这里不是下一行右一列的所有元素，而是初始左上角和以当前点为右下角的正方形的范围内的点，如下图）</strong> ，若不都为 1，则跳出本次循环并储存当前的最大正方形，找到下一个元素是 1 的节点作为左上角点，重复 2、3 步；若都为 1，则继续第 3 步）。</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/08/13/biqFJLHxV7CTXf8.png\" alt=\"\"></p>\n<h4 id=\"2代码\"><a class=\"markdownIt-Anchor\" href=\"#2代码\">#</a> <strong>（2）代码</strong></h4>\n<p><strong>配合题目链接食用</strong></p>\n<h5 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\">#</a> java</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maximalSquare</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSide = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"keyword\">null</span> || matrix.length == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 没有矩阵或矩阵大小为0时</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> maxSide;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = matrix.length, columns = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; columns; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) &#123; <span class=\"comment\">// 遇到一个 1 作为正方形的左上角</span></span><br><span class=\"line\">                    maxSide = Math.max(maxSide, <span class=\"number\">1</span>); <span class=\"comment\">// 更新可能的最大正方形边长</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> currentMaxSide = Math.min(rows - i, columns - j); <span class=\"comment\">// 当前最大正方形边长</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt; currentMaxSide; k++) &#123; <span class=\"comment\">// 判断新增的一行一列是否均为 1</span></span><br><span class=\"line\">                        <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (matrix[i + k][j + k] == <span class=\"string\">&#x27;0&#x27;</span>) &#123; <span class=\"comment\">// 判断右下角的点</span></span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt; k; m++) &#123; <span class=\"comment\">// 判断下一行右一列</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (matrix[i + k][j + m] == <span class=\"string\">&#x27;0&#x27;</span> || matrix[i + m][j + k] == <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">                                flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (flag) &#123; <span class=\"comment\">// 若判断都是1，则更新，不是则退出本次循环，寻找下一个左上角</span></span><br><span class=\"line\">                            maxSide = Math.max(maxSide, k + <span class=\"number\">1</span>); <span class=\"comment\">// 更新可能的最大正方形边长</span></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSquare = maxSide * maxSide;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSquare;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/185126/31/21226/19810/61284443E0d3f0dfd/b2db3058f56d7f8b.png\" alt=\"image-20210827093335340.png\"></p>\n<h4 id=\"3总结\"><a class=\"markdownIt-Anchor\" href=\"#3总结\">#</a> <strong>（3）总结</strong></h4>\n<p>​\t\t暴力的思路比其他方法简单（但是我的描述可能会有些不顺畅），但是效率不高。</p>\n<h3 id=\"2-dp算法动态规划来自题解\"><a class=\"markdownIt-Anchor\" href=\"#2-dp算法动态规划来自题解\">#</a> <strong>2、dp 算法（动态规划）（来自题解）</strong></h3>\n<p>​\t\t又一次见到了动态规划，还是有无从下手的感觉。</p>\n<h4 id=\"1解题思路-2\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路-2\">#</a> <strong>（1）解题思路</strong></h4>\n<p>​\t\t方法一虽然直观，但是时间复杂度太高，有没有办法降低时间复杂度呢？</p>\n<p>可以使用动态规划降低时间复杂度。我们用 dp (i,j) 表示以 (i,j) 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp (i,j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p>\n<p>那么如何计算 dp 中的每个元素值呢？对于每个位置 (i,j)，检查在矩阵中该位置的值：</p>\n<ul>\n<li>\n<p>如果该位置的值是 0，则 dp (i,j)=0，因为当前位置不可能在由 1 组成的正方形中；</p>\n</li>\n<li>\n<p>如果该位置的值是 11，则 dp (i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p>\n<p>​\tdp(i,j) = min( dp(i−1,j) , dp(i−1,j−1) , dp(i,j−1) ) + 1</p>\n<p>如果读者对这个状态转移方程感到不解，<a href=\"https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-2/\">可以参考 1277. 统计全为 1 的正方形子矩阵的官方题解</a>，其中给出了详细的证明。</p>\n</li>\n</ul>\n<p>此外，还需要考虑边界条件。如果 i 和 j 中至少有一个为 0，则以位置 (i, j)(i,j) 为右下角的最大正方形的边长只能是 11，因此 dp (i,j)=1。</p>\n<p>以下用一个例子具体说明。原始矩阵如下。</p>\n<p>0 1 1 1 0<br>\n1 1 1 1 0<br>\n0 1 1 1 1<br>\n0 1 1 1 1<br>\n0 0 1 1 1<br>\n 对应的 dp 值如下。</p>\n<p>0 1 1 1 0<br>\n1 1 2 2 0<br>\n0 1 2 3 1<br>\n0 1 2 3 2<br>\n0 0 1 2 3</p>\n<p>下图也给出了计算 dp 值的过程。</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/221/221_fig1.png\" alt=\"\"></p>\n<h4 id=\"2代码-2\"><a class=\"markdownIt-Anchor\" href=\"#2代码-2\">#</a> <strong>（2）代码</strong></h4>\n<p><strong>配合题目链接食用</strong></p>\n<h5 id=\"java-2\"><a class=\"markdownIt-Anchor\" href=\"#java-2\">#</a> Java</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maximalSquare</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSide = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"keyword\">null</span> || matrix.length == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> maxSide;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = matrix.length, columns = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[rows][columns];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; columns; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        dp[i][j] = Math.min(Math.min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]), dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSquare = maxSide * maxSide;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSquare;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode-Solution</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<h5 id=\"c\"><a class=\"markdownIt-Anchor\" href=\"#c\">#</a> C++</h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximalSquare</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSide = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = matrix.<span class=\"built_in\">size</span>(), columns = matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(rows, vector&lt;<span class=\"keyword\">int</span>&gt;(columns));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; columns; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        dp[i][j] = <span class=\"built_in\">min</span>(<span class=\"built_in\">min</span>(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]), dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    maxSide = <span class=\"built_in\">max</span>(maxSide, dp[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSquare = maxSide * maxSide;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSquare;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode-Solution</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<h4 id=\"3总结-2\"><a class=\"markdownIt-Anchor\" href=\"#3总结-2\">#</a> <strong>（3）总结</strong></h4>\n<p>​\t\t动态规划解题的思想还需要学习，现在还上不了手。</p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> <strong>题目总结</strong></h2>\n<p>​\t\t这次的题目是数最大正方形，暴力方法还是最先考虑到的，之后菜知道动态规划也可以解决。（动态规划现在还属实不会）</p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/passages/%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/",
            "title": "太平洋大西洋水流问题",
            "date_published": "2021-08-05T11:30:57.000Z",
            "content_html": "<h1 id=\"太平洋大西洋水流问题\"><a class=\"markdownIt-Anchor\" href=\"#太平洋大西洋水流问题\">#</a> 太平洋大西洋水流问题</h1>\n<p>​\t\t大一 -&gt; 大二暑期算法作业</p>\n<p>​\t\t<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>\n<h2 id=\"看到题目的感想\"><a class=\"markdownIt-Anchor\" href=\"#看到题目的感想\">#</a> 看到题目的感想</h2>\n<p>​\t\t刚看到这个题目的时候感觉他不是很熟悉，没有见过类似的题目，也没有见过类似的场景，感觉有点意思。</p>\n<p>​\t\t题目不算很长，但感觉难度不小。</p>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h2>\n<p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。</p>\n<p><strong>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</strong></p>\n<p>请找出那些水流<strong>既可以</strong>流动到 “太平洋”，<strong>又能</strong>流动到 “大西洋” 的陆地单元的坐标。</p>\n<p>提示：</p>\n<p>输出坐标的<strong>顺序不重要</strong><br>\n m 和 n 都<strong>小于 150</strong></p>\n<p>示例：</p>\n<p>给定下面的 5x5 矩阵:</p>\n<dl>\n<dt>太平洋～~   ~   ~   ~</dt>\n<dd>1   2   2   3  (5) /</dd>\n<dd>3   2   3  (4) (4) /</dd>\n<dd>2   4  (5)  3   1  /</dd>\n<dd>(6) (7)  1   4   5  /</dd>\n<dd>(5)  1   1   2   4  /</dd>\n</dl>\n<p>​            /    /    /    /    /   大西洋</p>\n<p>返回:</p>\n<p>[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元). （序号先左后上）</p>\n<h2 id=\"题目解答\"><a class=\"markdownIt-Anchor\" href=\"#题目解答\">#</a> 题目解答</h2>\n<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>\n<h3 id=\"逆流而上\"><a class=\"markdownIt-Anchor\" href=\"#逆流而上\">#</a> 逆流而上</h3>\n<p>​\t\t最开始的名字叫<strong>逆着水流向上找</strong>，后面才想起来有<strong>逆流而上</strong>这个成语，才改了名字。</p>\n<p>​\t\t最开始浮现的思路是想暴力解题，后来发现暴力解题太过于麻烦，效率也不高，索性就放弃了。之后才有的现在这个想法。</p>\n<h3 id=\"1解题思路\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路\">#</a> （1）解题思路</h3>\n<p>​\t\t本题找的是<strong>能够让水流留到两片水域</strong>的陆地单元的位置坐标，那么既然水能过去，那我们反过来找，<strong>分别找到两个水域的水能流到的地方，之后取交集</strong>，就得到了我们想要的答案。</p>\n<h3 id=\"2代码\"><a class=\"markdownIt-Anchor\" href=\"#2代码\">#</a> （2）代码</h3>\n<p><strong>配合题目链接食用</strong></p>\n<h4 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\">#</a> Java</h4>\n<p><strong>注：这个代码在 idea 上可以正常运行，但在力扣上会有报错。报错如下：</strong></p>\n<p>error: incompatible types: List&lt;int[]&gt; cannot be converted to List&lt;List<Integer>&gt; [in <strong>Driver</strong>.java]</p>\n<p>List&lt;List<Integer>&gt; ret = new Solution().pacificAtlantic(param_1);</p>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/197276/28/5074/29323/612842a4E395ba9f9/a2ea88eb469c810c.png\" alt=\"image-20210827093245188.png\"></p>\n<p><strong>List &amp; ArrayList：<a href=\"https://www.jianshu.com/p/25aa92f8d681\">https://www.jianshu.com/p/25aa92f8d681</a> 来源：简书</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">public</span> List&lt;<span class=\"keyword\">int</span>[]&gt; pacificAtlantic(<span class=\"keyword\">int</span>[][] matrix) &#123;</span><br><span class=\"line\">                List&lt;<span class=\"keyword\">int</span>[]&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(); <span class=\"comment\">// 储存最终数据</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> m = matrix.length; <span class=\"comment\">// 获取矩阵一边的长度</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(m &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ret; <span class=\"comment\">// 矩阵大小为0时</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> n = matrix[<span class=\"number\">0</span>].length; <span class=\"comment\">// 获取矩阵另一边的长度</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span>[][] Pacific = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[m][n]; <span class=\"comment\">// 太平洋的</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span>[][] Atlantic = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[m][n]; <span class=\"comment\">// 大西洋的</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123; <span class=\"comment\">// 递归判断一条边</span></span><br><span class=\"line\">                    dfs(matrix, i, <span class=\"number\">0</span>, Pacific, matrix[i][<span class=\"number\">0</span>]);</span><br><span class=\"line\">                    dfs(matrix, i, n-<span class=\"number\">1</span>, Atlantic, matrix[i][n-<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123; <span class=\"comment\">// 递归判断另一条边</span></span><br><span class=\"line\">                    dfs(matrix, <span class=\"number\">0</span>, i, Pacific, matrix[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">                    dfs(matrix, m-<span class=\"number\">1</span>, i, Atlantic, matrix[m-<span class=\"number\">1</span>][i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123; <span class=\"comment\">// 取交集得到最终结果</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j)</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(Pacific[i][j] &amp;&amp; Atlantic[i][j])</span><br><span class=\"line\">                            ret.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i, j&#125;); <span class=\"comment\">// 放入数据</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret; <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] m, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">boolean</span>[][] visited, <span class=\"keyword\">int</span> pre)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 超出边界 或 判断过是可以的 或 不能继续向上流动，则返回</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span> || x &gt;= m.length || y &gt;= m[<span class=\"number\">0</span>].length || visited[x][y] || m[x][y] &lt; pre)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                visited[x][y] = <span class=\"keyword\">true</span>; <span class=\"comment\">// 可以向上流</span></span><br><span class=\"line\">                dfs(m, x+<span class=\"number\">1</span>, y, visited, m[x][y]); <span class=\"comment\">// 递归判断相邻行或列</span></span><br><span class=\"line\">                dfs(m, x-<span class=\"number\">1</span>, y, visited, m[x][y]); <span class=\"comment\">// 递归判断相邻行或列</span></span><br><span class=\"line\">                dfs(m, x, y+<span class=\"number\">1</span>, visited, m[x][y]); <span class=\"comment\">// 递归判断相邻行或列</span></span><br><span class=\"line\">                dfs(m, x, y-<span class=\"number\">1</span>, visited, m[x][y]); <span class=\"comment\">// 递归判断相邻行或列</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3总结\"><a class=\"markdownIt-Anchor\" href=\"#3总结\">#</a> （3）总结</h3>\n<p>​\t\t这个解题思路来看的话感觉还是可以的，就是会有一些<strong>奇怪的 bug</strong>，不知道怎么肥四。</p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> 题目总结</h2>\n<p>​\t\t这个题目难度比之前的大一些，不好做，包括写的时候也查了一些资料（<strong>运用不熟练</strong>），好在最后搞出来了（虽然有一些奇怪的 bug）。</p>\n<p>​\t\t（<strong>递归真香</strong>）</p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/",
            "url": "http://example.com/passages/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/",
            "title": "罗马数字转整数",
            "date_published": "2021-07-24T00:49:38.000Z",
            "content_html": "<h1 id=\"罗马数字转整数\"><a class=\"markdownIt-Anchor\" href=\"#罗马数字转整数\">#</a> 罗马数字转整数</h1>\n<p>​\t\t大一 -&gt; 大二暑期算法作业</p>\n<p>​\t\t<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>\n<h2 id=\"看到题目的想法\"><a class=\"markdownIt-Anchor\" href=\"#看到题目的想法\">#</a> 看到题目的想法</h2>\n<p>​\t\t这个题目看起来挺有意思的，但是好像不好解。</p>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h2>\n<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>数值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>I</td>\n<td>1</td>\n</tr>\n<tr>\n<td>V</td>\n<td>5</td>\n</tr>\n<tr>\n<td>X</td>\n<td>10</td>\n</tr>\n<tr>\n<td>L</td>\n<td>50</td>\n</tr>\n<tr>\n<td>C</td>\n<td>100</td>\n</tr>\n<tr>\n<td>D</td>\n<td>500</td>\n</tr>\n<tr>\n<td>M</td>\n<td>1000</td>\n</tr>\n</tbody>\n</table>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<ol>\n<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>\n<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li>\n<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>\n</ol>\n<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>\n<p><strong>示例 1:</strong></p>\n<p>输入: “III”<br>\n 输出: 3</p>\n<p><strong>示例 2:</strong></p>\n<p>输入: “IV”<br>\n 输出: 4</p>\n<p><strong>示例 3:</strong></p>\n<p>输入: “IX”<br>\n 输出: 9</p>\n<p><strong>示例 4:</strong></p>\n<p>输入: “LVIII”<br>\n 输出: 58</p>\n<p>解释: L = 50, V= 5, III = 3.</p>\n<p><strong>示例 5:</strong></p>\n<p>输入: “MCMXCIV”<br>\n 输出: 1994<br>\n 解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>\n<p><strong>提示：</strong></p>\n<ol>\n<li>1 &lt;= s.length &lt;= 15</li>\n<li>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)</li>\n<li>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内</li>\n<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>\n<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>\n<li>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/roman-to-integer\">https://leetcode-cn.com/problems/roman-to-integer</a><br>\n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"题目解答\"><a class=\"markdownIt-Anchor\" href=\"#题目解答\">#</a> 题目解答</h2>\n<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>\n<h3 id=\"1暴力解题\"><a class=\"markdownIt-Anchor\" href=\"#1暴力解题\">#</a> 1. 暴力解题</h3>\n<h4 id=\"1解题思路\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路\">#</a> （1）解题思路</h4>\n<p>​\t\t想了想还是选择了暴力解题（<strong>比较简单</strong>。</p>\n<p>​\t\t将特殊情况转为另一个<strong>不在   I， V， X， L，C，D 和 M</strong>  中的单独的字母；再重新挨个求和。</p>\n<h4 id=\"2-代码\"><a class=\"markdownIt-Anchor\" href=\"#2-代码\">#</a> （2） 代码</h4>\n<p>​\t\t<strong>配合题目链接食用</strong></p>\n<p><strong>C++</strong></p>\n<p><strong>earse：</strong><a href=\"https://www.cnblogs.com/ylwn817/articles/1967689.html\">C++ 中 string erase 函数的使用 (转载) - jackdesk - 博客园 (cnblogs.com)</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++) <span class=\"comment\">// 将特殊情况转换</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;I&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;V&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;H&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;I&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;X&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;J&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;X&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;L&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;O&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;X&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;Q&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;C&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;D&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;C&#x27;</span>&amp;&amp;s[i+<span class=\"number\">1</span>]==<span class=\"string\">&#x27;M&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">erase</span>(i+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            s[i]=<span class=\"string\">&#x27;B&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++) <span class=\"comment\">// 挨个求和</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">switch</span></span>(s[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;I&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;V&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">5</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;X&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">10</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;L&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">50</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;C&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">100</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;D&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">500</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;M&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">1000</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;H&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">4</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;J&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">9</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;O&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">40</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Q&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">90</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;A&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">400</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;B&#x27;</span>:&#123;</span><br><span class=\"line\">                sum+=<span class=\"number\">900</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/177610/31/20874/22139/612842cbEa0f226ee/d8b14650ce07f5ff.png\" alt=\"image-20210827092938870.png\"></p>\n<h4 id=\"3总结\"><a class=\"markdownIt-Anchor\" href=\"#3总结\">#</a> （3）总结</h4>\n<p>​\t\t暴力计算的方法想起来并不复杂，但是写起来麻烦（重复、相似比较多），而且代码的性能也不高，所以还是不建议采用暴力算法。</p>\n<h3 id=\"2模拟来自题解\"><a class=\"markdownIt-Anchor\" href=\"#2模拟来自题解\">#</a> 2. 模拟（来自题解）</h3>\n<p>​\t\t很巧妙的一种方法，看完之后情不自禁的妙了起来。</p>\n<p>​\t\t<strong>妙<sub>啊</sub>～</strong></p>\n<p><strong>官方题解：<a href=\"https://leetcode-cn.com/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/\">https://leetcode-cn.com/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/</a></strong></p>\n<h4 id=\"1解题思路-2\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路-2\">#</a> （1）解题思路</h4>\n<p>** 通常情况下，罗马数字中小的数字在大的数字的右边。** 若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。</p>\n<p>例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。</p>\n<p>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，<strong>若一个数字右侧的数字比它大，则将该数字的符号取反。</strong></p>\n<p>例如 XIV 可视作 X−I+V=10−1+5=14。</p>\n<h4 id=\"2代码\"><a class=\"markdownIt-Anchor\" href=\"#2代码\">#</a> （2）代码</h4>\n<p>这里用到了<strong> map</strong> 这个东西，可以看看</p>\n<h5 id=\"c\"><a class=\"markdownIt-Anchor\" href=\"#c\">#</a> C++</h5>\n<p><strong>C++map： <a href=\"https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html\">https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html</a>  来源：某 C ++ 文档</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    map&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; symbolValues = &#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;I&#x27;</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;V&#x27;</span>, <span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;X&#x27;</span>, <span class=\"number\">10</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;L&#x27;</span>, <span class=\"number\">50</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"number\">100</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;D&#x27;</span>, <span class=\"number\">500</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&#x27;M&#x27;</span>, <span class=\"number\">1000</span>&#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> value = symbolValues[s[i]];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; n - <span class=\"number\">1</span> &amp;&amp; value &lt; symbolValues[s[i + <span class=\"number\">1</span>]]) &#123;</span><br><span class=\"line\">                ans -= value;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans += value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/196645/13/19919/22179/612842e5E892666a7/8ed9cac439b0d859.png\" alt=\"image-20210827093012125.png\"></p>\n<h5 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\">#</a> Java</h5>\n<p><strong>java map：<a href=\"https://blog.csdn.net/qq_29373285/article/details/81487594\">https://blog.csdn.net/qq_29373285/article/details/81487594</a></strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    Map&lt;Character, Integer&gt; symbolValues = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;I&#x27;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;V&#x27;</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;X&#x27;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;L&#x27;</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;D&#x27;</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\">        put(<span class=\"string\">&#x27;M&#x27;</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> value = symbolValues.get(s.charAt(i));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; n - <span class=\"number\">1</span> &amp;&amp; value &lt; symbolValues.get(s.charAt(i + <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                ans -= value;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans += value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/196645/13/19919/22179/612842e5E892666a7/8ed9cac439b0d859.png\" alt=\"image-20210827093028025.png\"></p>\n<h4 id=\"3总结-2\"><a class=\"markdownIt-Anchor\" href=\"#3总结-2\">#</a> （3）总结</h4>\n<p>​\t\t很巧妙地方法，是我没想到的，很棒。</p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> 题目总结</h2>\n<p>​\t\t听题解说是很经典的字符串匹配的题目，感觉很有意思，就是没有想到巧妙地方法。需要再接再厉。</p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/%E7%88%AC%E6%A5%BC%E6%A2%AF/",
            "url": "http://example.com/passages/%E7%88%AC%E6%A5%BC%E6%A2%AF/",
            "title": "爬楼梯",
            "date_published": "2021-07-19T07:24:26.000Z",
            "content_html": "<h1 id=\"爬楼梯\"><a class=\"markdownIt-Anchor\" href=\"#爬楼梯\">#</a> 爬楼梯</h1>\n<p>​\t\t大一 -&gt; 大二暑期算法作业</p>\n<p>​\t\t<strong>本文档中有对动态规划的解读（来自题解）</strong></p>\n<p>​\t\t<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>\n<h2 id=\"看到题目的想法\"><a class=\"markdownIt-Anchor\" href=\"#看到题目的想法\">#</a> 看到题目的想法</h2>\n<p>​\t\t这是一道比较经典的题目，之前好像见过类似的题目，所以上手还是有一些思路的。</p>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h2>\n<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p><strong>注意</strong>：给定 n 是一个正整数。</p>\n<p><strong>示例 1：</strong></p>\n<p>输入： 2<br>\n 输出： 2<br>\n 解释： 有两种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶</li>\n<li>2 阶</li>\n</ol>\n<p><strong>示例 2：</strong></p>\n<p>输入： 3<br>\n 输出： 3<br>\n 解释： 有三种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶 + 1 阶</li>\n<li>1 阶 + 2 阶</li>\n<li>2 阶 + 1 阶</li>\n<li></li>\n</ol>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/climbing-stairs\">https://leetcode-cn.com/problems/climbing-stairs</a><br>\n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"题目解答\"><a class=\"markdownIt-Anchor\" href=\"#题目解答\">#</a> 题目解答</h2>\n<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>\n<h3 id=\"1动态规划\"><a class=\"markdownIt-Anchor\" href=\"#1动态规划\">#</a> 1. 动态规划</h3>\n<h4 id=\"1解题思路\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路\">#</a> （1）解题思路</h4>\n<p>​       刚开始事项用递归写一下的，后来发现递归会超时，于是选用了动态规划。</p>\n<p>​       这是一道典型的动态规划题，<strong>由于每步只能走一或两阶台阶，所以到达这一阶的方法数是 跨一阶到达 + 跨两阶到达</strong>。所以走到第一阶有一种方法，走到第二阶有两种方法，<strong>从第三阶开始</strong>，每一阶的方法数等于前两阶的方法数的代数和（跨一阶到达 + 跨两阶到达）（ps：可以用数组储存，但没必要，因为我们需要的是最终结果。</p>\n<p>​       （有斐波那契那味了。</p>\n<h4 id=\"2代码\"><a class=\"markdownIt-Anchor\" href=\"#2代码\">#</a> （2）代码</h4>\n<p>​\t\t由于思路比较简单，也是顺利的写出了代码。（<strong>配合题目链接食用</strong>）</p>\n<h5 id=\"c\"><a class=\"markdownIt-Anchor\" href=\"#c\">#</a> C++</h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123; <span class=\"comment\">// 遍历计算直到算出想要的结果</span></span><br><span class=\"line\">            p = q; </span><br><span class=\"line\">            q = r; </span><br><span class=\"line\">            r = p + q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r; <span class=\"comment\">// 返回想要的结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img14.360buyimg.com/ddimg/jfs/t1/178109/1/21048/19824/612843b1Ebbddf701/64ca411d00d898bb.png\" alt=\"image-20210827092530062.png\"></p>\n<h5 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\">#</a> Java</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123; <span class=\"comment\">// 遍历计算直到算出想要的结果</span></span><br><span class=\"line\">            p = q; </span><br><span class=\"line\">            q = r; </span><br><span class=\"line\">            r = p + q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r; <span class=\"comment\">// 返回想要的结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img13.360buyimg.com/ddimg/jfs/t1/192688/38/20306/19931/612843c8Ead5d61e5/fbbd50516680a252.png\" alt=\"image-20210827092554179.png\"></p>\n<h5 id=\"c-2\"><a class=\"markdownIt-Anchor\" href=\"#c-2\">#</a> C</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123; <span class=\"comment\">// 遍历计算直到算出想要的结果</span></span><br><span class=\"line\">        p = q;</span><br><span class=\"line\">        q = r;</span><br><span class=\"line\">        r = p + q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r; <span class=\"comment\">// 返回想要的结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/181789/27/21163/20033/612843d9E4033bcc2/15eb1d8b958eb431.png\" alt=\"image-20210827092619237.png\"></p>\n<h4 id=\"3总结\"><a class=\"markdownIt-Anchor\" href=\"#3总结\">#</a> （3）总结</h4>\n<p>​\t\t这样直接计算的方法思路很简单，但是问题是计算的结果无法保留，用一次就要重新计算一次，十分的不方便。</p>\n<h3 id=\"2斐波那契数列\"><a class=\"markdownIt-Anchor\" href=\"#2斐波那契数列\">#</a> 2. 斐波那契数列</h3>\n<h4 id=\"1解题思路-2\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路-2\">#</a> （1）解题思路</h4>\n<p>​\t\t不难看出，此题的数据就是我们熟悉的<strong>斐波那契数列</strong>，因此我们可以<strong>借助斐波那契数列的通项公式</strong>来快速算出我们想要的结果（前一种解发是从头计算出来的，台阶数较大时效率低  。</p>\n<p>​\t\t这种方法简单粗暴，就是通项公式不好记。</p>\n<p>​\t\t通项公式的推导过程就不写了，可以去题解里面看一下。+</p>\n<p><strong>题目链接（去看官方题解）：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/\">https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</a></strong></p>\n<h4 id=\"2代码-2\"><a class=\"markdownIt-Anchor\" href=\"#2代码-2\">#</a> （2）代码</h4>\n<h5 id=\"c-3\"><a class=\"markdownIt-Anchor\" href=\"#c-3\">#</a> C++</h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> sqrt5 = <span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> fibn = <span class=\"built_in\">pow</span>((<span class=\"number\">1</span> + sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>) - <span class=\"built_in\">pow</span>((<span class=\"number\">1</span> - sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>); <span class=\"comment\">// 斐波那契数列通项公式</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)<span class=\"built_in\">round</span>(fibn / sqrt5); <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/186997/39/20254/20066/612843eaE3f9c5968/88a470ca748a910b.png\" alt=\"image-20210827092637917.png\"></p>\n<h5 id=\"java-2\"><a class=\"markdownIt-Anchor\" href=\"#java-2\">#</a> Java</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> sqrt5 = Math.sqrt(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> fibn = Math.pow((<span class=\"number\">1</span> + sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>) - Math.pow((<span class=\"number\">1</span> - sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>); <span class=\"comment\">// 斐波那契数列通项公式</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) Math.round(fibn / sqrt5); <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img13.360buyimg.com/ddimg/jfs/t1/197749/9/5098/19966/612843f7E025f4b3d/8647b6a5672410fd.png\" alt=\"image-20210827092704192.png\"></p>\n<h5 id=\"c-4\"><a class=\"markdownIt-Anchor\" href=\"#c-4\">#</a> C</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> sqrt5 = <span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> fibn = <span class=\"built_in\">pow</span>((<span class=\"number\">1</span> + sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>) - <span class=\"built_in\">pow</span>((<span class=\"number\">1</span> - sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>); <span class=\"comment\">// 斐波那契数列通项公式</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) round(fibn / sqrt5); <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img12.360buyimg.com/ddimg/jfs/t1/197249/18/5090/19858/61284418E58cc0b79/4adf3d43edded4c7.png\" alt=\"image-20210827092720313.png\"></p>\n<h4 id=\"3总结-2\"><a class=\"markdownIt-Anchor\" href=\"#3总结-2\">#</a> （3）总结</h4>\n<p>​\t\t这种解决办法方便快捷，也不会浪费多余的时间空间来计算，比较好用。<strong>（缺点就是通项公式并不容易记住）</strong></p>\n<h3 id=\"3矩阵快速幂来自题解\"><a class=\"markdownIt-Anchor\" href=\"#3矩阵快速幂来自题解\">#</a> 3. 矩阵快速幂（来自题解）</h3>\n<h4 id=\"1解题思路-代码\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路-代码\">#</a> （1）解题思路 + 代码</h4>\n<p>​\t\t说实话，行看到这种方法的时候<strong>感觉回到了线性代数的课堂上</strong>，又是熟悉的矩阵操作，让人头疼</p>\n<p>​\t\t具体的解题思路和代码就不搬过来了，可以去<strong>官方题解</strong>下查看。</p>\n<p><strong>题目链接（去看官方题解）：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/\">https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</a></strong></p>\n<h4 id=\"2总结\"><a class=\"markdownIt-Anchor\" href=\"#2总结\">#</a> （2）总结</h4>\n<p>​\t\t<strong>利用矩阵运算解题</strong>的方法还是没见过的，对我来说比较新奇，还需要认真的研究研究。</p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> 题目总结</h2>\n<p>​\t\t这道题的难度中规中矩，但也会有很奇妙很方便的解决方案，也让我知道了<strong>运用矩阵运算来解题</strong>的方法，很棒。</p>\n<h2 id=\"拓展动态规划摘自题解\"><a class=\"markdownIt-Anchor\" href=\"#拓展动态规划摘自题解\">#</a> 拓展（动态规划）（摘自题解）</h2>\n<p>​\t\t<strong>本部分附带原作者对本题的总结</strong></p>\n<p>不少同学对动态规划还处于朦胧状态，我特意<strong>录了一期视频</strong>，讲一讲<strong>动态规划解题方法论</strong>，这里详细介绍了动规五部曲，相信结合本篇题解，会对你学习动态规划有所帮助。</p>\n<p><strong>视频链接：<a href=\"https://www.bilibili.com/video/BV13Q4y197Wg\">https://www.bilibili.com/video/BV13Q4y197Wg</a>)</strong></p>\n<p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目 AC 之后，都不太清楚 dp [i] 表示的是什么。</p>\n<p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中。</strong></p>\n<p>状态转移公式（递推公式）是很重要，但动规<strong>不仅仅只有</strong>递推公式。</p>\n<p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>\n<ol>\n<li>确定 dp 数组（dp table）以及下标的含义</li>\n<li>确定递推公式</li>\n<li>dp 数组如何初始化</li>\n<li>确定遍历顺序</li>\n<li>举例推导 dp 数组</li>\n</ol>\n<p>一些同学可能想<strong>为什么要先确定递推公式，然后在考虑初始化</strong>呢？</p>\n<p><strong>因为一些情况是递推公式决定了 dp 数组要如何初始化！</strong></p>\n<p>后面的讲解中我都是围绕着这五点来进行讲解。</p>\n<p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p>\n<p>其实 确定递推公式 仅仅是解题里的一步而已！</p>\n<p>一些同学知道递推公式，但搞不清楚 dp 数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p>\n<p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p>\n<h3 id=\"动态规划应该如何debug\"><a class=\"markdownIt-Anchor\" href=\"#动态规划应该如何debug\">#</a> 动态规划应该如何 debug</h3>\n<p>相信动规的题目，很大部分同学都是这样做的。</p>\n<p>看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp 数组的初始化，递归公式，遍历顺序，处于一种黑盒的理解状态。</p>\n<p><strong>写动规题目，代码出问题很正常！</strong></p>\n<p><strong>找问题的最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p>\n<p>一些同学对于 dp 的学习是黑盒的状态，就是不清楚 dp 数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。</p>\n<p>这是一个很不好的习惯！</p>\n<p><strong>做动规的题目，写代码之前一定要把状态转移在 dp 数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。</strong></p>\n<p>然后再写代码，如果代码没通过就打印 dp 数组，看看是不是和自己预先推导的哪里不一样。</p>\n<p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p>\n<p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p>\n<p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了。</strong></p>\n<p>这也是我为什么在动规五步曲里强调推导 dp 数组的重要性。</p>\n<p>举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？</p>\n<p>发出这样的问题之前，其实可以自己先思考这三个问题：</p>\n<ul>\n<li>这道题目我举例推导状态转移公式了么？</li>\n<li>我打印 dp 数组的日志了么？</li>\n<li>打印出来了 dp 数组和我想的一样么？</li>\n</ul>\n<p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历 dp 数组的顺序。</p>\n<p>然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。</p>\n<p><strong>注意这里不是说不让大家问问题哈， 而是说问问题之前要有自己的思考，问题要问到点子上！</strong></p>\n<p><strong>大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！</strong></p>\n<p>如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。</p>\n<p>所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何 debug。</p>\n<p>动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。</p>\n<p>在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的 01 背包，leetcode 上的题目都是 01 背包的应用，而没有纯 01 背包的问题，那么就需要在把对应的理论知识讲解一下。</p>\n<p>大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。</p>\n<p>这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容，大家要重视起来哈。</p>\n<h3 id=\"原作者对本题总结\"><a class=\"markdownIt-Anchor\" href=\"#原作者对本题总结\">#</a> 原作者对本题总结</h3>\n<p>这道题目和动态规划：斐波那契数题目基本是一样的，但是会发现本题相比动态规划：斐波那契数难多了，为什么呢？</p>\n<p>关键是 动态规划：斐波那契数 题目描述就已经把动规五部曲里的递归公式和如何初始化都给出来了，剩下几部曲也自然而然的推出来了。</p>\n<p>而本题，就需要逐个分析了，大家现在应该初步感受出关于动态规划，你该了解这些！里给出的动规五部曲了。</p>\n<p>简单题是用来掌握方法论的，例如昨天斐波那契的题目够简单了吧，但昨天和今天可以使用一套方法分析出来的，这就是方法论！</p>\n<p>所以不要轻视简单题，那种凭感觉就刷过去了，其实和没掌握区别不大，只有掌握方法论并说清一二三，才能触类旁通，举一反三哈！</p>\n<h3 id=\"原作者的题目解答\"><a class=\"markdownIt-Anchor\" href=\"#原作者的题目解答\">#</a> 原作者的题目解答</h3>\n<p><strong>原作者的题目解答：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/solution/dai-ma-sui-xiang-lu-dong-tai-gui-hua-jin-y1hw/\">https://leetcode-cn.com/problems/climbing-stairs/solution/dai-ma-sui-xiang-lu-dong-tai-gui-hua-jin-y1hw/</a></strong></p>\n",
            "tags": [
                "算法作业"
            ]
        },
        {
            "id": "http://example.com/passages/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/",
            "url": "http://example.com/passages/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/",
            "title": "二叉树的中序遍历",
            "date_published": "2021-07-15T02:43:29.000Z",
            "content_html": "<h1 id=\"二叉树的中序遍历\"><a class=\"markdownIt-Anchor\" href=\"#二叉树的中序遍历\">#</a> 二叉树的中序遍历</h1>\n<p>​\t\t大一 -&gt; 大二暑期算法作业</p>\n<p>​\t\t<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>\n<h2 id=\"看到题目的感想\"><a class=\"markdownIt-Anchor\" href=\"#看到题目的感想\">#</a> 看到题目的感想</h2>\n<p>​\t\t被离散数学<strong>折磨</strong>之后看见树就会想到离散数学，虽然学习离散数学的时候老师<strong>教过中序遍历</strong>，但是看到这个题的时候还是<strong>没有想起来</strong>中序遍历是个啥，索性就去搜索了一下（快进到被老师打死）。</p>\n<p>​\t\t附上百度百科链接：</p>\n<p>​\t\t<strong>中序遍历：<a href=\"https://baike.baidu.com/item/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86\">https://baike.baidu.com/item/ 中序遍历</a></strong></p>\n<h2 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h2>\n<p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" alt=\"img\"></p>\n<p>输入：root = [1,null,2,3]<br>\n 输出：[1,3,2]</p>\n<p><strong>示例 2：</strong></p>\n<p>输入：root = []<br>\n 输出：[]</p>\n<p><strong>示例 3：</strong></p>\n<p>输入：root = [1]<br>\n 输出：[1]</p>\n<p><strong>示例 4：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg\" alt=\"img\"></p>\n<p>输入：root = [1,2]<br>\n 输出：[2,1]</p>\n<p><strong>示例 5：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg\" alt=\"img\"></p>\n<p>输入：root = [1,null,2]<br>\n 输出：[1,2]</p>\n<p>提示：</p>\n<p>树中节点数目在范围 [0, 100] 内<br>\n - 100 &lt;= Node.val &lt;= 100</p>\n<p>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal\">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a></p>\n<h2 id=\"题目解答\"><a class=\"markdownIt-Anchor\" href=\"#题目解答\">#</a> 题目解答</h2>\n<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>\n<h3 id=\"1递归算法\"><a class=\"markdownIt-Anchor\" href=\"#1递归算法\">#</a> 1. 递归算法</h3>\n<p>利用递归的思想解题也是老朋友了，在之前的算法题里面有过接触，所以并不是很难理解。</p>\n<h4 id=\"1解题思路\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路\">#</a> （1）解题思路</h4>\n<p>​\t\t在解题的时候，了解到了一个名叫 <strong>vector</strong> 的东西，可以理解为 C++ 和 Java 中的一种动态数组。记得第一次听到这个名词的时候还是在翁恺老师的《C 语言程序设计》这门课上听到的，想想还真是怀念。（跑远了</p>\n<p>附上一些链接（<strong>配合梯子一起食用</strong>）：</p>\n<p><strong>vector：内存在堆上</strong></p>\n<p>​    <strong>注意：vector 每添加一次都会把之前的全复制一遍，所以效率并不高。</strong></p>\n<p>​    <strong>1）</strong> <strong><a href=\"https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-160\">https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-160</a>  来源：Microsoft C++、C 和汇编程序文档</strong></p>\n<p>​    <strong>2） <a href=\"https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/package-summary.html\">https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/package-summary.html</a>  来源：Java 官方文档里的包（纯英文比较难顶</strong></p>\n<p>​    <strong>3） <a href=\"https://baike.baidu.com/item/Vector/3330482\">https://baike.baidu.com/item/Vector/3330482</a> 来源：百度百科</strong></p>\n<p>​    <strong>4） <a href=\"https://www.w3cschool.cn/cpp/cpp-i6da2pq0.html\">https://www.w3cschool.cn/cpp/cpp-i6da2pq0.html</a>  来源：某不知名 C++ 教程</strong></p>\n<p>​    <strong>《C 语言程序设计》：<a href=\"https://www.icourse163.org/learn/ZJU-9001?tid=9001#/learn/announce\">https://www.icourse163.org/learn/ZJU-9001?tid=9001#/learn/announce</a>  来源：中国大学 MOOC</strong></p>\n<p>​\t\t本题可以通过递归思想对给出的二叉树的<strong>左子树、根节点、右子树依次进行遍历（中序遍历）</strong>，并将各个数据存放在设置好的 vector<int>中（由于 vector 是<strong>动态分配内存</strong>的，所以比用担心大小会不够用），最后即可得到该二叉树的中序遍历。</p>\n<h4 id=\"2代码\"><a class=\"markdownIt-Anchor\" href=\"#2代码\">#</a> （2）代码</h4>\n<p>​\t\t解题代码如下（<strong>配合题目链接食用</strong>）：</p>\n<h5 id=\"c\"><a class=\"markdownIt-Anchor\" href=\"#c\">#</a> <strong>C++</strong></h5>\n<p><strong>有一种比较好用的 C++ 容器，比 vector 好用，只是不能自增。（本题未使用）</strong></p>\n<p><strong>array：内存在栈上</strong></p>\n<p><strong>array： <a href=\"http://c.biancheng.net/view/6688.html\">http://c.biancheng.net/view/6688.html</a> 来源：C 语言中文网</strong></p>\n<p><strong>array： <a href=\"https://www.bilibili.com/video/BV18b4y1X7EB?from=search&amp;seid=11718690349134275715\">https://www.bilibili.com/video/BV18b4y1X7EB?from=search&amp;seid=11718690349134275715</a> 来源：哔哩哔哩（是一个油管的小哥哥，讲的很棒，圈粉了）</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode* root, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root) &#123; <span class=\"comment\">// 如果碰到空节点，说明该部分遍历已完成，return出去</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root-&gt;left, res); <span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">        res.<span class=\"built_in\">push_back</span>(root-&gt;val); <span class=\"comment\">// 将该节点的值增加在动态数组末尾</span></span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root-&gt;right, res); <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; res; <span class=\"comment\">// 新建一个int类型的vector,用来存放遍历结果</span></span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root, res); <span class=\"comment\">// 从根节点root开始遍历，依次放入值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res; <span class=\"comment\">// 返回遍历结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><img src=\"https://img12.360buyimg.com/ddimg/jfs/t1/178612/13/21226/22498/61284220E9e541099/4f61f1de25898a99.png\" alt=\"image-20210827092120481.png\"></li>\n</ul>\n<h5 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\">#</a> <strong>Java</strong></h5>\n<p>List &amp; ArrayList 是 Java 中的一种列表。</p>\n<p><strong>List &amp; ArrayList：<a href=\"https://www.jianshu.com/p/25aa92f8d681\">https://www.jianshu.com/p/25aa92f8d681</a> 来源：简书</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(); <span class=\"comment\">// 新建Integer的List来存放数值</span></span><br><span class=\"line\">        inorder(root, res); <span class=\"comment\">// 从根节点root开始遍历，依次将数值放入</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res; <span class=\"comment\">// 返回遍历结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 如果碰到空节点，说明该部分遍历已完成，return出去</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inorder(root.left, res); <span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">        res.add(root.val); <span class=\"comment\">// 将该节点的值增加在末尾</span></span><br><span class=\"line\">        inorder(root.right, res); <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img14.360buyimg.com/ddimg/jfs/t1/200702/31/3771/22855/6128423eE4f6965f0/3afc9e3dfe9a422d.png\" alt=\"image-20210827092151479.png\"></p>\n<h5 id=\"c来自题解\"><a class=\"markdownIt-Anchor\" href=\"#c来自题解\">#</a> <strong>C（来自题解）</strong></h5>\n<p>（C 语言中的动态数组不会玩，于是把题解拿过来）</p>\n<p><strong>C 语言动态数组 <a href=\"https://www.runoob.com/w3cnote/c-dynamic-array.html\">https://www.runoob.com/w3cnote/c-dynamic-array.html</a> 来源：菜鸟教程</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span>* res, <span class=\"keyword\">int</span>* resSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    inorder(root-&gt;left, res, resSize);</span><br><span class=\"line\">    res[(*resSize)++] = root-&gt;val;</span><br><span class=\"line\">    inorder(root-&gt;right, res, resSize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">inorderTraversal</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* res = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">501</span>);</span><br><span class=\"line\">    *returnSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    inorder(root, res, returnSize);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode-Solution</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<h4 id=\"3总结\"><a class=\"markdownIt-Anchor\" href=\"#3总结\">#</a> （3）总结</h4>\n<p>​\t\t利用递归思想来解题还是比较舒服的，也很好用，适合我这种菜鸡。</p>\n<h3 id=\"2迭代算法\"><a class=\"markdownIt-Anchor\" href=\"#2迭代算法\">#</a> 2. 迭代算法</h3>\n<p><strong>关于迭代算法的基本思想：</strong></p>\n<p><strong>迭代算法 <a href=\"https://www.cnblogs.com/cs-whut/p/11024564.html\">https://www.cnblogs.com/cs-whut/p/11024564.html</a> 来源：博客园</strong></p>\n<p>​\t\t迭代算法之前没有接触过，上手有点看不懂。</p>\n<h4 id=\"1解题思路-2\"><a class=\"markdownIt-Anchor\" href=\"#1解题思路-2\">#</a> （1）解题思路</h4>\n<p>​\t\t通过迭代 + 栈模型来清楚的展现解题流程（题解中有动画展示，配合食用比较好理解）。</p>\n<h4 id=\"2代码-2\"><a class=\"markdownIt-Anchor\" href=\"#2代码-2\">#</a> （2）代码</h4>\n<p>​\t\t解题代码如下（<strong>配合题目链接食用</strong>）：</p>\n<h5 id=\"c-2\"><a class=\"markdownIt-Anchor\" href=\"#c-2\">#</a> <strong>C++</strong></h5>\n<p>C++ 的栈：</p>\n<p><strong>stack <a href=\"http://c.biancheng.net/view/478.html\">http://c.biancheng.net/view/478.html</a> 来源：C 语言中文网</strong></p>\n<p><strong>stack <a href=\"https://www.apiref.com/cpp-zh/cpp/container/stack.html\">https://www.apiref.com/cpp-zh/cpp/container/stack.html</a> 来源：C++ 文档</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; res; <span class=\"comment\">// 新建一个int类型的vector,用来存放遍历结果</span></span><br><span class=\"line\">        stack&lt;TreeNode*&gt; stk; <span class=\"comment\">// 新建栈</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"literal\">nullptr</span> || !stk.<span class=\"built_in\">empty</span>()) &#123; <span class=\"comment\">// 节点有数值 或 栈不为空</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 当节点有值时</span></span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(root); <span class=\"comment\">// 数据入栈</span></span><br><span class=\"line\">                root = root-&gt;left; <span class=\"comment\">// 访问左子树</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stk.<span class=\"built_in\">top</span>(); <span class=\"comment\">// 找到栈顶数据的节点</span></span><br><span class=\"line\">            <span class=\"comment\">// top()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</span></span><br><span class=\"line\">            stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"comment\">// pop()：弹出栈顶元素。</span></span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(root-&gt;val); <span class=\"comment\">// 在vector末尾添加当前节点数据</span></span><br><span class=\"line\">            root = root-&gt;right; <span class=\"comment\">// 访问右子树</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res; <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img13.360buyimg.com/ddimg/jfs/t1/191173/7/19840/22319/6128425eE22b3e07d/1ca7845e69631535.png\" alt=\"image-20210827092218700.png\"></p>\n<h5 id=\"java-2\"><a class=\"markdownIt-Anchor\" href=\"#java-2\">#</a> <strong>Java</strong></h5>\n<p>Java 的栈：</p>\n<p><strong>Deque： <a href=\"https://www.jianshu.com/p/d78a7c982edb\">https://www.jianshu.com/p/d78a7c982edb</a> 来源：简书</strong></p>\n<p><strong>stack：</strong>**</p>\n<p><strong>（1） <a href=\"https://www.javatpoint.com/java-stack\">https://www.javatpoint.com/java-stack</a>  来源：某 Java 文档</strong></p>\n<p><strong>（2） <a href=\"https://blog.csdn.net/YQYnsmile/article/details/78457539\">https://blog.csdn.net/YQYnsmile/article/details/78457539</a>  来源：屑 C 某某 N</strong></p>\n<p><strong>（3） <a href=\"https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Stack.html\">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Stack.html</a>  来源：某全英文 Java 文档</strong></p>\n<p>Deque 可以作为堆栈（LIFO 后进先出），此接口优于传统 Stack 类的使用。</p>\n<p><strong>Stack 和 Deque 方法的比较</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">栈方法</th>\n<th style=\"text-align:center\">等效 Deque 方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">push(e)</td>\n<td style=\"text-align:center\">addFirst(e)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">pop()</td>\n<td style=\"text-align:center\">removeFirst()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">peek()</td>\n<td style=\"text-align:center\">peekFirst()</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(); <span class=\"comment\">// 新建List来保存数据</span></span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stk = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;(); <span class=\"comment\">// 新建栈</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span> || !stk.isEmpty()) &#123; <span class=\"comment\">// 节点有数值 或 栈不为空</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 节点有数值时</span></span><br><span class=\"line\">                stk.push(root); <span class=\"comment\">// 将数据放入栈</span></span><br><span class=\"line\">                root = root.left; <span class=\"comment\">// 访问左子树</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stk.pop(); <span class=\"comment\">// pop()：弹出栈顶元素。</span></span><br><span class=\"line\">            res.add(root.val); <span class=\"comment\">// 在List末尾添加当前节点数据</span></span><br><span class=\"line\">            root = root.right; <span class=\"comment\">// 访问右子树</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res; <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img13.360buyimg.com/ddimg/jfs/t1/177616/31/21117/22717/6128427aE9968827a/f401017322512ef0.png\" alt=\"image-20210827092339328.png\"></p>\n<h5 id=\"c来自题解-2\"><a class=\"markdownIt-Anchor\" href=\"#c来自题解-2\">#</a> <strong>C</strong>（来自题解）</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">inorderTraversal</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</span><br><span class=\"line\">    *returnSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* res = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">501</span>);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>** <span class=\"title\">stk</span> =</span> <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TreeNode*) * <span class=\"number\">501</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (root != <span class=\"literal\">NULL</span> || top &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            stk[top++] = root;</span><br><span class=\"line\">            root = root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root = stk[--top];</span><br><span class=\"line\">        res[(*returnSize)++] = root-&gt;val;</span><br><span class=\"line\">        root = root-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode-Solution</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<h4 id=\"3总结-2\"><a class=\"markdownIt-Anchor\" href=\"#3总结-2\">#</a> （3）总结</h4>\n<p>​\t\t利用迭代算法来解题的思想还没有怎么接触过没上手感觉比较难。（<strong>还是递归香</strong>    <strong>确信</strong>）</p>\n<h3 id=\"3morris-中序遍历来自题解\"><a class=\"markdownIt-Anchor\" href=\"#3morris-中序遍历来自题解\">#</a> 3.Morris 中序遍历（来自题解）</h3>\n<p>​\t\t这个就是真的闻所未闻了，看了题解，决定搬过来</p>\n<h4 id=\"1思路与算法\"><a class=\"markdownIt-Anchor\" href=\"#1思路与算法\">#</a> （1）思路与算法</h4>\n<ol>\n<li>\n<p><strong>Morris 遍历算法</strong>是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O (1) O (1)。</p>\n<p><strong>Morris 遍历算法</strong>整体步骤如下（假设当前遍历到的节点为 xx）：</p>\n</li>\n<li>\n<p>如果 xx 无左孩子，先将 xx 的值加入答案数组，再访问 xx 的右孩子，即 x  =  x . right。<br>\n如果 xx 有左孩子，则找到 xx 左子树上最右的节点（<strong>即左子树中序遍历的最后一个节点，xx 在中序遍历中的前驱节点</strong>），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。</p>\n<ul>\n<li>如果 predecessor 的右孩子为空，则将其右孩子指向 xx，然后访问 xx 的左孩子，即  x  =  x . left。</li>\n<li>如果 predecessor 的右孩子不为空，则此时其右孩子指向 xx，说明我们已经遍历完 xx 的左子树，我们将 predecessor 的右孩子置空，将 xx 的值加入答案数组，然后访问 xx 的右孩子，即  x  =  x . right。</li>\n</ul>\n</li>\n<li>\n<p>重复上述操作，直至访问完整棵树。</p>\n<p>4. 其实整个过程我们就多做一步：假设当前遍历到的节点为 xx，将 xx 的左子树中最右边的节点的右孩子指向 xx，这样在左子树遍历完成后我们通过这个指向走回了 xx，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p>\n</li>\n</ol>\n<h4 id=\"2代码-3\"><a class=\"markdownIt-Anchor\" href=\"#2代码-3\">#</a> （2）代码</h4>\n<p><strong>题解链接： <a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/\">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</a> 来源：力扣</strong></p>\n<p>​\t\t不想搬运代码了，就给出了链接。<strong>Morris 中序遍历</strong>是题解中的第三种解法，题解带有动画教程，可以看看。</p>\n<h4 id=\"3总结-3\"><a class=\"markdownIt-Anchor\" href=\"#3总结-3\">#</a> （3）总结</h4>\n<p>​\t\t一种没听过的中序遍历算法，搬运题解来的。（主要还是太菜了没玩明白）</p>\n<h2 id=\"题目总结\"><a class=\"markdownIt-Anchor\" href=\"#题目总结\">#</a> 题目总结</h2>\n<p>​\t\t此次题目中，出现了<strong>递归算法、迭代算法、Morris 遍历算法</strong>三种解题思路。</p>\n<p>​\t\t总的来说，还是递归较好理解，写起来难度稍微低一些；迭代算法初次了解，试了试水；Morris 遍历算法第一次见，还是看题解叭（还是人菜）。</p>\n",
            "tags": [
                "算法作业"
            ]
        }
    ]
}