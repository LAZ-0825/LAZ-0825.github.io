<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用java将ResultSet中的数据打印成表格</title>
      <link href="/passages/%E4%BD%BF%E7%94%A8java%E5%B0%86ResultSet%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%89%93%E5%8D%B0%E6%88%90%E8%A1%A8%E6%A0%BC/"/>
      <url>/passages/%E4%BD%BF%E7%94%A8java%E5%B0%86ResultSet%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%89%93%E5%8D%B0%E6%88%90%E8%A1%A8%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a class="markdownIt-Anchor" href="#背景介绍">#</a> 背景介绍</h1><p>在写课设的时候呢，有一个需求是将数据库的数据输出到控制台，最好是格式化输出。</p><p>刚开始的时候我使用的方法是使用 select 语句讲数据拿到 ResultSet 中，之后将数据一条一条的放进对象中，之后放进 Arraylist 中来遍历输出。这种方法的效率较低，占用的时间空间都比较大。于是开始寻找一些方便好用的格式化输出 ResultSet 数据的方法，最终在参考了一些资料后整理出了这个方法。</p><h1 id="需求描述"><a class="markdownIt-Anchor" href="#需求描述">#</a> 需求描述</h1><p><code>MySQL</code>  的查询语句输出如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+------------+-----------+-----------+</span><br><span class="line">| id         | name      | phone     |</span><br><span class="line">+------------+-----------+-----------+</span><br><span class="line">| <span class="number">2007040901</span> | 小亮      | <span class="number">789789789</span> |</span><br><span class="line">| <span class="number">2007040902</span> | 小白      | <span class="number">852852852</span> |</span><br><span class="line">| <span class="number">2007040903</span> | 小明      | <span class="number">123123123</span> |</span><br><span class="line">| <span class="number">2007040904</span> | 小红      | <span class="number">456456456</span> |</span><br><span class="line">| <span class="number">2007040905</span> | 大飞      | <span class="number">456645564</span> |</span><br><span class="line">| <span class="number">2007041001</span> | 小青      | <span class="number">123456789</span> |</span><br><span class="line">| <span class="number">2007041002</span> | 小飞      | <span class="number">321654987</span> |</span><br><span class="line">| <span class="number">2007041003</span> | 小跑      | <span class="number">963852741</span> |</span><br><span class="line">| <span class="number">2007041004</span> | 大白      | <span class="number">789789789</span> |</span><br><span class="line">| <span class="number">2007041101</span> | 小王      | <span class="number">111222333</span> |</span><br><span class="line">| <span class="number">2007041102</span> | 小星      | <span class="number">444555666</span> |</span><br><span class="line">| <span class="number">2007041103</span> | 小义      | <span class="number">777888999</span> |</span><br><span class="line">| <span class="number">2007041104</span> | 萧山      | <span class="number">111444777</span> |</span><br><span class="line">| <span class="number">2007041105</span> | 大王      | <span class="number">123123123</span> |</span><br><span class="line">| <span class="number">2007041201</span> | 赵小花    | <span class="number">222555888</span> |</span><br><span class="line">| <span class="number">2007041202</span> | 赵大花    | <span class="number">333666999</span> |</span><br><span class="line">| <span class="number">2007041203</span> | 赵老花    | <span class="number">159357123</span> |</span><br><span class="line">| <span class="number">2007041204</span> | 赵仙花    | <span class="number">623847456</span> |</span><br><span class="line">| <span class="number">2007041205</span> | 大力      | <span class="number">915915159</span> |</span><br><span class="line">| <span class="number">2007041301</span> | 郭小凯    | <span class="number">159159159</span> |</span><br><span class="line">| <span class="number">2007041302</span> | 郭大凯    | <span class="number">357357357</span> |</span><br><span class="line">| <span class="number">2007041303</span> | 郭老凯    | <span class="number">852852852</span> |</span><br><span class="line">| <span class="number">2007041304</span> | 郭仙凯    | <span class="number">963963963</span> |</span><br><span class="line">| <span class="number">2007041305</span> | 大明      | <span class="number">357537753</span> |</span><br><span class="line">+------------+-----------+-----------+</span><br><span class="line"><span class="number">24</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>使用 <code>JDBC</code>  执行上述的查询语句，将结果集中的查询结果以表格的形式打印出来。</p><h1 id="思路"><a class="markdownIt-Anchor" href="#思路">#</a> 思路</h1><ul><li>通过结果集的元数据可以知道结果集中的列数，和列名.</li><li>然后遍历结果集，分别统计每一列中的最大字符数。</li><li>然后通过 <code>System.out.printf()</code>  方法进行格式化输出。</li></ul><h1 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现">#</a> 具体实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSetMetaData;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果集打印机.将结果集中的数据打印成表格.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSetPrinter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printResultSet</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ResultSetMetaData resultSetMetaData = rs.getMetaData();</span><br><span class="line">        <span class="comment">// 获取列数</span></span><br><span class="line">        <span class="keyword">int</span> ColumnCount = resultSetMetaData.getColumnCount();</span><br><span class="line">        <span class="comment">// 保存当前列最大长度的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] columnMaxLengths = <span class="keyword">new</span> <span class="keyword">int</span>[ColumnCount];</span><br><span class="line">        <span class="comment">// 缓存结果集,结果集可能有序,所以用ArrayList保存变得打乱顺序.</span></span><br><span class="line">        ArrayList&lt;String[]&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 按行遍历</span></span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="comment">// 保存当前行所有列</span></span><br><span class="line">            String[] columnStr = <span class="keyword">new</span> String[ColumnCount];</span><br><span class="line">            <span class="comment">// 获取属性值.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ColumnCount; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取一列</span></span><br><span class="line">                columnStr[i] = rs.getString(i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 计算当前列的最大长度</span></span><br><span class="line">                columnMaxLengths[i] = Math.max(columnMaxLengths[i], (columnStr[i] == <span class="keyword">null</span>) ? <span class="number">0</span> : columnStr[i].length());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缓存这一行.</span></span><br><span class="line">            results.add(columnStr);</span><br><span class="line">        &#125;</span><br><span class="line">        printSeparator(columnMaxLengths);</span><br><span class="line">        printColumnName(resultSetMetaData, columnMaxLengths);</span><br><span class="line">        printSeparator(columnMaxLengths);</span><br><span class="line">        <span class="comment">// 遍历集合输出结果</span></span><br><span class="line">        Iterator&lt;String[]&gt; iterator = results.iterator();</span><br><span class="line">        String[] columnStr;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            columnStr = iterator.next();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ColumnCount; i++) &#123;</span><br><span class="line">                <span class="comment">// System.out.printf(&quot;|%&quot; + (columnMaxLengths[i] + 1) + &quot;s&quot;, columnStr[i]);</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;|%&quot;</span> + columnMaxLengths[i] + <span class="string">&quot;s&quot;</span>, columnStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printSeparator(columnMaxLengths);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出列名.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultSetMetaData 结果集的元数据对象.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMaxLengths  每一列最大长度的字符串的长度.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printColumnName</span><span class="params">(ResultSetMetaData resultSetMetaData, <span class="keyword">int</span>[] columnMaxLengths)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> columnCount = resultSetMetaData.getColumnCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">            <span class="comment">// System.out.printf(&quot;|%&quot; + (columnMaxLengths[i] + 1) + &quot;s&quot;, resultSetMetaData.getColumnName(i + 1));</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;|%&quot;</span> + columnMaxLengths[i] + <span class="string">&quot;s&quot;</span>, resultSetMetaData.getColumnName(i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出分隔符.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMaxLengths 保存结果集中每一列的最长的字符串的长度.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSeparator</span><span class="params">(<span class="keyword">int</span>[] columnMaxLengths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnMaxLengths.length; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">            <span class="comment">// for (int j = 0; j &lt; columnMaxLengths[i] + 1; j++) &#123;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columnMaxLengths[i]; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="测试"><a class="markdownIt-Anchor" href="#测试">#</a> 测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String URL = <span class="string">&quot;jdbc:mysql://localhost:3306/student_information?useUnicode=true&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDBC测试.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JDBCexample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.加载数据库驱动</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        testStatement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试Statement的用法.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="comment">// 2.打开数据库连接</span></span><br><span class="line">             Connection conn = DriverManager.getConnection(URL, user, password);</span><br><span class="line">             <span class="comment">// 3.创建语句</span></span><br><span class="line">             Statement stmt = conn.createStatement()) &#123;</span><br><span class="line">            <span class="comment">// 模拟SQL注入</span></span><br><span class="line">            testSqlInjecton(stmt);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SQLException : &quot;</span> + sqle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟SQL注入.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt Statement对象.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSqlInjecton</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from student&quot;</span>;</span><br><span class="line">        ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line">        ResultSetPrinter.printResultSet(rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JDBCexample();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果">#</a> 运行结果</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+----------+---+---------+</span><br><span class="line">|        id|name|    phone|</span><br><span class="line">+----------+---+---------+</span><br><span class="line">|<span class="number">2007040901</span>| 小亮|<span class="number">789789789</span>|</span><br><span class="line">|<span class="number">2007040902</span>| 小白|<span class="number">852852852</span>|</span><br><span class="line">|<span class="number">2007040903</span>| 小明|<span class="number">123123123</span>|</span><br><span class="line">|<span class="number">2007040904</span>| 小红|<span class="number">456456456</span>|</span><br><span class="line">|<span class="number">2007040905</span>| 大飞|<span class="number">456645564</span>|</span><br><span class="line">|<span class="number">2007041001</span>| 小青|<span class="number">123456789</span>|</span><br><span class="line">|<span class="number">2007041002</span>| 小飞|<span class="number">321654987</span>|</span><br><span class="line">|<span class="number">2007041003</span>| 小跑|<span class="number">963852741</span>|</span><br><span class="line">|<span class="number">2007041004</span>| 大白|<span class="number">789789789</span>|</span><br><span class="line">|<span class="number">2007041101</span>| 小王|<span class="number">111222333</span>|</span><br><span class="line">|<span class="number">2007041102</span>| 小星|<span class="number">444555666</span>|</span><br><span class="line">|<span class="number">2007041103</span>| 小义|<span class="number">777888999</span>|</span><br><span class="line">|<span class="number">2007041104</span>| 萧山|<span class="number">111444777</span>|</span><br><span class="line">|<span class="number">2007041105</span>| 大王|<span class="number">123123123</span>|</span><br><span class="line">|<span class="number">2007041201</span>|赵小花|<span class="number">222555888</span>|</span><br><span class="line">|<span class="number">2007041202</span>|赵大花|<span class="number">333666999</span>|</span><br><span class="line">|<span class="number">2007041203</span>|赵老花|<span class="number">159357123</span>|</span><br><span class="line">|<span class="number">2007041204</span>|赵仙花|<span class="number">623847456</span>|</span><br><span class="line">|<span class="number">2007041205</span>| 大力|<span class="number">915915159</span>|</span><br><span class="line">|<span class="number">2007041301</span>|郭小凯|<span class="number">159159159</span>|</span><br><span class="line">|<span class="number">2007041302</span>|郭大凯|<span class="number">357357357</span>|</span><br><span class="line">|<span class="number">2007041303</span>|郭老凯|<span class="number">852852852</span>|</span><br><span class="line">|<span class="number">2007041304</span>|郭仙凯|<span class="number">963963963</span>|</span><br><span class="line">|<span class="number">2007041305</span>| 大明|<span class="number">357537753</span>|</span><br><span class="line">+----------+---+---------+</span><br></pre></td></tr></table></figure><h2 id="提示"><a class="markdownIt-Anchor" href="#提示">#</a> 提示</h2><p>在使用时可以根据具体情况适当的做一些微调，以便达到想要的效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-632-最小区间</title>
      <link href="/passages/Leetcode-632-%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/"/>
      <url>/passages/Leetcode-632-%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-632-最小区间"><a class="markdownIt-Anchor" href="#leetcode-632-最小区间">#</a> Leetcode 632. 最小区间</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>你有  <code>k</code>  个 <strong>非递减排列</strong> 的整数列表。找到一个 <strong>最小</strong> 区间，使得  <code>k</code>  个列表中的每个列表至少有一个数包含在其中。</p><p>我们定义如果  <code>b-a &lt; d-c</code>  或者在  <code>b-a == d-c</code>  时  <code>a &lt; c</code> ，则区间  <code>[a,b]</code>  比  <code>[c,d]</code>  小。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">4</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">24</span>,<span class="number">26</span>], [<span class="number">0</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">20</span>], [<span class="number">5</span>,<span class="number">18</span>,<span class="number">22</span>,<span class="number">30</span>]]</span><br><span class="line">输出：[<span class="number">20</span>,<span class="number">24</span>]</span><br><span class="line">解释： </span><br><span class="line">列表 <span class="number">1</span>：[<span class="number">4</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">24</span>, <span class="number">26</span>]，<span class="number">24</span> 在区间 [<span class="number">20</span>,<span class="number">24</span>] 中。</span><br><span class="line">列表 <span class="number">2</span>：[<span class="number">0</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">20</span>]，<span class="number">20</span> 在区间 [<span class="number">20</span>,<span class="number">24</span>] 中。</span><br><span class="line">列表 <span class="number">3</span>：[<span class="number">5</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">30</span>]，<span class="number">22</span> 在区间 [<span class="number">20</span>,<span class="number">24</span>] 中。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>nums.length == k</code></li><li><code>1 &lt;= k &lt;= 3500</code></li><li><code>1 &lt;= nums[i].length &lt;= 50</code></li><li><code>-105 &lt;= nums[i][j] &lt;= 105</code></li><li><code>nums[i]</code>  按非递减顺序排列</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists">https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2><p>在解题过程中我们可以将题目给的若干列表表示出来，这里以三个列表为例。</p><p>我们用线段表示这三个列表的区间，用红圈表示列表中的元素。表示如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/2fe077483aeb92a1.png" alt=""></p><p>题目要求我们寻找一个区间，要求囊括每个有序列表中的至少一个元素。我们可以在上面画出的区间中画出非常多符合条件的区间，这里我们少画几个。画出的区间如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/d3d1fa9b9c608659.png" alt=""></p><p>这里的 “<strong>至少一个元素</strong>” 可以理解成 “<strong>一个元素</strong>”，上图的区间一和区间二便是如此。因此，我们要寻找的最小区间只需要包含每个有序列表内的一个元素即可，于是我们得到了区间二和区间三。</p><p>那么，对于区间二和区间三，我们如何判断它们当中谁是我们要找的最小区间呢？那一定是这个区间内所包含的 3 个 (  <code>k</code>  个) 元素中，最小值和最大值的差值最小的那一个，这也就代表了这个区间最小。显然，区间二中最大值与最小值的差值小于区间三中最大值与最小值的差值，所以区间二比区间三要小。如果两个区间中最大值与最小值的差值相等，则数值小的区间小（参照题目中的条件：我们定义如果  <code>b-a &lt; d-c</code>  或者在  <code>b-a == d-c</code>  时  <code>a &lt; c</code> ，则区间  <code>[a,b]</code>  比  <code>[c,d]</code>  小）。</p><p>现在我们以  <code>nums = [[2,4,7],[1,4,5],[3,5,6,8]]</code>  作为示例来思考如何寻找最小区间。</p><p>我们先将这三个列表画出来，如下图所示：</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/3472a07507d62809.png" alt=""></p><p>我们可以为每个列表定义一个指针，如图：</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/cded557384c82251.png" alt=""></p><p>此时，这三个指针所指的三个元素可以构成一个最小区间，且最小值与最大值的差值为 2，我们先记录下来。</p><p>接下来我们寻找最小区间，如何寻找呢？我们可以将此时的左边界右移来缩小区间，计算右移后的区间长度，发现和上一个区间的长度相同，并且上一个区间的数值更小，所以此次移动后不记录区间长度；右移之后如图所示：</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/731f91a9504823f6.png" alt=""></p><p>再次将左边界右移来缩小区间，计算右移后的区间长度并记录；右移之后如图所示：</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/b88b829a7be1d5b9.png" alt=""></p><p>再次将左边界右移来缩小区间，计算右移后的区间长度，发现和上一个区间的长度相同，并且上一个区间的数值更小，所以此次移动后不记录区间长度；右移之后如图所示：</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/1521bfc41376ebb4.png" alt=""></p><p>再次将左边界右移来缩小区间，计算右移后的区间长度，发现大于之前的区间长度，不记录；右移之后如图所示：</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/dfa2f6b9afeed477.png" alt=""></p><p>再次将左边界右移来缩小区间，计算右移后的区间长度，发现大于之前的区间长度，不记录；右移之后如图所示：</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/74a8998a446f0db6.png" alt=""></p><p>此时，第二个列表已经走到最后，左边界将无法移动，此时所记录的最小区间即为我们要寻找的最小区间，即最小区间为  <code>[3,4]</code>  。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2><p>前面列举了两种暴力解答的方法（未实现），后面为上方解题思路的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、暴力解答：遍历每个数组，计算每个数组中出现的每个数字在所有数组中出现过的数组个数</span></span><br><span class="line"><span class="comment">// 全部出现的元素组成的最短区间即为想要的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二、穷举：每个元素作为头和尾，然后判断是否符合条件之后判断是否最短</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次向右移动最小值，记录最短区间长度和位置</span></span><br><span class="line"><span class="comment">// 长度短 或 长度相同时数值小 的区间小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line"><span class="comment">//        定义一个模拟区间，最开始范围是 -1e-5 到 1e-5</span></span><br><span class="line">        <span class="keyword">int</span> leftRange = (<span class="keyword">int</span>)-<span class="number">1e-5</span>;</span><br><span class="line">        <span class="keyword">int</span> rightRange = (<span class="keyword">int</span>)<span class="number">1e5</span>;</span><br><span class="line">        <span class="keyword">int</span> minRange = rightRange - leftRange;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        当前区间内的最大值(选取1e-5结果不对)</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引0，代表第一个链表；ptrs[0] = 指针在链表中的位置</span></span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span>[] ptrs = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line"><span class="comment">//        定义一个优先队列，用来取最小值（也可以用for循环代替）</span></span><br><span class="line"><span class="comment">//        优先队列可以通过 ptrs[index*] 把所有指针所指位置最小的指针放到前面去，从而取到最小值</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer index1, Integer index2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums.get(index1).get(ptrs[index1]) - nums.get(index2).get(ptrs[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      开始时，将索引都赛道队列中，并取下 [max,nums.get(i).get(0)] 区间的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ptrs.length; i++) &#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">            max = max(max, nums.get(i).get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      循环更新，直到某一区间走完</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//          取出最小值（左边界）（也可以用for循环代替）</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = queue.poll();</span><br><span class="line"><span class="comment">//          计算当前范围</span></span><br><span class="line">            <span class="keyword">int</span> curRange = max - nums.get(minIndex).get(ptrs[minIndex]);</span><br><span class="line"><span class="comment">//          如果当前范围小，则更新左右边界</span></span><br><span class="line">            <span class="keyword">if</span> (curRange &lt; minRange) &#123;</span><br><span class="line"><span class="comment">//              更新右边界</span></span><br><span class="line">                minRange = curRange;</span><br><span class="line"><span class="comment">//              左边界是当前值最小的索引（在优先队列的最前面）</span></span><br><span class="line">                leftRange = nums.get(minIndex).get(ptrs[minIndex]);</span><br><span class="line">                rightRange = max;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//          指针右移</span></span><br><span class="line">            ptrs[minIndex]++;</span><br><span class="line"><span class="comment">//          指针超出，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (ptrs[minIndex] == nums.get(minIndex).size())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//          将最小值放入</span></span><br><span class="line">            queue.offer(minIndex);</span><br><span class="line"><span class="comment">//          取得当前区间的最大值</span></span><br><span class="line">            max = max(max, nums.get(minIndex).get(ptrs[minIndex]));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      构造结果并返回</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        result[<span class="number">0</span>] = leftRange;</span><br><span class="line">        result[<span class="number">1</span>] = rightRange;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2><p>本题中寻找最小区间使用的方法是不断右移左边界，使得区间变小，在区间变小是进行比较和统计，最终得到最小区间。</p><p>在本体的解答个过程中，我感觉作图是解题非常好的帮周，可以帮助我们条理的梳理我们的题目，有利于我们的解答。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-218-天际线问题</title>
      <link href="/passages/Leetcode-218-%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
      <url>/passages/Leetcode-218-%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>321</p><h1 id="leetcode-218-天际线问题"><a class="markdownIt-Anchor" href="#leetcode-218-天际线问题">#</a> Leetcode 218. 天际线问题</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>城市的 <strong>天际线</strong> 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 <em>由这些建筑物形成的</em> <strong>天际线</strong> 。</p><p>每个建筑物的几何信息由数组  <code>buildings</code>  表示，其中三元组  <code>buildings[i] = [lefti, righti, heighti]</code>  表示：</p><ul><li><code>lefti</code>  是第  <code>i</code>  座建筑物左边缘的  <code>x</code>  坐标。</li><li><code>righti</code>  是第  <code>i</code>  座建筑物右边缘的  <code>x</code>  坐标。</li><li><code>heighti</code>  是第  <code>i</code>  座建筑物的高度。</li></ul><p>你可以假设所有的建筑都是完美的长方形，在高度为  <code>0</code>  的绝对平坦的表面上。</p><p><strong>天际线</strong> 应该表示为由 “关键点” 组成的列表，格式  <code>[[x1,y1],[x2,y2],...]</code>  ，并按 <strong>x 坐标</strong> 进行 <strong>排序</strong> 。<strong>关键点是水平线段的左端点</strong>。列表中最后一个点是最右侧建筑物的终点， <code>y</code>  坐标始终为  <code>0</code>  ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p><strong>注意</strong>：输出天际线中不得有连续的相同高度的水平线。例如  <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code>  是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个： <code>[...[2 3], [4 5], [12 7], ...]</code></p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：buildings = [[<span class="number">2</span>,<span class="number">9</span>,<span class="number">10</span>],[<span class="number">3</span>,<span class="number">7</span>,<span class="number">15</span>],[<span class="number">5</span>,<span class="number">12</span>,<span class="number">12</span>],[<span class="number">15</span>,<span class="number">20</span>,<span class="number">10</span>],[<span class="number">19</span>,<span class="number">24</span>,<span class="number">8</span>]]</span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">10</span>],[<span class="number">3</span>,<span class="number">15</span>],[<span class="number">7</span>,<span class="number">12</span>],[<span class="number">12</span>,<span class="number">0</span>],[<span class="number">15</span>,<span class="number">10</span>],[<span class="number">20</span>,<span class="number">8</span>],[<span class="number">24</span>,<span class="number">0</span>]]</span><br><span class="line">解释：</span><br><span class="line">图 A 显示输入的所有建筑物的位置和高度，</span><br><span class="line">图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：buildings = [[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= buildings.length &lt;= 104</code></li><li><code>0 &lt;= lefti &lt; righti &lt;= 231 - 1</code></li><li><code>1 &lt;= heighti &lt;= 231 - 1</code></li><li><code>buildings</code>  按  <code>lefti</code>  非递减排序</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/the-skyline-problem">https://leetcode-cn.com/problems/the-skyline-problem</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2><p>解答本题使用的是扫描线算法，对于这个题我本来是没什么思路的，后来看了一些教程才有的思路。</p><p>扫描线算法，顾名思义就是对线条进行扫描，这里我们扫描的是建筑物的边缘线。</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/608b58569bd2a360.png" alt=""></p><p>我在这里先简述一下扫描线算法的原理：构造一个大顶堆（优先队列也行），从左到右扫描建筑物，扫描到左边线时，将该建筑物的高度加入大顶堆；扫描到右边线，将当前建筑物的高度弹出大顶堆。在扫描搭配左（右）边线并将当前建筑物的高度加入（弹出）大顶堆之后，我们需要观察大顶堆的最大值有没有发生变化，如果发生变化，则证明产生了关键点，并记录产生的关键点，关键点坐标为 (当前的 x 坐标，大顶堆弹出当前建筑物高度后的最大值)。经过这样的一边扫描之后，我们就可以顺利的得到我们想要的关键点了。</p><p>那么，如何区分左边线和右边线呢？这里使用的方法是在读入数据的时候将左边线的纵坐标读入成负值，这样就可以通过纵坐标的正负来判断扫描到的线是左边线还是右边线了。</p><p>在读入数据结束后，我们需要使用 sort 函数对数据进行升序排序，以确保：</p><ol><li>我们是从左到右来扫描边线</li><li>我们扫描边线碰到某条左边线和某条右边线重合的情况时，先对左边线进行扫描，再扫描右边线（因为录入信息的时候将左边线的纵坐标录入为负值，在 sort 排序时横坐标相同的情况下左边线靠前，从而可以先进行扫描）</li><li>两条左边先重合时让高度高的线进入大根堆</li><li>两条右边线重合时高度小的先弹出大根堆</li></ol><p>这样，在扫描结束后我们就可以得到想要的关键点集合了</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2><p>C++ multiset</p><p><a href="https://blog.csdn.net/sodacoco/article/details/84798621">(133 条消息) multiset 用法总结__CSDN</a></p><p><a href="https://www.educba.com/c-plus-plus-multiset/">C++ Multiset | Tutorials on Top 27 Multiset Functions with Examples (educba.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="comment">// auto&amp; 会修改 buildings 里面的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; b: buildings) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(&#123; b[<span class="number">0</span>], -b[<span class="number">2</span>] &#125;);</span><br><span class="line">            vec.<span class="built_in">push_back</span>(&#123; b[<span class="number">1</span>], b[<span class="number">2</span>] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// multiset当大顶堆的用</span></span><br><span class="line">        multiset&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="comment">// 初始化 先放一个0</span></span><br><span class="line">        pq.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> preMax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键点存放</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : vec) &#123;</span><br><span class="line">            <span class="comment">// 遇到左边线</span></span><br><span class="line">            <span class="keyword">if</span> (p.second &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">insert</span>(-p.second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到右边线</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pq.<span class="built_in">erase</span>(pq.<span class="built_in">find</span>(p.second));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取当前最大值</span></span><br><span class="line">            <span class="keyword">int</span> curMax = *pq.<span class="built_in">rbegin</span>();</span><br><span class="line">            <span class="comment">// 判断是否为关键点</span></span><br><span class="line">            <span class="keyword">if</span> (curMax != preMax) &#123;</span><br><span class="line">                <span class="comment">// 放入关键点集合并更新最大值</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123; p.first,curMax &#125;);</span><br><span class="line">                preMax = curMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2><p>第一次接触扫描线算法，感觉非常有意思，但我感觉扫描线算法的用处不止这样，相信以后还能碰到。</p><p>在本次解题过程中，我感觉左边线的负值处理和读入数据后的 sort 排序比较有意思。</p><p>菜鸡先爬了～～～</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-1226-哲学家进餐</title>
      <link href="/passages/Leetcode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90/"/>
      <url>/passages/Leetcode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-1226-哲学家进餐"><a class="markdownIt-Anchor" href="#leetcode-1226-哲学家进餐">#</a> Leetcode 1226. 哲学家进餐</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p><p>所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p><p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p><p>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/23/an_illustration_of_the_dining_philosophers_problem.png" alt=""></p><p>问题描述和图片来自维基百科 <a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">https://en.wikipedia.org/wiki/Dining_philosophers_problem</a></p><p>哲学家从 <strong>0</strong> 到 <strong>4</strong> 按 <strong>顺时针</strong> 编号。请实现函数  <code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code> ：</p><ul><li><p><code>philosopher</code>  哲学家的编号。</p></li><li><p><code>pickLeftFork</code>  和  <code>pickRightFork</code>  表示拿起左边或右边的叉子。</p></li><li><p><code>eat</code>  表示吃面。</p></li><li><p><code>putLeftFork</code>  和  <code>putRightFork</code>  表示放下左边或右边的叉子。</p></li><li><p>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。</p></li></ul><p>给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：[[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">解释:</span><br><span class="line">n 表示每个哲学家需要进餐的次数。</span><br><span class="line">输出数组描述了叉子的控制和进餐的调用，它的格式如下：</span><br><span class="line">output[i] = [a, b, c] (<span class="number">3</span>个整数)</span><br><span class="line"></span><br><span class="line">- a 哲学家编号。</span><br><span class="line">- b 指定叉子：&#123;<span class="number">1</span> : 左边, <span class="number">2</span> : 右边&#125;.</span><br><span class="line">- c 指定行为：&#123;<span class="number">1</span> : 拿起, <span class="number">2</span> : 放下, <span class="number">3</span> : 吃面&#125;。</span><br><span class="line">  如 [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>] 表示 <span class="number">4</span> 号哲学家拿起了右边的叉子。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 60</code></li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/the-dining-philosophers">https://leetcode-cn.com/problems/the-dining-philosophers</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2><p>​本题要求 (题意)：设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p><p>​刚开始的话，简单了解到了信号量  <code>Semaphore</code>  的用法，并写了一个感觉不是很切合题意的解决方法（一个一个吃）。</p><p>​之后又简单学习了  <code>synchronized</code>  的用法 (详见上一篇博客)，并按照  <code>synchronized</code>  的限制思路来写了一个  <code>synchronized</code>  修饰类内方法的解决方法（感觉也不是很符合题意）。</p><h3 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore">#</a> Semaphore</h3><p>​  <code>Semaphore</code>  可以控制同一时间访问资源的线程总数，通过  <code>acquire()</code>  和  <code>release()</code>  来获取和释放信号量从而实现对线程数量的控制。所以我们在解体的时候可以通过限制线程总数为 1 的方法来实现一个一个吃的暴力解决办法。</p><p><code>Semaphore semaphore = new Semaphore(1);</code>   -&gt; 限制线程总数为 1（只有一个信号量）</p><p><code>semaphore.acquire(1);</code>   -&gt; 获取一个信号量，并将信号量数量 - 1</p><p><code>semaphore.release(1);</code>   -&gt; 释放一个信号量，并将信号量数量 + 1</p><h3 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized">#</a> synchronized</h3><p>​被  <code>synchronized</code>  修饰的代码同一时间只能被一个作用的对象访问，  <code>synchronized</code>  修饰的位置不同，相对应的作用对象不同。例如：</p><p>​  <code>synchronized</code>  修饰一个普通方法： -&gt; 作用对象为调用这个方法的对象。</p><p>​  <code>synchronized</code>  修饰一个  <code>static</code>  方法： -&gt; 作用对象为这个类的所有对象。</p><p>由于本题中使用的是  <code>DiningPhilosophers</code>  类的同一个对象，所以两种方法均可（不过个人感觉还是  <code>synchronized</code>  修饰一个普通方法）好一些。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2><h3 id="semaphore-2"><a class="markdownIt-Anchor" href="#semaphore-2">#</a> Semaphore</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制线程总数为1（只有一个信号量）</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 一个一个吃</span></span><br><span class="line">        semaphore.acquire(<span class="number">1</span>); <span class="comment">// 获取一个信号量，并将信号量数量 - 1</span></span><br><span class="line">        pickLeftFork.run();</span><br><span class="line">        pickRightFork.run();</span><br><span class="line">        eat.run();</span><br><span class="line">        putLeftFork.run();</span><br><span class="line">        putRightFork.run();</span><br><span class="line">        semaphore.release(<span class="number">1</span>); <span class="comment">// 释放一个信号量，并将信号量数量 + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/02/f412682f61fb2cf2.png" alt=""></p><h3 id="synchronized-2"><a class="markdownIt-Anchor" href="#synchronized-2">#</a> synchronized</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 i 号哲学家，需要获取 [i, i%5] 号筷子。但是获取筷子之前需要让synchronized获取到对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="comment">// 由于本题中使用的是DiningPhilosophers类的同一个对象，所以该方法可以是普通方法也可以是static方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        pickLeftFork.run();</span><br><span class="line">        pickRightFork.run();</span><br><span class="line">        eat.run();</span><br><span class="line">        putLeftFork.run();</span><br><span class="line">        putRightFork.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/02/a1b53eabd78d26cd.png" alt=""></p><h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2><p>​在思路上，我解决本体的方法大体上是每次只允许一个人访问资源，通过  <code>Semaphore</code>  限制进程数量和  <code>synchronized</code>  修饰方法来实现，个人感觉这两种解法不是很符合题意，但是其他的方法还未学会，只能先这样解题了。</p><p>​还是有很多东西需要学习的呜呜呜 (菜鸡嘤嘤～~ ~ doge)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中Synchronized的用法（简单介绍）</title>
      <link href="/passages/Java%E4%B8%ADSynchronized%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%89/"/>
      <url>/passages/Java%E4%B8%ADSynchronized%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍">#</a> 简单介绍</h1><h3 id="synchronized-是java中的关键字是一种同步锁-它修饰的对象有以下几种"><a class="markdownIt-Anchor" href="#synchronized-是java中的关键字是一种同步锁-它修饰的对象有以下几种">#</a>  <code>synchronized</code>  是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种：</h3><p>1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号  <code>&#123;&#125;</code>  括起来的代码，作用的对象是调用这个代码块的对象；<br>　　2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；<br>　　3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；<br>　　4. 修改一个类，其作用的范围是  <code>synchronized</code>  后面括号括起来的部分，作用主的对象是这个类的所有对象。</p><h1 id="修饰一个代码块"><a class="markdownIt-Anchor" href="#修饰一个代码块">#</a> 修饰一个代码块</h1><p>1、一个线程访问一个对象中的  <code>synchronized(this)</code>  同步代码块时，其他试图访问该对象的线程将被阻塞。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wbg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字synchronized&quot;</span>);</span><br><span class="line">        SyncThread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程名:&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用关键字-synchronized-运行结果"><a class="markdownIt-Anchor" href="#使用关键字-synchronized-运行结果">#</a> 使用关键字  <code>synchronized</code>  运行结果</h2><p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813202814267-1084435693.png" alt="img"></p><h2 id="不使用关键字-synchronized-运行结果"><a class="markdownIt-Anchor" href="#不使用关键字-synchronized-运行结果">#</a> 不使用关键字  <code>synchronized</code>  运行结果</h2><p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813215801141-1864858293.png" alt="img"></p><p>当两个并发线程 (  <code>thread1</code>  和  <code>thread2</code>  ) 访问同一个对象 (  <code>syncThread</code>  ) 中的  <code>synchronized</code>  代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。  <code>Thread1</code>  和  <code>thread2</code>  是互斥的，因为在执行  <code>synchronized</code>  代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。<br>我们再把  <code>SyncThread</code>  的调用稍微改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字synchronized每次调用进行new SyncThread()&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread( <span class="keyword">new</span> SyncThread(), <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread( <span class="keyword">new</span> SyncThread(), <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果">#</a> 运行结果</h2><p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813220831864-787748019.png" alt="img"></p><p>为什么上面的例子中  <code>thread1</code>  和  <code>thread2</code>  同时在执行。这是因为  <code>synchronized</code>  只锁定对象，每个对象只有一个锁（  <code>lock</code>  ）与之相关联，而上面的代码等同于下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字synchronized每次调用进行new SyncThread()&quot;</span>);</span><br><span class="line">        SyncThread syncThread1 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        SyncThread syncThread2 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncThread1, <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncThread2, <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这时创建了两个  <code>SyncThread</code>  的对象  <code>syncThread1</code>  和  <code>syncThread2</code>  ，线程  <code>thread1</code>  执行的是  <code>syncThread1</code>  对象中的  <code>synchronized</code>  代码 (  <code>run</code>  )，而线程  <code>thread2</code>  执行的是  <code>syncThread2</code>  对象中的  <code>synchronized</code>  代码 (  <code>run</code>  )；我们知道  <code>synchronized</code>  锁定的是对象，这时会有两把锁分别锁定  <code>syncThread1</code>  对象和  <code>syncThread2</code>  对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。</p><h2 id="二-当一个线程访问对象的一个-synchronizedthis-同步代码块时另一个线程仍然可以访问该对象中的非-synchronizedthis-同步代码块"><a class="markdownIt-Anchor" href="#二-当一个线程访问对象的一个-synchronizedthis-同步代码块时另一个线程仍然可以访问该对象中的非-synchronizedthis-同步代码块">#</a> 二、当一个线程访问对象的一个  <code>synchronized(this)</code>  同步代码块时，另一个线程仍然可以访问该对象中的非  <code>synchronized(this)</code>  同步代码块。</h2><h3 id="多个线程访问-synchronized-和非-synchronized-代码块"><a class="markdownIt-Anchor" href="#多个线程访问-synchronized-和非-synchronized-代码块">#</a> 多个线程访问  <code>synchronized</code>  和非  <code>synchronized</code>  代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字synchronized&quot;</span>);</span><br><span class="line">        Mthreads mt=<span class="keyword">new</span> Mthreads();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(mt, <span class="string">&quot;mt1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(mt, <span class="string">&quot;mt2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mthreads</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mthreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非synchronized代码块，未对count进行读写操作，所以可以不用synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; count:&quot;</span> + count);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">if</span> (threadName.equals(<span class="string">&quot;mt1&quot;</span>)) &#123;</span><br><span class="line">            countAdd();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threadName.equals(<span class="string">&quot;mt2&quot;</span>)) &#123;</span><br><span class="line">            printCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果-2"><a class="markdownIt-Anchor" href="#运行结果-2">#</a> 运行结果</h3><p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813222142309-231904508.png" alt="img"></p><p>上面代码中  <code>countAdd</code>  是一个  <code>synchronized</code>  的，  <code>printCount</code>  是非  <code>synchronized</code>  的。从上面的结果中可以看出一个线程访问一个对象的  <code>synchronized</code>  代码块时，别的线程可以访问该对象的非  <code>synchronized</code>  代码块而不受阻塞。</p><h1 id="修饰一个方法"><a class="markdownIt-Anchor" href="#修饰一个方法">#</a> 修饰一个方法</h1><p><code>Synchronized</code>  修饰一个方法很简单，就是在方法的前面加  <code>synchronized</code>  ，  <code>public synchronized void method()&#123;&#125;</code>  ;   <code>synchronized</code>  修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。如将的  <code>run</code>  方法改成如下的方式，实现的效果一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;线程名:&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                   Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813222952717-956438905.png" alt="img"></p><h2 id="synchronized-作用于整个方法的写法"><a class="markdownIt-Anchor" href="#synchronized-作用于整个方法的写法">#</a>  <code>Synchronized</code>  作用于整个方法的写法。</h2><p>写法一:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法二:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。</p><p>在用  <code>synchronized</code>  修饰方法时要注意以下要点：</p><p><strong> <code>synchronized</code>  关键字不能继承。</strong><br>虽然可以使用  <code>synchronized</code>  来定义方法，但  <code>synchronized</code>  并不属于方法定义的一部分，因此，  <code>synchronized</code>  关键字不能被继承。如果在父类中的某个方法使用了  <code>synchronized</code>  关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上  <code>synchronized</code>  关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下：<br>在子类方法中加上  <code>synchronized</code>  关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lass Parent &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类方法中调用父类的同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; <span class="keyword">super</span>.method();   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><font color=Red>在定义接口方法时不能使用 synchronized 关键字。</font></p><p><font color=Red>构造方法不能使用 synchronized 关键字，但可以使用 synchronized 代码块来进行同步。</font></p><h1 id="修饰一个静态的方法"><a class="markdownIt-Anchor" href="#修饰一个静态的方法">#</a> 修饰一个静态的方法</h1><p><code>Synchronized</code>  也可修饰一个静态方法，用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道静态方法是属于类的而不属于对象的。同样的，  <code>synchronized</code>  修饰的静态方法锁定的是这个类的所有对象。</p><h2 id="synchronized-修饰静态方法"><a class="markdownIt-Anchor" href="#synchronized-修饰静态方法">#</a>  <code>synchronized</code>  修饰静态方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wbg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字静态synchronized&quot;</span>);</span><br><span class="line">        SyncThread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果-3"><a class="markdownIt-Anchor" href="#运行结果-3">#</a> 运行结果</h2><p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813224017511-578390484.png" alt="img"></p><p><code>syncThread1</code>  和  <code>syncThread2</code>  是  <code>SyncThread</code>  的两个对象，但在  <code>thread1</code>  和  <code>thread2</code>  并发执行时却保持了线程同步。这是因为  <code>run</code>  中调用了静态方法  <code>method</code>  ，而静态方法是属于类的，所以  <code>syncThread1</code>  和  <code>syncThread2</code>  相当于用了同一把锁。这与使用关键字  <code>synchronized</code>  运行结果相同</p><h1 id="修饰一个类"><a class="markdownIt-Anchor" href="#修饰一个类">#</a> 修饰一个类</h1><p><code>Synchronized</code>  还可作用于一个类，用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wbg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用ClassName&quot;</span>);</span><br><span class="line">        SyncThread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ClassName.class) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(SyncThread.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果-4"><a class="markdownIt-Anchor" href="#运行结果-4">#</a> 运行结果</h2><p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813224557391-772452008.png" alt="img"></p><p>效果和上面  <code>synchronized</code>  修饰静态方法是一样的，  <code>synchronized</code>  作用于一个类  <code>T</code>  时，是给这个类  <code>T</code>  加锁，  <code>T</code>  的所有对象用的是同一把锁。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h1><p>1、 无论  <code>synchronized</code>  关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果  <code>synchronized</code>  作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。<br>2、每个对象只有一个锁（  <code>lock</code>  ）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。<br>3、实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</p><p>原文链接：<a href="https://www.cnblogs.com/weibanggang/p/9470718.html">Java 中 Synchronized 的用法（简单介绍）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-208-实现Trie(前缀树)</title>
      <link href="/passages/Leetcode-208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91/"/>
      <url>/passages/Leetcode-208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-208-实现-trie-前缀树"><a class="markdownIt-Anchor" href="#leetcode-208-实现-trie-前缀树">#</a> Leetcode 208. 实现 Trie (前缀树)</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code>  初始化前缀树对象。</li><li><code>void insert(String word)</code>  向前缀树中插入字符串 <code> word</code> 。</li><li><code>boolean search(String word) </code>  如果字符串  <code>word</code>  在前缀树中，返回  <code>true</code>  （即，在检索之前已经插入）；否则，返回  <code>false</code>  。</li><li><code>boolean startsWith(String prefix)</code>  如果之前已经插入的字符串  <code>word</code>   的前缀之一为  <code>prefix</code>  ，返回  <code>true</code>  ；否则，返回  <code>false</code> 。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;Trie&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;search&quot;</span>, <span class="string">&quot;search&quot;</span>, <span class="string">&quot;startsWith&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;search&quot;</span>]</span><br><span class="line">[[], [<span class="string">&quot;apple&quot;</span>], [<span class="string">&quot;apple&quot;</span>], [<span class="string">&quot;app&quot;</span>], [<span class="string">&quot;app&quot;</span>], [<span class="string">&quot;app&quot;</span>], [<span class="string">&quot;app&quot;</span>]]</span><br><span class="line">输出</span><br><span class="line">[null, null, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, null, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">trie.<span class="built_in">insert</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">trie.<span class="built_in">search</span>(<span class="string">&quot;apple&quot;</span>);   <span class="comment">// 返回 True</span></span><br><span class="line">trie.<span class="built_in">search</span>(<span class="string">&quot;app&quot;</span>);     <span class="comment">// 返回 False</span></span><br><span class="line">trie.<span class="built_in">startsWith</span>(<span class="string">&quot;app&quot;</span>); <span class="comment">// 返回 True</span></span><br><span class="line">trie.<span class="built_in">insert</span>(<span class="string">&quot;app&quot;</span>);</span><br><span class="line">trie.<span class="built_in">search</span>(<span class="string">&quot;app&quot;</span>);     <span class="comment">// 返回 True</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code>  和  <code>prefix </code>  仅由小写英文字母组成</li><li><code>insert</code>  、 <code>search</code>  和  <code>startsWith</code>  调用次数<strong>总计</strong>不超过  <code>3 * 104 </code>  次</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree">https://leetcode-cn.com/problems/implement-trie-prefix-tree</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2><p>​有百度百科可知（连接已上方给出），字典树是一种树形结构，每个节点只储存一个字符，且为节点不存储字符，我认为它是一种可以按照路径存储字符串的数据结构。</p><p>​现在我们需要将一些单词（只有小写英文字母）存储在字典树里面，我们就在字典树里面的每个节点中创建一个大小为 26 的对象数组  <code>Trie* next[26]</code>  （  <code>该数组中的26个位置分别对应26个小写英文字母</code>  ），同时我们创建一个用来提取字符编号的基准  <code>Base</code>  （  <code>const char Base='a';</code>  ，  <code>编号 = 字符 - Base</code>  ），将计算出的编号作为访问对象数组的索引。</p><p>​当我们向字典树中添加一个单词是，只需要一个字符一层的遍历字典树的节点，如果未找到包含该字符的节点，则新建一个节点并将字符放入；若找到了存放该字符的节点，则指向该节点并继续向下一层字符遍历；直到遍历完该单词的最后一个字母时，将该节点的  <code>isWord</code>  值改为  <code>true</code>  ，标示着这里是一个单词的结尾。</p><p>​当我们在字典树中查找一个单词时，与添加步骤相同，也是一直向下遍历，区别是当遍历时未找到对应的字符时需要返回  <code>false</code>  来表示未找到需要查找的单词；并且在查找到最后一个字符后，返回该字符的  <code>isWord</code>  来表示是否查找成功。</p><p>​当我们在字典树中进行前缀匹配操作时，步骤跟查找一个单词的步骤基本相同，区别就是在查找到最后一个字符后直接返回  <code>true</code>  即可（因为在前缀匹配的条件下，只要找到了最后一个字符，就证明肯定有以该字符串为前缀的单词，这个单词的最小值就是前缀本身）。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> Base=<span class="string">&#x27;a&#x27;</span>; <span class="comment">// 后续作为基准来提取字符的编号（编号 = 字符 - Base）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isWord; <span class="comment">// 作为表示是否为单词结尾的tag</span></span><br><span class="line">    Trie* next[<span class="number">26</span>]; <span class="comment">// 子节点（分别对应26个英文字母，通过Base得到索引来使用）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        isWord = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(next)); <span class="comment">// 初始化数组（内容都为0）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入单词</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c - Base] == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果没有对应的子节点的话，就new一个来用</span></span><br><span class="line">                node-&gt;next[c - Base] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[c - Base]; <span class="comment">// 指向下一个子节点（指向下一个字母）</span></span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isWord = <span class="literal">true</span>; <span class="comment">// 修改tag表示此处是一个单词的结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找单词</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历匹配字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">            <span class="comment">// 向下匹配</span></span><br><span class="line">            node = node-&gt;next[c - Base];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 未匹配到最后一个字符，返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配到了最后一个字符，返回该字符的isWord</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前缀匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 跟查找操作类似，只是不需要判断最后一个字符结点的isWord，因为既然能匹配到最后一个字符，那后面一定有单词是以它为前缀的。（至少是以该字符串为单词）</span></span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : prefix) &#123;</span><br><span class="line">            node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * 您的Trie对象将被实例化并按如下方式调用：</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/01/774864f87352f82c.png" alt=""></p><p><img src="https://s3.bmp.ovh/imgs/2022/01/2b72d6e4e876f9c6.png" alt=""></p><h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2><p>​在本题中，我们需要实现字典树，字典树是一种特殊的树形结构，由于储存的字符只有小写英文字母，所以可以用对象数组  <code>Trie* next[26]</code>  来存储。同时因为一个节点只能存放一个字符，使得我肯可以一个字符一层的去查找，而  <code>isWord</code>  给予了判断该字符是否为一个单词结尾的依据；插入，查找，前缀匹配三个操作都是依托上面所实现的东西来进行的。三种操作的相同点就是都要进行多次按照字符的遍历，不同点在于对于未找到对应字符的处理以及相同情况下的返回值不同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-133-克隆图</title>
      <link href="/passages/Leetcode-133-%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
      <url>/passages/Leetcode-133-%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-133克隆图"><a class="markdownIt-Anchor" href="#leetcode-133克隆图">#</a> Leetcode 133. 克隆图</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>给你无向<a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin">连通</a>图中一个节点的引用，请你返回该图的<a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a>（克隆）。</p><p>图中的每个节点都包含它的值  <code>val</code> （ <code>int</code> ） 和其邻居的列表（ <code>list[Node]</code> ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（ <code>val = 1</code> ），第二个节点值为 2（ <code>val = 2</code> ），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">解释：</span><br><span class="line">图中有 <span class="number">4</span> 个节点。</span><br><span class="line">节点 <span class="number">1</span> 的值是 <span class="number">1</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">2</span> 的值是 <span class="number">2</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br><span class="line">节点 <span class="number">3</span> 的值是 <span class="number">3</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">4</span> 的值是 <span class="number">4</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 <span class="number">1</span> 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p>示例 4：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[<span class="number">2</span>],[<span class="number">1</span>]]</span><br><span class="line">输出：[[<span class="number">2</span>],[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>提示：</p><ol><li>节点数不超过 100 。</li><li>每个节点值  <code>Node.val</code>  都是唯一的， <code>1 &lt;= Node.val &lt;= 100</code> 。</li><li>无向图是一个<a href="https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%9B%BE/1680528?fr=aladdin">简单图</a>，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 <code>p</code>  是节点 <code>q</code>  的邻居，那么节点  <code>q </code> 也必须是节点  <code>p </code> 的邻居。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/clone-graph">https://leetcode-cn.com/problems/clone-graph</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2><p>​对一个图进行深拷贝时，我们可以对它进行遍历，并在遍历时进行拷贝，最后得到该图的深拷贝结果。</p><p>​通过一个节点遍历一个连通图的有效方法为<a href="https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2?fromtitle=%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86&amp;fromid=9796166">深度优先遍历 (DFS)</a> 和<a href="https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2?fromtitle=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86&amp;fromid=9796192">广度优先遍历 (BFS)</a>。(层序遍历不适合无向图)</p><p>​我们知道，无向图中，若 A、B 两点相连，则可以从 A 连接 B 也可以从 B 连接 A，这一点使得我们在使用深度优先遍历和广度优先遍历克隆 (深拷贝) 一个无向图时需要对结点进行标记，来代表它们是否已经被克隆过。</p><p>​关于这一点的解决，最开始时想对每一个节点加一个 <code>tag</code>  来表示是否已经克隆过，后来发现不太行；之后也尝试了使用队列、栈和列表来实现 <code>tag</code> ，也没有达到想要的效果，最后选取了 ** <code>哈希表HashMap</code> ** 来实现对克隆的记录。</p><p>​在 HashMap 中， <code>key</code> / <code>value</code>  分别为 <strong> <code>原始图节点</code>  / <code>克隆图节点</code> </strong>，这样表示比较清晰且便于查找 (也做过储存节点值 / 克隆图节点，但不如上文方法清晰)。我们从给定节点开始对图进行遍历。如果某个节点已经被访问过，则返回其克隆图中的对应节点 (查找 HashMap)。如果当前访问的节点不在哈希表中，则创建它的克隆节点并存储在哈希表中。<strong>注意：<strong>在需要递归的时候，克隆节点并保存在哈希表中的操作</strong>需要放在进入递归之前</strong>，不然有可能在递归中遇到相同的节点，陷入死循环 (再次遍历此节点)。</p><p>​<strong>递归操作：<strong>在递归时，会递归每个节点的邻接点，递归次数由邻接点数量决定，每一次都返回对应邻接点的克隆节点 (注意：克隆前需要先</strong>判断该点是否已经被克隆过</strong>)，最后返回这些克隆节点的列表，放入对应克隆节点的邻接表中，这样就可以克隆给定的节点和其邻接点。</p><h3 id="1深度优先遍历递归"><a class="markdownIt-Anchor" href="#1深度优先遍历递归">#</a> 1. 深度优先遍历（递归）</h3><p>​通过递归实现深度优先遍历，在遍历的中间对节点进行克隆并将克隆节点保存在哈希表中（<strong>注意克隆保存和进入递归的先后</strong>）</p><h3 id="2广度优先遍历栈"><a class="markdownIt-Anchor" href="#2广度优先遍历栈">#</a> 2. 广度优先遍历（栈）</h3><p>​用栈实现广度优先遍历，这种做法不需要递归，但仍需要在遍历的中间对节点进行克隆并将克隆节点保存在哈希表中</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2><h3 id="1深度优先遍历递归-2"><a class="markdownIt-Anchor" href="#1深度优先遍历递归-2">#</a> 1. 深度优先遍历（递归）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义一个哈希表来记录访问过的节点以及克隆过的节点</span></span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果为空</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">find</span>(node) != visited.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> visited[node];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 新建克隆节点并储存</span></span><br><span class="line">        Node* cloneNode = <span class="keyword">new</span> <span class="built_in">Node</span>(node -&gt; val);</span><br><span class="line">        visited[node] = cloneNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor : node -&gt; neighbors) </span><br><span class="line">            cloneNode -&gt; neighbors.<span class="built_in">push_back</span>(<span class="built_in">cloneGraph</span>(neighbor));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="ac截图"><a class="markdownIt-Anchor" href="#ac截图">#</a> AC 截图：</h5><p><img src="https://s3.bmp.ovh/imgs/2022/01/585d97e015a7a791.png" alt=""></p><p><img src="https://s3.bmp.ovh/imgs/2022/01/e1246a181a6aed25.png" alt=""></p><h3 id="2广度优先遍历栈-2"><a class="markdownIt-Anchor" href="#2广度优先遍历栈-2">#</a> 2. 广度优先遍历（栈）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果为空</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 新建克隆节点并储存</span></span><br><span class="line">        Node* cloneNode = <span class="keyword">new</span> <span class="built_in">Node</span>(node -&gt; val);</span><br><span class="line">        visited[node] = cloneNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建队列</span></span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="comment">// 节点入队</span></span><br><span class="line">        que.<span class="built_in">push</span>(node);</span><br><span class="line">        <span class="comment">// 如果队列不为空</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取队首并出栈</span></span><br><span class="line">            Node* temp = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor : temp -&gt; neighbors)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited.<span class="built_in">find</span>(neighbor) == visited.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 新建克隆节点并入栈</span></span><br><span class="line">                    visited[neighbor] = <span class="keyword">new</span> <span class="built_in">Node</span>(neighbor -&gt; val);</span><br><span class="line">                    que.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新克隆节点的邻居列表（在哈希表中找到该克隆节点并更新克隆节点的邻居列表）</span></span><br><span class="line">                visited[temp] -&gt; neighbors.<span class="built_in">push_back</span>(visited[neighbor]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="ac截图-2"><a class="markdownIt-Anchor" href="#ac截图-2">#</a> AC 截图：</h5><p><img src="https://s3.bmp.ovh/imgs/2022/01/585d97e015a7a791.png" alt=""></p><p><img src="https://s3.bmp.ovh/imgs/2022/01/01cedf0345728be0.png" alt=""></p><h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2><p>​做完这个题之后，我感觉主要思路就是对该图进行遍历并同时深拷贝，无论哪种遍历方法都需要给节点打上 tag 来标志该节点是否被克隆过（通过哈希表实现）。在深度优先遍历中使用递归时需要注意操作的先后顺序（克隆保存和进入递归的先后），否则会陷入死循环；广度优先遍历则不需要担心这一点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法</title>
      <link href="/passages/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/passages/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="acwing-785-快速排序"><a class="markdownIt-Anchor" href="#acwing-785-快速排序">#</a> AcWing 785. 快速排序</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>给定你一个长度为 n 的整数数列。</p><p>请你使用快速排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤n≤100000</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2><h4 id="题意理解"><a class="markdownIt-Anchor" href="#题意理解">#</a> 题意理解</h4><p>这道题目显然是要我们将一个无序数列排序，成为具有升序性质的升序序列.</p><h4 id="算法处理"><a class="markdownIt-Anchor" href="#算法处理">#</a> 算法处理</h4><p>一道排序题目，数据范围是关键，我们发现这道题目只能让我们使用 O (nlogn) 的算法，显然我们可以选择快速排序，归并排序等算法，这里我们就使用快速排序.</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2><h4 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 如果没有数据或者只有一个数字的话，则不用排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = q[(l + r) / <span class="number">2</span>],i = l - <span class="number">1</span>, j = r + <span class="number">1</span>; <span class="comment">// 确定分界点和指针</span></span><br><span class="line">    <span class="comment">// 注意：分界点有四种取法，这里取的是中间的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123; <span class="comment">// i和j未相遇时，一直循环</span></span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x); <span class="comment">// 寻找</span></span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x); <span class="comment">// 寻找</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i],q[j]); <span class="comment">// 未相遇则交换，相遇了就不交换</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继续对整理出的两段数据进行排序</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j); </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span> ,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java"><a class="markdownIt-Anchor" href="#java">#</a> Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> 基础算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick_Sort</span> </span>&#123; <span class="comment">// 快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> N = (<span class="keyword">int</span>) (<span class="number">1e6</span> +<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n; <span class="comment">// 要排序的整数的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] p = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 如果没有数据或者只有一个数字的话，则不用排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = p[(l + r)/<span class="number">2</span>],i = l - <span class="number">1</span>,j = r + <span class="number">1</span>;<span class="comment">// 确定分界点和指针</span></span><br><span class="line">        <span class="comment">// 注意：分界点有四种取法，这里取的是中间的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123; <span class="comment">// i和j未相遇时，一直循环</span></span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span>(p[i] &lt; x); <span class="comment">// 寻找</span></span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span>(p[j] &gt; x); <span class="comment">// 寻找</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) &#123; <span class="comment">// 指针未相遇则交换，相遇了就不交换</span></span><br><span class="line">                <span class="keyword">int</span> t = p[i];</span><br><span class="line">                p[i] = p[j];</span><br><span class="line">                p[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quick_sort(p,l,j); <span class="comment">// 递归处理左半边</span></span><br><span class="line">        quick_sort(p,j+<span class="number">1</span>,r); <span class="comment">// 递归处理右半边</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            p[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quick_sort(p,<span class="number">0</span>,n-<span class="number">1</span>); <span class="comment">// 快排</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            System.out.println(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="acwing-787-归并排序"><a class="markdownIt-Anchor" href="#acwing-787-归并排序">#</a> AcWing 787. 归并排序</h1><h2 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2">#</a> 题目描述</h2><p>给定你一个长度为 n 的整数数列。</p><p>请你使用归并排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><h4 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h4><p>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。</p><h4 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h4><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><h4 id="数据范围-2"><a class="markdownIt-Anchor" href="#数据范围-2">#</a> 数据范围</h4><p>1≤n≤100000</p><h4 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例-2"><a class="markdownIt-Anchor" href="#输出样例-2">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h2 id="解题思路-2"><a class="markdownIt-Anchor" href="#解题思路-2">#</a> 解题思路</h2><h4 id="题意理解-2"><a class="markdownIt-Anchor" href="#题意理解-2">#</a> 题意理解</h4><p>这道题目还是让我们排序，只不过这里强制要求我们使用归并排序，所以既然如此的话，让我们好好地康康这道题目.</p><h4 id="算法处理-2"><a class="markdownIt-Anchor" href="#算法处理-2">#</a> 算法处理</h4><p>归并排序，它有两大核心操作.</p><p>一个是将数组一分为二，一个无序的数组成为两个数组.</p><p>另外一个操作就是，合二为一，将两个有序数组合并成为一个有序数组.</p><p><img src="https://cdn.acwing.com/media/article/image/2019/05/19/1130_4cf170747a-3.gif" alt=""></p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2">#</a> 代码实现</h2><h4 id="c-2"><a class="markdownIt-Anchor" href="#c-2">#</a> C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 要排序的整数的个数</span></span><br><span class="line"><span class="keyword">int</span> q[N],tmp[N]; <span class="comment">// 排序的数组和功能数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 归并排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">// 选取中间点，相当于 int mid = (l+r) / 2;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid); <span class="comment">// 对左半部分进行递归</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r); <span class="comment">// 对右半部分进行递归</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,i = l,j = mid+<span class="number">1</span>; <span class="comment">// 设置递归左右两边区域时使用的三个指针</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) <span class="comment">// 左右两边都没遍历完的时候</span></span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++]; <span class="comment">// 后指针指的数字更小的话，将后指针所指数字放入功能数组并指向下一位</span></span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++]; <span class="comment">// 前指针指的数字更小的话，将前指针所指数字放入功能数组并指向下一位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将未遍历完的部分放入功能数组</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++]; <span class="comment">// 将前半部分未遍历完的部分放入功能数组</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k++] = q[j++]; <span class="comment">// 将后半部分未遍历完的部分放入功能数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) q[i] = tmp[j]; <span class="comment">// 将功能数组中排好序的数字复制到原始数组中</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java-2"><a class="markdownIt-Anchor" href="#java-2">#</a> Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 基础算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge_Sort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> N = (<span class="keyword">int</span>) (<span class="number">1e6</span> +<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n; <span class="comment">// 要排序的整数的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] p = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">// 选取中间点，相当于 int mid = (l+r) / 2;</span></span><br><span class="line"></span><br><span class="line">        merge_sort(p,l,mid); <span class="comment">// 对左半部分进行递归</span></span><br><span class="line">        merge_sort(p,mid+<span class="number">1</span>,r); <span class="comment">// 对右半部分进行递归</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>,i = l,j = mid+<span class="number">1</span>; <span class="comment">// 设置递归左右两边区域时使用的三个指针  // 这句易错</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) <span class="comment">// 左右两边都没遍历完的时候</span></span><br><span class="line">            <span class="keyword">if</span>(p[i] &lt;= p[j]) tmp[k++] = p[i++]; <span class="comment">// 后指针指的数字更小的话，将后指针所指数字放入功能数组并指向下一位</span></span><br><span class="line">            <span class="keyword">else</span> tmp[k++] = p[j++]; <span class="comment">// 前指针指的数字更小的话，将前指针所指数字放入功能数组并指向下一位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将未遍历完的部分放入功能数组</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = p[i++]; <span class="comment">// 将前半部分未遍历完的部分放入功能数组</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) tmp[k++] = p[j++]; <span class="comment">// 将后半部分未遍历完的部分放入功能数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) p[i] = tmp[j]; <span class="comment">// 将功能数组中排好序的数字复制到原始数组中</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            p[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        merge_sort(p,<span class="number">0</span>,n-<span class="number">1</span>); <span class="comment">// 快排</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            System.out.println(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="acwing-789-数的范围二分"><a class="markdownIt-Anchor" href="#acwing-789-数的范围二分">#</a> AcWing 789. 数的范围（二分）</h1><h2 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3">#</a> 题目描述</h2><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p><p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 00 开始计数）。</p><p>如果数组中不存在该元素，则返回  <code>-1 -1</code> 。</p><h4 id="输入格式-3"><a class="markdownIt-Anchor" href="#输入格式-3">#</a> 输入格式</h4><p>第一行包含整数 n 和 q，表示数组长度和询问个数。</p><p>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。</p><p>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p><h4 id="输出格式-3"><a class="markdownIt-Anchor" href="#输出格式-3">#</a> 输出格式</h4><p>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回  <code>-1 -1</code> 。</p><h4 id="数据范围-3"><a class="markdownIt-Anchor" href="#数据范围-3">#</a> 数据范围</h4><p>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000</p><h4 id="输入样例-3"><a class="markdownIt-Anchor" href="#输入样例-3">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="输出样例-3"><a class="markdownIt-Anchor" href="#输出样例-3">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><h2 id="解题思路-3"><a class="markdownIt-Anchor" href="#解题思路-3">#</a> 解题思路</h2><h4 id="整数二分"><a class="markdownIt-Anchor" href="#整数二分">#</a> 整数二分</h4><p>二分的本质是二段性不是单调性。</p><p>当想找不满足性质的边界值（红色区域的右边界值）</p><p><img src="https://gitee.com/adameta/img/raw/master/1580979705_20200206160241434_9286.png" alt=""></p><p>找中间值  <code>mid = (l+r+1)/2</code> <br>if (check (mid)) 等于 true 或者是 false<br>check (m) 是检查 m 是在<strong>不满足性质的区间</strong>（检查是不是在红色区间）<br>更新 l 或者 r</p><p><img src="https://gitee.com/adameta/img/raw/master/1580979706_20200206161754906_7010.png" alt=""></p><p>当想找满足性质的边界值（绿色区域的左边界值）</p><ol><li>找中间值  <code>mid = (l+r)/2</code></li><li>if (check (mid)) 等于 true 或者是 false<br>check (m) 是检查 m 是在<strong>满足性质的区间</strong>（检查是不是在绿色区间）</li><li>更新 l 或者 r</li></ol><p><img src="https://gitee.com/adameta/img/raw/master/1580979706_20200206163113295_29079.png" alt=""></p><p>归结上面的两种二分方法，步骤为：</p><ol><li>先写一个 check 函数</li><li>判定在 check 的情况下（true 和 false 的情况下），如何更新区间。</li><li>在 check (m)==true 的分支下是:<ol><li><code>l=mid</code>  的情况，中间点的更新方式是 <code>m=(l+r+1)/2</code></li><li><code>r=mid</code>  的情况，中间点的更新方式是 <code>m=(l+r)/2</code></li></ol></li></ol><p>这种方法保证了：</p><ol><li>最后的 <code>l==r</code></li><li>搜索到达的答案是闭区间的，即 a [l] 是满足 check () 条件的。</li></ol><h2 id="代码实现-3"><a class="markdownIt-Anchor" href="#代码实现-3">#</a> 代码实现</h2><h4 id="java-3"><a class="markdownIt-Anchor" href="#java-3">#</a> Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> N = (<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt(); <span class="comment">// 读入数组长度</span></span><br><span class="line">        m = in.nextInt(); <span class="comment">// 读入询问个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;n;i++) q[i] = in.nextInt(); <span class="comment">// 读入数组数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(m-- &gt; <span class="number">0</span>) &#123; <span class="comment">// 询问个数大于0（还未询问完）</span></span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            x = in.nextInt(); <span class="comment">// 读入要询问的数字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>; <span class="comment">// 选取左右指针(数组的左右两边)</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 当指针未相遇时(未找到想找到的边界时)</span></span><br><span class="line">                <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// mid = l // 定义中间量 用于检查数据和更新指针</span></span><br><span class="line">                <span class="keyword">if</span> (q[mid] &gt;= x) r = mid; <span class="comment">// 更新右指针</span></span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>; <span class="comment">// 更新左指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q[l] != x) System.out.println(<span class="string">&quot;-1 -1&quot;</span>); <span class="comment">// 未找到想要的边界(未找到想要的数字(找到的位置上的数字不是我们想要的))</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(l + <span class="string">&quot; &quot;</span>); <span class="comment">// 输出我们想要的左边界(查询的数字第一次出现的位置)</span></span><br><span class="line">                l = <span class="number">0</span>;r = n - <span class="number">1</span>; <span class="comment">// 重新选取选取左右指针(数组的左右两边)</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// // 当指针未相遇时(未找到想找到的边界时)</span></span><br><span class="line">                    <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; <span class="comment">// mid = r // 重新定义中间量 用于检查数据和更新指针</span></span><br><span class="line">                    <span class="keyword">if</span> (q[mid] &lt;= x) l = mid; <span class="comment">// 更新左指针</span></span><br><span class="line">                    <span class="keyword">else</span> r = mid - <span class="number">1</span>; <span class="comment">// 更新右指针</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(l); <span class="comment">// 输出我们想要的右边界(查询的数字最后一次出现的位置)</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c-3"><a class="markdownIt-Anchor" href="#c-3">#</a> C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--) &#123; <span class="comment">// 询问个数大于0（还未查询完）</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); <span class="comment">// 读入要查询的数字</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>; <span class="comment">// 选取左右指针（数组的左右两边）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确定左边界（第一次出现的位置）</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123; <span class="comment">// 当指针未相遇时(未找到想找到的边界时)）</span></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">// mid = l // 定义中间量 用于检查数据和更新指针</span></span><br><span class="line">            <span class="keyword">if</span>(q[mid] &gt;= x) r = mid; <span class="comment">// 更新右指针</span></span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>; <span class="comment">// 更新左指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q[l] != x) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl; <span class="comment">// 未找到想要的边界(未找到想要的数字(找到的位置上的数字不是我们想要的))</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> ; <span class="comment">// 输出我们想要的左边界(查询的数字第一次出现的位置)</span></span><br><span class="line">            l = <span class="number">0</span>,r = n<span class="number">-1</span>; <span class="comment">// 重新选取选取左右指针(数组的左右两边)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 确定左边界（第一次出现的位置）</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt; r) &#123; <span class="comment">// 当指针未相遇时(未找到想找到的边界时)</span></span><br><span class="line">                <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// mid = r // 重新定义中间量 用于检查数据和更新指针</span></span><br><span class="line">                <span class="keyword">if</span>(q[mid] &lt;= x) l = mid; <span class="comment">// 更新左指针</span></span><br><span class="line">                <span class="keyword">else</span> r = mid<span class="number">-1</span>; <span class="comment">// 更新右指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl; <span class="comment">// 输出我们想要的右边界(查询的数字最后一次出现的位置)</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="acwing-790-数的三次方根二分"><a class="markdownIt-Anchor" href="#acwing-790-数的三次方根二分">#</a> AcWing 790. 数的三次方根（二分）</h1><h2 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4">#</a> 题目描述</h2><p>给定一个浮点数 n，求它的三次方根。</p><h4 id="输入格式-4"><a class="markdownIt-Anchor" href="#输入格式-4">#</a> 输入格式</h4><p>共一行，包含一个浮点数 n。</p><h4 id="输出格式-4"><a class="markdownIt-Anchor" href="#输出格式-4">#</a> 输出格式</h4><p>共一行，包含一个浮点数，表示问题的解。</p><p>注意，结果保留 6 位小数。</p><h4 id="数据范围-4"><a class="markdownIt-Anchor" href="#数据范围-4">#</a> 数据范围</h4><p>−10000≤n≤10000</p><h4 id="输入样例-4"><a class="markdownIt-Anchor" href="#输入样例-4">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000.00</span><br></pre></td></tr></table></figure><h4 id="输出样例-4"><a class="markdownIt-Anchor" href="#输出样例-4">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.000000</span><br></pre></td></tr></table></figure><h2 id="解题思路-4"><a class="markdownIt-Anchor" href="#解题思路-4">#</a> 解题思路</h2><p>学会整数二分后，相信这个大家有手就行。</p><h2 id="代码实现-4"><a class="markdownIt-Anchor" href="#代码实现-4">#</a> 代码实现</h2><h4 id="c-4"><a class="markdownIt-Anchor" href="#c-4">#</a> C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; x; <span class="comment">// 读入数据</span></span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-10000</span>,r = <span class="number">10000</span>; <span class="comment">// 设定范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>) &#123; <span class="comment">// 是否找到</span></span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">// 中间值</span></span><br><span class="line">        <span class="keyword">if</span>(mid*mid*mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,l); <span class="comment">// %lf默认保留六位小数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java-4"><a class="markdownIt-Anchor" href="#java-4">#</a> Java</h4><p><strong><a href="https://cloud.tencent.com/developer/article/1607231">JAVA 字符串格式化 ——String.format () 的使用</a></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        x = in.nextDouble(); <span class="comment">// 读入数据</span></span><br><span class="line">        <span class="keyword">double</span> l = -<span class="number">10000</span>,r = <span class="number">10000</span>; <span class="comment">// 设定范围</span></span><br><span class="line">        <span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>) &#123; <span class="comment">// 是否找到</span></span><br><span class="line">            <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">// 中间值</span></span><br><span class="line">            <span class="keyword">if</span>(mid*mid*mid &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%.6f&quot;</span>, l)); <span class="comment">// 保留六位小数</span></span><br><span class="line">        <span class="comment">// System.out.printf(&quot;%.6f&quot;,l); // 作用相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="acwing-791-高精度加法"><a class="markdownIt-Anchor" href="#acwing-791-高精度加法">#</a> AcWing 791. 高精度加法</h1><h2 id="题目描述-5"><a class="markdownIt-Anchor" href="#题目描述-5">#</a> 题目描述</h2><p>给定两个正整数（不含前导 00），计算它们的和。</p><h4 id="输入格式-5"><a class="markdownIt-Anchor" href="#输入格式-5">#</a> 输入格式</h4><p>共两行，每行包含一个整数。</p><h4 id="输出格式-5"><a class="markdownIt-Anchor" href="#输出格式-5">#</a> 输出格式</h4><p>共一行，包含所求的和。</p><h4 id="数据范围-5"><a class="markdownIt-Anchor" href="#数据范围-5">#</a> 数据范围</h4><p>1≤整数长度≤1000001≤整数长度≤100000</p><h4 id="输入样例-5"><a class="markdownIt-Anchor" href="#输入样例-5">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">23</span><br></pre></td></tr></table></figure><h4 id="输出样例-5"><a class="markdownIt-Anchor" href="#输出样例-5">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure><h2 id="解题思路-5"><a class="markdownIt-Anchor" href="#解题思路-5">#</a> 解题思路</h2><ol><li><p>因为是长整数的加法运算，普通的数据类型无法存放，所以选择了 vector（也因为有  <code>.size</code>  这个函数才采用它）。</p></li><li><p>过长的数据使我选择了字符串来读入，用循环放入 vector 即可（将数字低位在前高位在后的放入）。</p></li><li><p>在循环中通过算子 <code>t</code>  来进行每一位的运算，并将下一次运算的进位算出： <code>t /= 10;</code> （参与下一位数的运算），剩余部分写入结果中： <code>C.push_back(t%10);</code> 。</p></li><li><p>循环结束（各位的运算完成）后，如果最高位时 0，则需要进一位： <code>C.push_back(1);</code></p></li></ol><h2 id="代码实现-5"><a class="markdownIt-Anchor" href="#代码实现-5">#</a> 代码实现</h2><h4 id="c-5"><a class="markdownIt-Anchor" href="#c-5">#</a> C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A,vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123; <span class="comment">// 使用引用传参，就不用再复制一遍了</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C; <span class="comment">// 储存结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 运算的算子以及进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>();i++) &#123; <span class="comment">// 加法运算，A或B未读完时，加法继续</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i]; <span class="comment">// 从个位数开始加，一次循环加一位</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i]; <span class="comment">// 从个位数开始加，一次循环加一位</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>); <span class="comment">// 排除t中需要进位的部分并将剩下的放在C里面</span></span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">// 下一次运算时的进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 运算后最高位是0，则进1</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// 使用字符串读入数据</span></span><br><span class="line">    <span class="comment">// 在下面一步时，注意字符串的末尾有&#x27;0&#x27;，所以有 size() - 1 </span></span><br><span class="line">    <span class="comment">// 而 a[i] - &#x27;0&#x27; 是为了拿到数据(eg: &#x27;2&#x27; - &#x27;0&#x27; = 0)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 将数据放入vector中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 将数据放入vector中</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C = <span class="built_in">add</span>(A,B); <span class="comment">// 进行加法运算并将结果放入C中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在下面这一步时，要注意size() - 1,不然的话结果前面会多一个0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]); <span class="comment">// 输出结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="acwing-792-高精度减法"><a class="markdownIt-Anchor" href="#acwing-792-高精度减法">#</a> AcWing 792. 高精度减法</h1><h2 id="题目描述-6"><a class="markdownIt-Anchor" href="#题目描述-6">#</a> 题目描述</h2><p>给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。</p><h4 id="输入格式-6"><a class="markdownIt-Anchor" href="#输入格式-6">#</a> 输入格式</h4><p>共两行，每行包含一个整数。</p><h4 id="输出格式-6"><a class="markdownIt-Anchor" href="#输出格式-6">#</a> 输出格式</h4><p>共一行，包含所求的差。</p><h4 id="数据范围-6"><a class="markdownIt-Anchor" href="#数据范围-6">#</a> 数据范围</h4><p>1≤整数长度≤105</p><h4 id="输入样例-6"><a class="markdownIt-Anchor" href="#输入样例-6">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h4 id="输出样例-6"><a class="markdownIt-Anchor" href="#输出样例-6">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><h2 id="解题思路-6"><a class="markdownIt-Anchor" href="#解题思路-6">#</a> 解题思路</h2><p>判断需要相减的两个数的大小，然后进行逐位相减。</p><h2 id="代码实现-6"><a class="markdownIt-Anchor" href="#代码实现-6">#</a> 代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A - B 是否大于0</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>(); <span class="comment">// 先看长度，长度长的大</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="comment">// 从个位开始比较，相同跳过这位数，不相同返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 都相同，返回true(此时A - B = 0)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法运算</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="comment">// 从个位开始逐位相减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t; <span class="comment">// 减去上一次的借位</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i]; <span class="comment">// 由于A&gt;B,i有可能超出B的位数，需要验证</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>); <span class="comment">// 添加结果(包含t&gt;0与t&lt;0的情况) --&gt; t&gt;0: t%10,  t&lt;0: (t + 10) % 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算借位</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 消除结果前的0(eg: 111-110=001 , 需要去除两个数字 0 使结果变成 1 )</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// 读入数据为字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 转换成数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 转换成数字</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C; <span class="comment">// 定义结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// A &gt; B 时,sub(A, B),否则 sub(B, A),并输出一个&#x27;-&#x27;号</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B)) C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">    <span class="keyword">else</span> C = <span class="built_in">sub</span>(B, A), cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写在后面"><a class="markdownIt-Anchor" href="#写在后面">#</a> 写在后面</h1><p>暂时先写这么多，学了其他的继续写（~~ 菜鸡嘤嘤</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言快速入门</title>
      <link href="/passages/C%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/passages/C%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a class="markdownIt-Anchor" href="#序言">#</a> 序言</h1><p>​        C 语言是一种面向过程的计算机编程语言，多用于嵌入式开发（电路硬件编程）与系统底层编写， 比如我们常用的 Linux 系统，Windows 系统就是主要由 C 语言编写的。同时 c 语言也是最早出现的编程语 言之一，最早在 1972 年就已经被使用，并且直到现在它也是使用率最多的编程语言之一。</p><h2 id="计算机的内存"><a class="markdownIt-Anchor" href="#计算机的内存">#</a> 计算机的内存</h2><p>代码本身存储在计算机的硬盘里，不管计算机开机还是关机，你写的程序的代码都是存在的，但是 一个程序要想运行起来就需要运行在计算机的内存里。</p><p>可以将计算机的内存想象成一个大的空间，这个空间中有各种各样的程序在运行着，并且每个程序 都会占用一定的空间，而所占空间的大小由程序本身所有的一些变量，函数等决定。</p><h2 id="什么是编译器"><a class="markdownIt-Anchor" href="#什么是编译器">#</a> 什么是编译器</h2><p>我们的计算机只能够识别由 0 和 1 的二进制码，因此我们写出来的代码要想运行起来必须经过软件的 编译，将英文的编程语句转换为电脑能够识别的二进制码，不论哪种编程语言，最终都会经过编译转换 为计算机可识别的二进制码。** 将代码转换为二进制机器码的过程就叫做编译，负责进行转换的程序叫做 编译器。** 例如 gcc 编译器 等</p><h2 id="ide集成开发环境是什么"><a class="markdownIt-Anchor" href="#ide集成开发环境是什么">#</a> IDE (集成开发环境) 是什么</h2><p>​        IDE 是 Intergreated Development Environment 的缩写，中文称为集成开发环境，是指辅助程序 员开发的应用软件。</p><p>​        我们已经知道，想要运行一个 C 语言程序必须有编译器，但是在实际开发过程中，除运行程序必须 的编译器之外，我们往往还需要很多其他的辅助工具，比如 语言编辑器、自动建立工具、除错器等等 。这些被打包在一起成为一个开发软件， 统一发布和安装，统称为集成开发环境（IDE）。比如我们使 用的 VS2010，devc++，CLion 等都是 IDE。</p><p><strong>IDE 与编译器的区别</strong></p><p>​       IDE 是编译器与其它各种开发工具的集合体。</p><p><strong>面向过程思想</strong></p><p>​面向过程是一种以过程为中心的编程思想，其原理就是将问题分解成一个一个详细的步骤，然后通 过函数实现每一个步骤，并依次调用。 面向过程我们所关心的是解决一个问题的步骤，举个例子，汽车发动、汽车熄火，这是两个不同 的事件，对于面向过程而言，我们关心的是事件本身，因此我们会使用两个函数完成以上两个动作，然 后依次调用即可。</p><p>​再比如 进入游戏，开始游戏，游戏结算，这是三个不同的事件，我们在玩游戏时只会关注这三个事 件，我们可以使用函数来表示这三个不同的动作，依次调用。</p><p>计算机基本快捷键的使用</p><ol><li>ctrl + 空格 /ctrl+shift : 快速切换中英文输入法</li><li>Ctrl-X：剪切所选项并拷贝到剪贴板。</li><li>Ctrl-C：将所选项拷贝到剪贴板。</li><li>Ctrl-V：将剪贴板的内容粘贴到当前文稿或应用中。</li><li>Ctrl-Z：撤销上一个命令。</li><li>Ctrl-A：全选各项。</li><li>Ctrl-S: 保存当前文件</li><li>Ctrl-F：查找文稿中的项目或打开 “查找” 窗口。</li><li>win+R: 唤起 “运行” 对话框，快速运行特定程序</li><li>win+X: 唤起系统菜单</li></ol><h2 id="第一个程序hello-world"><a class="markdownIt-Anchor" href="#第一个程序hello-world">#</a> 第一个程序（Hello World!)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 我的第一个 C 程序 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World! \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序解析"><a class="markdownIt-Anchor" href="#程序解析">#</a> 程序解析</h2><p>一个最基础的 C 语言程序由 <strong>预处理器指令，函数，变量，语句和表达式 以及 注释</strong>组成</p><p>接下来我们讲解一下上面这段程序：</p><ol><li>程序的第一行 <strong>#include</strong> 是预处理器指令，告诉 C 编译器在实际编译之前要包含<strong> stdio.h</strong> 文 件，可以将头文件理解为一个工具箱，在我们开始工作前，需要先拿好工具箱才能开始我们的 工作。</li><li>下一行<strong> int main ()</strong> 是主函数，程序从这里开始执行。</li><li>下一行 <strong>/<em>…</em>/</strong> 将会被编译器忽略，不会执行，这里放置程序的注释内容。它们用来告诉读者 这个程序或者这些代码要做什么。</li><li>下一行 **printf (…)** 是 C 中另一个可用的函数，会在屏幕上显示消息 “Hello, World!”。</li><li>下一行 <strong>return 0;</strong> 终止 main () 函数，并返回值 0，表示程序完整地结束。</li></ol><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法">#</a> 基本语法</h1><p>​分号：在 c 语言中，每个语句之后必须跟一个 <strong>英文分号</strong>表示一个语句的结束</p><p>​注释：C 语言有两种注释方式，分别是 <strong>//<strong> 和</strong>上文那种</strong>，// 是单行注释，只会将一行标注为注释，而<strong>上文那种</strong>是多行注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释 //</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​<strong>标识符:</strong></p><p>​C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 语言是<strong>区分大小写</strong>的编程语言。因此，在 C 中， Manpower 和 manpower 是两个不同的标识符。</p><h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型">#</a> 数据类型</h1><h2 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型">#</a> 基本类型</h2><h3 id="int整型"><a class="markdownIt-Anchor" href="#int整型">#</a> <strong>int（整型）</strong></h3><p>​可以用来声明一个整数变量</p><h3 id="short短字节类型"><a class="markdownIt-Anchor" href="#short短字节类型">#</a> <strong>short（短字节类型）</strong></h3><p>​可以用来声明短整形（节约内存）</p><h3 id="long-int长字节类型"><a class="markdownIt-Anchor" href="#long-int长字节类型">#</a> <strong>long int（长字节类型）</strong></h3><p>​当数据的大小超出 int 类型的上限时，可以使用 long int 甚至是 long long int 来扩大取值范围</p><h3 id="double和float浮点类型"><a class="markdownIt-Anchor" href="#double和float浮点类型">#</a> <strong>double 和 float（浮点类型）</strong></h3><p>​double 和 float 用来表示浮点数（小数）</p><p>​区别：</p><p>​ double 可以存储到小数点后 15 位，float 可以存储到小数点后 6 位</p><h3 id="char字符类型"><a class="markdownIt-Anchor" href="#char字符类型">#</a> <strong>char（字符类型）</strong></h3><p>​char 是最小的基本类型，只占 1 个字节的存储空间，主要用来表示字符，例如‘a’,‘b’,‘c’,‘d’等。</p><p>​ 值得注意的是，<strong>char 类型的‘1’和 int 类型的 1 是不一样的</strong>，在实际编写代码时需要注意。</p><h3 id="unsigned无符号修饰符"><a class="markdownIt-Anchor" href="#unsigned无符号修饰符">#</a> <strong>unsigned（无符号）修饰符</strong></h3><p>​unsigned 可以用来修饰前面的数据类型，例如 unsigned int,unsigned char,unsigned double 等， 被 unsigned 修饰的数据类型其所占的存储空间大小不变，但是最大值会扩大为原来的 2 倍，最小值变为 0. 也就是说，一个数据类型被 unsigned 修饰以后，这个数据类型将变为无符号类型，也就是其不再有负 数值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">20201022</span>;</span><br><span class="line"><span class="keyword">int</span> year = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">short</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> num = <span class="number">1234567890</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> weight = <span class="number">188.5326</span>;</span><br><span class="line"><span class="keyword">float</span> high = <span class="number">100.25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> a=<span class="number">32767</span>,b=a+<span class="number">1</span>;<span class="comment">//定义短整型无符号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%u\nb=%u\n&quot;</span>,a,b);<span class="comment">//以无符号输出</span></span><br></pre></td></tr></table></figure><p>​<strong>相对于 unsigned，还有一个 signed 修饰符，signed 是有符号修饰符，但是我们一般省略他，c 语 言默认的数据类型都是有符号的</strong></p><table><thead><tr><th>类型</th><th>储存空间大小</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>char</td><td>（与 signed char 或 unsigned char 相同）</td><td>（与 signed char 或 unsigned char 相同）</td><td>（与 signed char 或 unsigned char 相同）</td></tr><tr><td>unsigned char</td><td>1 个字节</td><td>0</td><td>255</td></tr><tr><td>signed char</td><td>1 个字节</td><td>-128</td><td>127</td></tr><tr><td>int</td><td>2 个或 4 个字节</td><td>-32 768 或 -2 147 483 684</td><td>32 768 或 2 147 483 684</td></tr><tr><td>unsigned int</td><td>2 个或 4 个字节</td><td>0</td><td>65 535 或 4 294 967 295</td></tr><tr><td>short</td><td>2 个字节</td><td>-32 768</td><td>32 767</td></tr><tr><td>unsigned short</td><td>2 个字节</td><td>0</td><td>65 535</td></tr><tr><td>long</td><td>4 个字节</td><td>-2 147 483 648</td><td>2 147 483 647</td></tr><tr><td>unsigned long</td><td>4 个字节</td><td>0</td><td>4 294 967 295</td></tr><tr><td>long long（C99）</td><td>8 个字节</td><td>-9 223 372 036 854 755 808</td><td>9 223 372 036 854 755 808</td></tr><tr><td>unsigned long long（C99）</td><td>8 个字节</td><td>0</td><td>18 446 744 073 709 551 615</td></tr></tbody></table><p>​<strong>注：int 类型在 16 位系统中占 2 个字节，在 32 和 64 位系统中占 4 个字节</strong></p><h2 id="基本类型转换"><a class="markdownIt-Anchor" href="#基本类型转换">#</a> 基本类型转换</h2><h4 id="1自动类型转换"><a class="markdownIt-Anchor" href="#1自动类型转换">#</a> 1. 自动类型转换</h4><p>当两个不同类型的变量进行运算时，编译器会自动进行类型转换，自动类型转换遵从以下规则：</p><p><img src="https://s3.bmp.ovh/imgs/2021/10/95b6bbcb25e8bb2f.png" alt=""></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">1.2</span>;</span><br><span class="line"><span class="keyword">double</span> c = a+b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,c);</span><br></pre></td></tr></table></figure><p>​在执行 a+b 运算的时候编译器会先把 int 类型的 a 转为 double 类型，然后再和 b 进行运算</p><h4 id="2强制类型转换"><a class="markdownIt-Anchor" href="#2强制类型转换">#</a> 2. 强制类型转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">3.641593</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="keyword">int</span>)a ); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,a );<span class="comment">// 3.641593</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注：在进行由高到低的强制类型转换时，数据会有部分丢失</strong></p><p><strong>强制类型转换是临时的，不会修改变量本来的类型</strong></p></blockquote><h2 id="基本类型书写"><a class="markdownIt-Anchor" href="#基本类型书写">#</a> 基本类型书写</h2><p><strong>整数</strong></p><ul><li><p>默认为 10 进制 ，10 ，20。</p></li><li><p>以 0 开头为 8 进制，012，024。</p></li><li><p>以 0b 开头为 2 进制，0b1010, 0b10100。</p></li><li><p>以 0x 开头为 16 进制，0xa，0x14。</p></li></ul><p><strong>小数</strong></p><p>单精度常量（float）：2.3f 。</p><p>双精度常量（double）：2.3，默认为双精度。</p><p><strong>字符型常量</strong></p><p>用英文单引号括起来，只保存一个字符，‘a’、‘b’ 、’*’ ，还有转义字符 ‘\n’ 、’\t’。</p><p><strong>字符串常量</strong></p><p>用英文的双引号引起来 可以保存多个字符：“abc”。</p><h2 id="变量"><a class="markdownIt-Anchor" href="#变量">#</a> 变量</h2><p>​变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存 储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>​这里的 age 就是一个变量，变量 age 的值为 5，而”age“叫做变量名。</p><p>​同一类型的多个变量的声明之间可以用逗号隔开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line"><span class="comment">//声明并定义了变量 i、j 和 k，</span></span><br><span class="line"><span class="comment">//这指示编译器创建类型为 int 的名为 i、j、k 的变量。下面同理</span></span><br><span class="line"><span class="keyword">char</span> c, ch;</span><br><span class="line"><span class="keyword">float</span> f, salary;</span><br><span class="line"><span class="keyword">double</span> d;</span><br></pre></td></tr></table></figure><h3 id="变量的输入和输出"><a class="markdownIt-Anchor" href="#变量的输入和输出">#</a> 变量的输入和输出</h3><p>1.scanf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入char变量：</span></span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入int变量：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入double/float变量：</span></span><br><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a);</span><br><span class="line"><span class="keyword">float</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;a);</span><br></pre></td></tr></table></figure><p>2.printf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出char变量：</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a); <span class="comment">// c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出int变量：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出double/float变量：</span></span><br><span class="line"><span class="keyword">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,a); <span class="comment">// 3.140000 默认保留六位小数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,a);<span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,a);<span class="comment">// 3.1</span></span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>符号</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th><th>结果</th></tr></thead><tbody><tr><td>x</td><td>unsigned int</td><td>以十六进制小写输出</td><td>printf(&quot;%x&quot;,11);</td><td>b</td></tr><tr><td>X</td><td>unsigned int</td><td>以十六进制大写输出</td><td>printf(&quot;%X&quot;,11);</td><td>B</td></tr><tr><td>o</td><td>unsigned int</td><td>以八进制无符号整 S 输出</td><td>printf( &quot;%o”,100);</td><td>144</td></tr><tr><td>u</td><td>unsigned int</td><td>以无符号整型输出</td><td>printf( “%u,%u”,100u,100);</td><td>100,100</td></tr><tr><td>d、i</td><td>int</td><td>以整型输出</td><td>printf(&quot;%i,%d&quot;, 100,100);</td><td>100,100</td></tr></tbody></table><h2 id="常量"><a class="markdownIt-Anchor" href="#常量">#</a> 常量</h2><p>​常量是固定值，在程序执行期间不会改变。</p><p>​常量可以是任何的基本数据类型，比如 int,double,char</p><h3 id="常量的定义"><a class="markdownIt-Anchor" href="#常量的定义">#</a> 常量的定义：</h3><ol><li><p>使用 <strong>#define</strong> 预处理器。</p></li><li><p>使用 <strong>const</strong> 关键字。 <strong>被 const 和 define 修饰的变量不可变</strong></p><p><strong>#define 预处理器</strong></p><p>下面是使用 #define 预处理器定义常量的形式：</p><p>注意：define 定义之后不需要加分号</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//模式：</span></span><br><span class="line"><span class="comment">//#define identifier value</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEWLINE <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> area;</span><br><span class="line">area = LENGTH * WIDTH;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value of area : %d\n&quot;</span>, area);</span><br><span class="line"><span class="keyword">double</span> r_area;</span><br><span class="line">r_area = PI * R * R;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value of double area:%lf\n&quot;</span>, r_area);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, NEWLINE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const 关键字</strong></p><p>​可以使用 const 前缀声明指定类型的常量，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LENGTH = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> WIDTH = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> NEWLINE = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> area;</span><br><span class="line">area = LENGTH * WIDTH;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value of area : %d&quot;</span>, area);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, NEWLINE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运算符"><a class="markdownIt-Anchor" href="#运算符">#</a> 运算符</h1><h2 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符">#</a> 算术运算符</h2><ol><li><p>”+“运算符：把两个数相加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = 7</span></span><br></pre></td></tr></table></figure></li><li><p>”-“运算符：把两个数相减</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = a - b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = -3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>“*” 运算符：把两个数相乘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = a * b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = 10</span></span><br></pre></td></tr></table></figure></li><li><p>“/” 运算符：把两个数相除，左边是被除数，右边的是除数（右边的数不能为 0）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = a / b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = 0</span></span><br><span class="line"><span class="comment">/*这里因为a，b，c都是int类型，a/b=0.4,所以会直接舍去后面的.4，只剩0*/</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">double</span> e = <span class="number">3.0</span>;</span><br><span class="line"><span class="keyword">double</span> f = e / d;</span><br><span class="line"><span class="comment">//double类型允许小数的存在，因此这里的f就是1.5了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：C 语言不会对计算结果进行四舍五入，会直接全部舍去，比如 3.9，转为 int 类型的时候 就会变成 3</p></li><li><p>”%“：取余运算符，可以直接取整除之后的余数：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = b % a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = 1</span></span><br></pre></td></tr></table></figure><ol start="6"><li>”++“运算符：自增运算符，让变量的值加 1：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a++;<span class="comment">//也可以写成 c = ++a;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = </span></span><br></pre></td></tr></table></figure><p><strong>a<ins> 与</ins> a 的区别:</strong></p><p>​在进行 a++ 运算时，程序会先对 a 复制一次，然后让其 + 1，执行的操作类似 a = a + 1</p><p>​在进行 ++a 运算时，程序会直接让 a+1</p><ol start="7"><li><p>“–” 运算符：自减运算符，让变量的值 - 1：</p><p>​与 ++ 运算符同理，a–运算会对 a 先复制一次，再让其 - 1，–a 会直接让其 - 1</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,--a);<span class="comment">//输出0</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b--);<span class="comment">//输出1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b);<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure><p><strong>关系运算符</strong></p><ol><li>== 运算符：</li></ol><p>在 c 语言中 ” = “表示的是对一个变量进行赋值，而要想判断两个变量的值是否相同所用到的 是” == “运算符，该运算符返回的是一个真假值（在 c 语言中 1 表示真值，0 表示假值）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a == b);<span class="comment">// 1</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a == b); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ol start="2"><li>!= 运算符:</li></ol><p>这个运算符表示两个变量是否不同，返回值为真假值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a != b);<span class="comment">// 0</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a != b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ol start="3"><li>&gt; 运算符：</li></ol><p>判断运算符左边的变量是否大于右边的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &gt; b);<span class="comment">// 0</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &gt; b); <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>&lt; 运算符：</li></ol><p>判断运算符左边的变量是否小于右边的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &lt; b);<span class="comment">// 1</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &lt; b); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ol start="5"><li>&gt;= 运算符：</li></ol><p>判断运算符左边的变量是否大于等于右边的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &gt;= b);<span class="comment">// 1</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &gt;= b); <span class="comment">// 1 </span></span><br></pre></td></tr></table></figure><ol start="6"><li>&lt;= 运算符：</li></ol><p>判断运算符左边的变量是否小于等于右边的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &lt; b);<span class="comment">// 1</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &lt; b); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符">#</a> 逻辑运算符</h2><ol><li>&amp;&amp; 运算符： 表示 “且”，如果左右两个操作全部为真，则该表达式返回真</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>,b = <span class="number">3</span>;</span><br><span class="line">(a &lt; b &amp;&amp; a == <span class="number">2</span>) <span class="comment">// 这个表达式为 1</span></span><br><span class="line">(a &lt; b &amp;&amp; a == <span class="number">3</span>) <span class="comment">// 这个表达式为 0</span></span><br><span class="line">(a &lt; b &amp;&amp; a == <span class="number">3</span>) <span class="comment">// 这个表达式为 0</span></span><br><span class="line">(a &gt; b &amp;&amp; a == <span class="number">2</span>) <span class="comment">// 这个表达式为 0</span></span><br></pre></td></tr></table></figure><ol start="2"><li>|| 运算符： 表示 “或”，左右两个操作有一个为真，则该表达式为真</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>,b = <span class="number">3</span>;</span><br><span class="line">(a &lt; b || a == <span class="number">2</span>) <span class="comment">// 这个表达式为 1</span></span><br><span class="line">(a &lt; b || a == <span class="number">3</span>) <span class="comment">// 这个表达式为 1</span></span><br><span class="line">(a &gt; b || a == <span class="number">2</span>) <span class="comment">// 这个表达式为 1</span></span><br><span class="line">(a &gt; b || a == <span class="number">3</span>) <span class="comment">// 这个表达式为 0</span></span><br></pre></td></tr></table></figure><ol start="3"><li>! 运算符： 表示 “非”，如果修饰的条件表达式为真，则该表达式为假，反之为真。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>,b = <span class="number">3</span>;</span><br><span class="line">(a &lt; b || a == <span class="number">2</span>) <span class="comment">// 这个表达式为 1</span></span><br><span class="line">!(a &lt; b || a == <span class="number">2</span>) <span class="comment">// 这个表达式为 0</span></span><br><span class="line">(a &gt; b &amp;&amp; a == <span class="number">2</span>) <span class="comment">// 这个表达式为 0</span></span><br><span class="line">!(a &gt; b &amp;&amp; a == <span class="number">2</span>) <span class="comment">// 这个表达式为 1</span></span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符">#</a> 赋值运算符</h2><table><thead><tr><th><strong>运算符</strong></th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td>C = A + B 将把 A + B 的 值赋给 C</td></tr><tr><td>+=</td><td>加且赋值运算符，把右边操作数加上左边操作数的结果赋 值给左边操作数</td><td>C += A 相当于 C = C + A</td></tr><tr><td>-=</td><td>减且赋值运算符，把左边操作数减去右边操作数的结果赋 值给左边操作数</td><td>C -= A 相当于 C = C - A</td></tr><tr><td>*=</td><td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋 值给左边操作数</td><td>C *= A 相当于 C = C * A</td></tr><tr><td>/=</td><td>除且赋值运算符，把左边操作数除以右边操作数的结果赋 值给左边操作数</td><td>C /= A 相当于 C = C / A</td></tr><tr><td>%=</td><td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td>C %= A 相当于 C = C % A</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">a += <span class="number">3</span>; <span class="comment">// a = a + 3</span></span><br><span class="line">a -= <span class="number">3</span>; <span class="comment">// a = a - 3</span></span><br><span class="line">a *= <span class="number">3</span>; <span class="comment">// a = a * 3</span></span><br><span class="line">a /= <span class="number">3</span>; <span class="comment">// a = a / 3</span></span><br><span class="line">a %= <span class="number">3</span>; <span class="comment">// a = a % 3</span></span><br><span class="line">a = <span class="number">3</span>; <span class="comment">// a = 3</span></span><br></pre></td></tr></table></figure><h1 id="判断语句"><a class="markdownIt-Anchor" href="#判断语句">#</a> 判断语句</h1><p><img src="https://static.runoob.com/wp-content/uploads/c/C-decision-20200923-1.svg" alt=""></p><p>​判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需 的）和条件为假时要执行的语句（可选的）。</p><h2 id="if-语句"><a class="markdownIt-Anchor" href="#if-语句">#</a> if 语句</h2><p>​模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件语句)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = b!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​一个 if 语句由一个条件语句后跟一个或多个语句组成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b &amp;&amp; a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = b!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="else语句"><a class="markdownIt-Anchor" href="#else语句">#</a> else 语句</h2><p>​当条件不满足 if 中的条件语句时会跳入 else 语句执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式/条件语句)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果布尔表达式为真将执行的语句 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果布尔表达式为假将执行的语句 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://static.runoob.com/wp-content/uploads/c/c-if-else-20200923.svg" alt=""></p><p>​示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>,b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a&lt;b!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a&gt;=b!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="else-if-语句"><a class="markdownIt-Anchor" href="#else-if-语句">#</a> else if 语句</h2><p>​当需要进行多次判断时，可以使用 else if 语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>/条件语句<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果布尔表达式1为真将执行的语句 */</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>/条件语句<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果布尔表达式1为假,布尔表达式2为真将执行的语句 */</span></span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*如果两个布尔表达式都为假要执行的语句*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>,b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a&lt;b!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=b!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a&gt;b!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-case-语句"><a class="markdownIt-Anchor" href="#switch-case-语句">#</a> switch case 语句</h2><p>​如果需要判断的语句很多的时候，if else 未免显得非常繁琐，因此我们可以使用效率更高，更加精 简的 switch case 语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)&#123;<span class="keyword">case</span> 值<span class="number">1</span> :statement(s);<span class="comment">//执行语句break; /* 可选的 */case 值2 :statement(s);//执行语句break; /* 可选的 *//* 可以有任意数量的 case 语句 */default : /* 可选的 如果匹配不成功就会跳到这个标签下面去执行这个标签下面的语句*/statement(s);&#125;</span></span><br></pre></td></tr></table></figure><p>​示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;<span class="keyword">switch</span>(x)&#123;<span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">&quot;x=0&quot;</span>);<span class="comment">//执行语句break; /* 可选的 */case 5:printf(&quot;x=5&quot;);//执行语句break; /* 可选的 *//* 可以有任意数量的 case 语句 */default : /* 可选的 如果匹配不成功就会跳到这个标签下面去执行这个标签下面的语句*/printf(&quot;no pattern&quot;);&#125;</span></span><br></pre></td></tr></table></figure><p><strong>switch</strong> 语句必须遵循下面的规则：</p><ul><li><p>switch 语句中 case 后面是一个常量（不能为浮点数） 在一个 switch 中可以有任意数量的 case 语句。</p></li><li><p>case 后面的常量 必须与 switch 中的变量具有相同的数据类型。</p></li><li><p>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为 止。</p></li><li><p>当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</p></li><li><p>不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会继续后续的 case，直到遇到 break 为止。</p></li><li><p>一个 switch 语句可以有一个可选的 default，出现在 switch 的结尾。在上面所有的 case 都 不执行时执行。default 中的 break 语句不是必需的。</p><p>​示例：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> grade = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span>(grade)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;很棒！\n&quot;</span> );</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span> :</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;做得好\n&quot;</span> );</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;您通过了\n&quot;</span> );</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最好再试一下\n&quot;</span> );</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;无效的成绩\n&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;成绩是 %c\n&quot;</span>, grade );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环"><a class="markdownIt-Anchor" href="#循环">#</a> 循环</h1><p>​当我们需要重复执行同一块代码时，我们可以使用循环操作来减少代码量。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/12/loop.png" alt=""></p><h2 id="1while循环"><a class="markdownIt-Anchor" href="#1while循环">#</a> 1.while 循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件语句)</span><br><span class="line">&#123;</span><br><span class="line">statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,n);</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次打印出0--9</span></span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2014/09/BFE13459-897C-41A5-AE94-D71B0CA50FB6.jpg" alt=""></p><h2 id="2for循环"><a class="markdownIt-Anchor" href="#2for循环">#</a> 2.for 循环</h2><h2 id=""><a class="markdownIt-Anchor" href="#">#</a> </h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( init; condition; increment )</span><br><span class="line">&#123;</span><br><span class="line">statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//依次打印出从0到9</span></span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2014/09/69978E61-0BA5-4D66-A115-D3AD15B16F47.jpg" alt=""></p><h2 id="3do"><a class="markdownIt-Anchor" href="#3do">#</a> <a href="http://3.do">3.do</a>…while 循环：</h2><p>​不像 <strong>for</strong> 和 while 循环，它们是在循环头部测试循环条件。在 C 语言中，do…while 循环是 在循环的尾部检查它的条件。</p><p>​do…while 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。也就是 说，do…while 结构会先执行循环，后进行条件判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">statement(s);</span><br><span class="line">&#125;<span class="keyword">while</span>( condition );</span><br></pre></td></tr></table></figure><p>​示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">++n;</span><br><span class="line">&#125; <span class="keyword">while</span>(n &lt; <span class="number">0</span>); <span class="comment">// 输出 0</span></span><br><span class="line"><span class="keyword">while</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">++n;</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2014/09/B2FE1EC7-6477-439B-8F50-82D537673799.jpg" alt=""></p><h1 id="函数"><a class="markdownIt-Anchor" href="#函数">#</a> 函数</h1><p>​函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main () ，所有简 单的程序都可以定义其他额外的函数。</p><p>​定义方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数)&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 返回类型：** 一个函数可以返回一个值。指函数返回的值的数据类型。有些函数执行所需的操作而不 返回值，在这种情况下，返回类型是 void。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_a</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明">#</a> 函数声明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int max(int ,int );</span><br><span class="line">void print_a(int );</span><br><span class="line">int max(int a,int b)&#123;</span><br><span class="line">if(a &gt; b)&#123;</span><br><span class="line">return a;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void print_a(int a)&#123;</span><br><span class="line">printf(&quot;%d&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n = 0,m = 5;</span><br><span class="line">int num = max(n,m);</span><br><span class="line">print_a(num);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a class="markdownIt-Anchor" href="#数组">#</a> 数组</h1><p>​当我们需要声明或使用同一类型的多个变量时，一个个声明未免太过繁琐，我们可以使用数组来达 到这个目的。</p><blockquote><p>数组是一个 <strong>固定大小</strong> 的 <strong>相同类型元素</strong> 的 <strong>顺序集合</strong>。</p></blockquote><p>​声明方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 数组名[数组大小];</span><br></pre></td></tr></table></figure><p>​示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>]; <span class="comment">// 声明一个大小为10的int类型数组,它可以存储10个int类型的元素</span></span><br><span class="line"><span class="keyword">double</span> <span class="built_in">array</span>[<span class="number">10</span>]; <span class="comment">// 声明一个大小为10的double类型数组，它可以存储10个double类型的元素</span></span><br></pre></td></tr></table></figure><h2 id="初始化数组"><a class="markdownIt-Anchor" href="#初始化数组">#</a> 初始化数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>​<strong>注意： 大括号 {} 之间的值的数目不能大于我们在数组声明时在方括号 [] 中指定的元素数目。</strong></p><p>​有时我们会开一个超级大的数组，这时使用大括号来进行初始化就非常麻烦了，因此我们结合之前 的循环操作来对数组进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line"><span class="built_in">array</span>[i] = i+<span class="number">100</span>; <span class="comment">// 设置元素i的值为i+100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问数组元素</strong></p><p>​数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。 例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> num = <span class="built_in">array</span>[<span class="number">0</span>]; <span class="comment">// num = 0;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ )<span class="comment">//利用循环打印整个数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Array[%d] = %d\n&quot;</span>, j, <span class="built_in">array</span>[j] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>注意：数组元素只被创建而没有被初始化的时候是不能进行正常访问的，只有数组中元素被赋值才 可以正常访问。</strong></p><h1 id="指针"><a class="markdownIt-Anchor" href="#指针">#</a> 指针</h1><h2 id="使用指针"><a class="markdownIt-Anchor" href="#使用指针">#</a> 使用指针</h2><p>​想要在函数中完成变量的交换，不被形参所限制。</p><p>​<strong>指针</strong>可以达成我们的目的。</p><p>​在程序运行时，变量被创建时， 变量都会被分配到一个内存位置。</p><p>​内存位置可以通过 **&amp; 运算符<strong>获取</strong>地址 **。</p><p>​<strong>注意： 指针变量的类型必须要跟被取地址变量类型一致</strong></p><h2 id="怎么理解指针"><a class="markdownIt-Anchor" href="#怎么理解指针">#</a> 怎么理解指针</h2><p>让我们把 *p ，拆分成两部分去理解。</p><p><strong>’p’ 部分 ：是一个变量，能存储地址。</strong></p><p><strong>’*’ 部分 ：获取变量 p 储存的地址，并找到该地址上存储的值。</strong></p><p>​运行上面的代码，输出 *p 的值就是 var 的值。</p><p>​** 注意：** 多数时候指针初始化置 <strong>NULL</strong> 很有必要。</p><h2 id="指针基本运算"><a class="markdownIt-Anchor" href="#指针基本运算">#</a> 指针基本运算</h2><p>​指针就是地址，地址在内存中也是以数的形式存在，所以指针也能进行基本运算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);</span><br><span class="line">p++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);</span><br><span class="line">p -= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="指向一维数组的指针"><a class="markdownIt-Anchor" href="#指向一维数组的指针">#</a> 指向一维数组的指针</h2><ul><li><p>数组中的每个数据都会保存在一个储存单元里面，只要是储存单元就会有地址，所以就可以用 指针保存数组储存单元的地址。</p><p><em>为指针赋数组数据的地址</em></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = &amp;num[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以使用指针操作一维数组</strong></p><ul><li>第一种</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br><span class="line">p++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br></pre></td></tr></table></figure><ul><li>第二种</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = &amp;num[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h2 id="指向二维数组的指针"><a class="markdownIt-Anchor" href="#指向二维数组的指针">#</a> 指向二维数组的指针</h2><p>​跟一维数组相似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;num[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><ul><li>注意： 不能为指针直接赋予二维数组的数组名，即上面的代码不能写成： int *p = num；</li></ul><h2 id="数组指针"><a class="markdownIt-Anchor" href="#数组指针">#</a> 数组指针</h2><p>​<strong>顾名思义：</strong> 指向数组的指针</p><p>​如果一个指针指向了数组，就称它为数组指针。c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>​在概念上的矩阵是像这种矩阵的样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>​但实际上它在内存中是链式存储的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>​定义一个数组指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br></pre></td></tr></table></figure><p><strong>括号里面的 * 代表 p 是一个指针，[3] 代表这个 指针 p 指向了类型为 int [3] 的数组</strong></p><ul><li><p>p 指向数组 a 的开头，就是指向数组的第 0 行元素，p + 1 指向数组的第一行元素</p></li><li><p>所以 *(p+1) 就表示数组的第一行元素的值，有多个数据</p></li><li><p>*(p+1) + 1 表示第一行的第一个数据的地址</p></li></ul><h2 id="二级指针"><a class="markdownIt-Anchor" href="#二级指针">#</a> 二级指针</h2><p>​<strong>顾名思义：</strong> 指向指针的指针</p><p>​假设有一个 int 类型的变量 a ， p1 是指向 a 的指针变量， p2 又是指向 p1 的指针变量。</p><p>​用代码形式展现就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **p2 = &amp;p1;</span><br></pre></td></tr></table></figure><p>​指针变量也是一种变量，也会占用存储空间，也可以使用 &amp; 获取它的地址。C 语言不限制指针的级 数，每增加一级指针，在定义指针变量时就得增加一个星号。p1 是一级指针，指向普通类型的数据， 定义时有一个；p2 是二级指针，指向一级指针 p1，定义时有两个 *。</p><p>​** 同理：** 指针可以有三级指针、四级指针等等。</p><h2 id="指针在函数中的作用"><a class="markdownIt-Anchor" href="#指针在函数中的作用">#</a> 指针在函数中的作用</h2><p><strong>指针作为函数的参数</strong></p><p>写一个函数并调用，实现交换变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp= a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">swap(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>,a,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​运行上面的代码，<strong>a 和 b 的值并没有发生交换</strong></p><h2 id="形参形式参数"><a class="markdownIt-Anchor" href="#形参形式参数">#</a> 形参（形式参数）</h2><p>​在函数定义中出现的参数，它没有数据，只能在函数被调用时接收传递进来的数据，所以称为<strong>形式参数</strong>。</p><h2 id="实参实际参数"><a class="markdownIt-Anchor" href="#实参实际参数">#</a> 实参（实际参数）</h2><p>​函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为<strong>实际参数</strong>。 形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp= a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">swap(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>,a,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>main 函数</strong> 中调用的 <strong>swap 函数</strong> <strong>swap(a, b);</strong> 中的 a，b 是<strong>实参</strong>。</p><p>​<strong>swap 函数</strong> 定义的 <strong>void swap(int a,int b)</strong> 中的 a，b 是<strong>形参。</strong></p><p>​在 c 语言中实参和形参之间的数据传输是单向的 “值传递” 方式，也就是实参可以影响形参，而形参不 能影响实参。指针变量作为参数也不例外，但是可以改变实参指针变量所指向的变量的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确的变量交换代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *temp= a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">swap(&amp;a, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>,a,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面代码在调用 scanf 或者 swap 函数的时候，传入变量时，变量前都使用了 &amp; 运算符</p><p>​这两个函数通过传入的地址去改变了实参。</p><h2 id="指针函数"><a class="markdownIt-Anchor" href="#指针函数">#</a> 指针函数</h2><p>​C 语言允许函数的返回值是一个指针（地址），我们将这样的函数称为指针函数。</p><p>​下面的例子定义了一个函数 strlong () ，用来返回两个字符串中较长的一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strlong</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span>&#123;<span class="comment">//返回类型是(char*)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(str1) &gt;= <span class="built_in">strlen</span>(str2))&#123;</span><br><span class="line"><span class="keyword">return</span> str1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> str2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">30</span>], str2[<span class="number">30</span>], *str;</span><br><span class="line">gets(str1);</span><br><span class="line">gets(str2);</span><br><span class="line">str = strlong(str1, str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Longer string: %s\n&quot;</span>, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>注意：函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数。</strong></p><h1 id="结构体"><a class="markdownIt-Anchor" href="#结构体">#</a> 结构体</h1><p>​如果我们想存储多个学生的信息，比如身高、体重、学习成绩，等等。</p><p>​在学结构体前，我们可以使用多个数组，用相同下标去存储一个学生的所有信息。</p><p>​或者使用很多的变量，去储存信息，上述实现方法显得相当麻烦。</p><p>​C 语言向我们提供了一种数据类型 <strong>：结构体（struct）</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">double</span> weight;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;student1;</span><br></pre></td></tr></table></figure><p>​这是一个结构体的定义，拆分看。</p><p>​<strong>struct student:</strong> struct 是定义结构体必备的前缀。student 是结构体标签。 struct student 可 以像 int、double、float 作为定义变量的数据类型。</p><p>​**{} 内的变量：** 结构体就像个模板，能规定好里面填什么变量。</p><p>​**student1：** 定义 struct student 类型的变量 .</p><p><strong>typedef</strong></p><p>​<strong>typedef</strong> 这是一个重命名的关键字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef + 数据类型 + 你想要重命名的英文</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">double</span> weight;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;Stu;</span><br></pre></td></tr></table></figure><p>​typedef 在这段代码中将 stu 等效成了  <code>struct student ，而不是一个 struct student</code>  类型的变量。</p><p>​<strong>结构体变量的初始化</strong></p><p>​结构体也是一种数据类型，从某种程度上说与 int 等类似，属于同级，所以定义变量的方式也是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truct Stu stu1,stu2; <span class="comment">//这里定义了Stu类型的变量</span></span><br></pre></td></tr></table></figure><p>​<strong>结构体成员的赋值</strong></p><p>​结构体成员的获取形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体变量名.成员名;</span><br></pre></td></tr></table></figure><p>​<strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stu stu1;</span><br><span class="line">stu1.height = <span class="number">175</span>;</span><br><span class="line">stu1.name = <span class="string">&#x27;辰灏&#x27;</span>;</span><br><span class="line">stu1.weight = <span class="number">100.0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;身高：%d,姓名：%s,体重：%lf\n&quot;</span>,stu1.height,stu1.name,stu1.weight);</span><br></pre></td></tr></table></figure><h2 id="结构体的使用"><a class="markdownIt-Anchor" href="#结构体的使用">#</a> 结构体的使用</h2><ul><li>在结构体中使用数组</li></ul><p><strong>结构体中的成员变量可以是数组，没有什么特别的。</strong></p><ul><li>结构体与指针</li></ul><p><strong>结构体可以作为函数的参数传进子函数中，然后在子函数中使用.</strong></p><p><strong>下面是一个输出函数</strong></p><p><strong>Node 是一个结构体，print () 是一个子函数，这个子函数有一个 Node 类型的参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Stu *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,stu-&gt;height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a class="markdownIt-Anchor" href="#链表">#</a> 链表</h2><p>结构体变量指针</p><ul><li>结构体变量指向自身</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">table</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">table</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在初始化时，变量next,会指向自身，所以在初始化变量时要把next指针置NULL。</span></span><br></pre></td></tr></table></figure><ul><li><p>指向其它结构变量</p><p>​即将定义的两个结构体变量，比方说定义了 st1 和 st2 两个结构体变量，只需要将 st2 的地址 赋给 st1 的指针域，这样 st1 的指针就指向了 st2。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">table</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">strcut table st1 = &#123;<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">table</span> <span class="title">st2</span> =</span> &#123;<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">st1.next = &amp;st2;</span><br></pre></td></tr></table></figure><h3 id="动态创建链表"><a class="markdownIt-Anchor" href="#动态创建链表">#</a> 动态创建链表</h3><ul><li><p>构造一个结构类型，此结构类型必须包含至少一个成员指针，此指针要指向此结构类型</p></li><li><p>定义 3 个结构体类型的指针，按照用途可以命名为，p_head,p_rail,p_new</p></li><li><p>动态生成新的结点，为各成员变量赋值，最后加到链表当中。</p></li><li><p>动态创建的链表，没有一个单独的变量名去寻找到节点，全部都是由结构体中的 next 指针找 到下一个节点</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">short</span> i; <span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">char</span> c; <span class="comment">///数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span> <span class="comment">//指针域，用于指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p>​定义结构体指针，不一定要在 main 函数中定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node *p_head,*p_rail,*p_new ;</span><br></pre></td></tr></table></figure><h3 id="使用malloc函数申请存储空间"><a class="markdownIt-Anchor" href="#使用malloc函数申请存储空间">#</a> 使用 malloc 函数申请存储空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p_head = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br></pre></td></tr></table></figure><ul><li><p>（struct node*) 强制类型转换</p></li><li><p>malloc () 申请空间函数</p></li><li><p>sizeof () 申请的大小函数 在使用完这个结构体以后可以使用函数</p></li><li><p>free () 将申请的空间释放。</p></li></ul><p>​示例：</p><p>​构造结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> i;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">//定义变量</span></span><br><span class="line">Node node1 = &#123;<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>&#125;;</span><br><span class="line">Node node2 = &#123;<span class="number">2</span>,<span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line">Node node3 = &#123;<span class="number">3</span>,<span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//链表连接</span></span><br><span class="line">node1.next = &amp;node2;</span><br><span class="line">node2.next = &amp;node3;</span><br><span class="line"><span class="comment">//动态申请节点并添加到链表中</span></span><br><span class="line">Node *p_new;</span><br><span class="line">p_new = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">p_new-&gt;i = <span class="number">4</span>;</span><br><span class="line">p_new-&gt;c = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">node3.next = p_new;</span><br></pre></td></tr></table></figure><h3 id="链表操作"><a class="markdownIt-Anchor" href="#链表操作">#</a> 链表操作</h3><p>插入</p><p><img src="https://s3.bmp.ovh/imgs/2021/10/0bf521dd435c6a14.png" alt=""></p><ul><li>插入节点到头节点之前</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node p_new = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//创建新结点，并为其开辟空间</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;(p_new-&gt;i),&amp;(p_new-&gt;c)); <span class="comment">//录入结点数据</span></span><br><span class="line"><span class="comment">//插入节点</span></span><br><span class="line">p_new-&gt;next = p_head;</span><br><span class="line">p_head = p_new;</span><br></pre></td></tr></table></figure><ul><li>插入节点到链表中间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node *p_new = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//创建新结点，并为其开辟空间</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;(p_new-&gt;i),&amp;(p_new-&gt;c)); <span class="comment">//录入结点数据</span></span><br><span class="line">Node *p_front = p_head-&gt;next;</span><br><span class="line">p_new-&gt;next = p_front-&gt;next;</span><br><span class="line">p_front-&gt;next = p_new;</span><br></pre></td></tr></table></figure><ul><li>插入节点到末尾</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!p)&#123; <span class="comment">//如果p是空的</span></span><br><span class="line">p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;(p-&gt;i),&amp;(p-&gt;c)); <span class="comment">//录入结点数据</span></span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//next节点置空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node p_loop = p;</span><br><span class="line"><span class="keyword">while</span>(p_loop)&#123;</span><br><span class="line">p_loop = p_loop-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p_new = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;(p_new-&gt;i),&amp;(p_new-&gt;c)); <span class="comment">//录入结点数据</span></span><br><span class="line">p_new-&gt;next = <span class="literal">NULL</span>;<span class="comment">//next节点置空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除某一位置节点</li></ul><p><img src="https://s3.bmp.ovh/imgs/2021/10/9c1b67676cb5017d.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_list</span><span class="params">(struct node *p_head,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">strct node *p_front,*p_del;</span><br><span class="line">p_front = p_head;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= pos - <span class="number">1</span>;i ++)</span><br><span class="line">&#123;</span><br><span class="line">p_front = p_front-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    p_del = p_front-&gt;next;</span><br><span class="line">p_front-&gt;next = p_del-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p_del);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某菜鸡艰难的you-get使用历程</title>
      <link href="/passages/%E6%9F%90%E8%8F%9C%E9%B8%A1%E8%89%B0%E9%9A%BE%E7%9A%84you-get%E4%BD%BF%E7%94%A8%E5%8E%86%E7%A8%8B/"/>
      <url>/passages/%E6%9F%90%E8%8F%9C%E9%B8%A1%E8%89%B0%E9%9A%BE%E7%9A%84you-get%E4%BD%BF%E7%94%A8%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>​        <strong>声明：本文主要功能是记录使用 you-get 的感受和经历，也写了一些使用的过程，可以参考，但不是教学式的教程。（需要教程请百度 / 必应一下）</strong></p><h1 id="you-get初体验"><a class="markdownIt-Anchor" href="#you-get初体验">#</a> you-get 初体验</h1><p>​        偶尔有看到身边的同学在用 you-get，并推荐给了我们，当时并没有感觉有很棒，但是后来感觉还是很好用的（真香定律。</p><h1 id="you-get的使用"><a class="markdownIt-Anchor" href="#you-get的使用">#</a> you-get 的使用</h1><h2 id="安装"><a class="markdownIt-Anchor" href="#安装">#</a> 安装</h2><p>​        首先我们需要准备 Python 环境，可以去 python 官网下载，大于等于 Python3 即可，我用的是 python3.9.7。</p><p><img src="https://s3.bmp.ovh/imgs/2021/09/d969338599694a69.png" alt=""></p><p>​        准备好环境之后就可以下载 you-get 了。（cmd 和 git bush 都可以）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install you-get</span><br><span class="line"></span><br><span class="line"># 如果下载的慢，可以使用国内的源站下载</span><br><span class="line">#豆瓣</span><br><span class="line">pip install -i http://pypi.douban.com/simple/ you-get</span><br><span class="line">#清华</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple you-get</span><br></pre></td></tr></table></figure><p>​        安装之后输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get</span><br></pre></td></tr></table></figure><p>​        出现如下内容说明安装好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">usage: you-get [OPTION]... URL...</span><br><span class="line"></span><br><span class="line">A tiny downloader that scrapes the web</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -V, --version         Print version and exit</span><br><span class="line">  -h, --help            Print this help message and exit</span><br><span class="line"></span><br><span class="line">Dry-run options:</span><br><span class="line">  (no actual downloading)</span><br><span class="line"></span><br><span class="line">  -i, --info            Print extracted information</span><br><span class="line">  -u, --url             Print extracted information with URLs</span><br><span class="line">  --json                Print extracted URLs in JSON format</span><br><span class="line"></span><br><span class="line">Download options:</span><br><span class="line">  -n, --no-merge        Do not merge video parts</span><br><span class="line">  --no-caption          Do not download captions (subtitles, lyrics, danmaku, ...)</span><br><span class="line">  -f, --force           Force overwriting existing files</span><br><span class="line">  --skip-existing-file-size-check</span><br><span class="line">                        Skip existing file without checking file size</span><br><span class="line">  -F STREAM_ID, --format STREAM_ID</span><br><span class="line">                        Set video format to STREAM_ID</span><br><span class="line">  -O FILE, --output-filename FILE</span><br><span class="line">                        Set output filename</span><br><span class="line">  -o DIR, --output-dir DIR</span><br><span class="line">                        Set output directory</span><br><span class="line">  -p PLAYER, --player PLAYER</span><br><span class="line">                        Stream extracted URL to a PLAYER</span><br><span class="line">  -c COOKIES_FILE, --cookies COOKIES_FILE</span><br><span class="line">                        Load cookies.txt or cookies.sqlite</span><br><span class="line">  -t SECONDS, --timeout SECONDS</span><br><span class="line">                        Set socket timeout</span><br><span class="line">  -d, --debug           Show traceback and other debug info</span><br><span class="line">  -I FILE, --input-file FILE</span><br><span class="line">                        Read non-playlist URLs from FILE</span><br><span class="line">  -P PASSWORD, --password PASSWORD</span><br><span class="line">                        Set video visit password to PASSWORD</span><br><span class="line">  -l, --playlist        Prefer to download a playlist</span><br><span class="line">  -a, --auto-rename     Auto rename same name different files</span><br><span class="line">  -k, --insecure        ignore ssl errors</span><br><span class="line"></span><br><span class="line">Proxy options:</span><br><span class="line">  -x HOST:PORT, --http-proxy HOST:PORT</span><br><span class="line">                        Use an HTTP proxy for downloading</span><br><span class="line">  -y HOST:PORT, --extractor-proxy HOST:PORT</span><br><span class="line">                        Use an HTTP proxy for extracting only</span><br><span class="line">  --no-proxy            Never use a proxy</span><br><span class="line">  -s HOST:PORT or USERNAME:PASSWORD@HOST:PORT, --socks-proxy HOST:PORT or USERNAME:PASSWORD@HOST:PORT</span><br><span class="line">                        Use an SOCKS5 proxy for downloading</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        里面也包含了可用参数和命令。<br>​        其中比较重要的有：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-i</td><td>显示资源信息，比如说格式、清晰度、大小等</td></tr><tr><td>-i</td><td>指定下载或查看的 url，有时候可以省略 - u 直接加上 url</td></tr><tr><td>-o</td><td>设置输出文件夹，即保存路径，若不指定，则保存在当前工作目录</td></tr><tr><td>-O</td><td>设置文件名，可采用默认文件名</td></tr><tr><td>-f</td><td>强制覆盖已存在的文件</td></tr><tr><td>-l</td><td>优先下载整个列表</td></tr><tr><td>-P</td><td>使用密码（若访问视频需要密码）</td></tr><tr><td>-t</td><td>设置超时时间，单位是秒</td></tr><tr><td>-c</td><td>使用 cookie，加载 cookies.txt 或者 cookies.sqlite</td></tr></tbody></table><h2 id="使用"><a class="markdownIt-Anchor" href="#使用">#</a> 使用</h2><p>​        好的终于是安装成功了，可以愉快的开始使用了。</p><p>​        我们这里以蛋黄派 2021.9.7 更新的视频为例来下载。</p><p>​        输入如下语句来进行下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get https://www.bilibili.com/video/BV1Eb4y1U7hY?spm_id_from=333.851.b_7265636f6d6d656e64.1</span><br></pre></td></tr></table></figure><p>​        之后就可以在默认路径下找到你下载的视频啦～</p><p><img src="https://s3.bmp.ovh/imgs/2021/09/fbaaaa0c69a96bb6.png" alt=""></p><p>​        下载成功的话会有一个 MP4 文件和一个 XML 文件，分别对应视频和弹幕。</p><p>​        在这个步骤部分小伙伴会有疑问：<strong>为森么我下载下来是 FLV 文件和 XML 文件呢</strong>？</p><p>我们可以通过 -i 指令来查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get -i https://www.bilibili.com/video/BV1Eb4y1U7hY?spm_id_from=333.851.b_7265636f6d6d656e64.1</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2021/09/4e6e16c7e83a9394.png" alt=""></p><p>​        在这里我们可以找到 1080p 的 MP4 格式的下载指令，于是我们删除之前下载的文件，输入如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get --format=dash-flv https://www.bilibili.com/video/BV1Eb4y1U7hY?spm_id_from=333.851.b_7265636f6d6d656e64.1</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2021/09/af6db85327aa8ef7.png" alt=""></p><p>​        在这一步之后，有人（比如我）会发现：<strong>咦？为森么下载了两个 MP4 文件，是原视频的音频和视频分开的那种</strong>。</p><p>​        这里就要提到一个叫<strong> FFmpeg</strong> 的东西了，它可以解决这个问题，具体解决方法建议自行百度 / 必应。（主要是因为我的问题是萱琪姐姐帮忙解决的，具体操作我也不是很清楚</p><p>​       还要推荐一个叫 Windows powerShell 的东西，这个也比较好用。在文件夹处 shift + 邮件即可呼出，我们可以通过 Windows powerShell 来使用 git 和 cmd，当然使用 Windows powerShell 配合 you-get 下载也十分的方便。</p><p>​        最后附上 Windows powerShell 的下载界面。<br><img src="https://s3.bmp.ovh/imgs/2021/09/5f81eae2d969af1a.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大正方形</title>
      <link href="/passages/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
      <url>/passages/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="最大正方形"><a class="markdownIt-Anchor" href="#最大正方形">#</a> <strong>最大正方形</strong></h1><p>​大一 -&gt; 大二暑期算法作业</p><p>​<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p><h2 id="看到题目的感想"><a class="markdownIt-Anchor" href="#看到题目的感想">#</a> <strong>看到题目的感想</strong></h2><p>​寻找最大正方形是小时候经常玩的一种游戏，说是可以锻炼观察力与判断力什么的，现在也会有家长带着小孩玩这个游戏，不过不是很多。</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> <strong>题目描述</strong></h2><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" alt=""></p><p>输入：matrix = [[“1”,“0”,“1”,“0”,“0”],[“1”,“0”,“1”,“1”,“1”],[“1”,“1”,“1”,“1”,“1”],[“1”,“0”,“0”,“1”,“0”]]<br> 输出：4</p><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg" alt=""></p><p>输入：matrix = [[“0”,“1”],[“1”,“0”]]<br> 输出：1</p><p>示例 3：</p><p>输入：matrix = [[“0”]]<br> 输出：0</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximal-square">https://leetcode-cn.com/problems/maximal-square</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答">#</a> <strong>题目解答</strong></h2><p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p><h3 id="1-暴力计算"><a class="markdownIt-Anchor" href="#1-暴力计算">#</a> 1、<strong>暴力计算</strong></h3><h4 id="1解题思路"><a class="markdownIt-Anchor" href="#1解题思路">#</a> <strong>（1）解题思路</strong></h4><p>语言描述不是很棒，大家凑活看叭，┭┮﹏┭┮</p><p>想了想，暴力计算是最简单直观的做法，具体做法如下：</p><ol><li>遍历矩阵中的元素，当遇到 1 时，将该元素作为正方形的左上角的位置。</li><li>确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围 - 不能超出矩阵的行和列），在该范围内寻找只包含 1 的最大正方形；</li><li>每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 1。（方便起见，需要先判断选取的点的右下角的点是否为 1。若不是，则跳出本次循环并储存当前的最大正方形，找到下一个元素是 1 的节点作为左上角点，重复 2、3 步；若是，则判断下一行和右一列的其他元素是否都为 1 <strong>（注：这里不是下一行右一列的所有元素，而是初始左上角和以当前点为右下角的正方形的范围内的点，如下图）</strong> ，若不都为 1，则跳出本次循环并储存当前的最大正方形，找到下一个元素是 1 的节点作为左上角点，重复 2、3 步；若都为 1，则继续第 3 步）。</li></ol><h4 id="2代码"><a class="markdownIt-Anchor" href="#2代码">#</a> <strong>（2）代码</strong></h4><p><strong>配合题目链接食用</strong></p><h5 id="java"><a class="markdownIt-Anchor" href="#java">#</a> java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123; <span class="comment">// 没有矩阵或矩阵大小为0时</span></span><br><span class="line">            <span class="keyword">return</span> maxSide;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123; <span class="comment">// 遇到一个 1 作为正方形的左上角</span></span><br><span class="line">                    maxSide = Math.max(maxSide, <span class="number">1</span>); <span class="comment">// 更新可能的最大正方形边长</span></span><br><span class="line">                    <span class="keyword">int</span> currentMaxSide = Math.min(rows - i, columns - j); <span class="comment">// 当前最大正方形边长</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; currentMaxSide; k++) &#123; <span class="comment">// 判断新增的一行一列是否均为 1</span></span><br><span class="line">                        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + k][j + k] == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 判断右下角的点</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123; <span class="comment">// 判断下一行右一列</span></span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + k][j + m] == <span class="string">&#x27;0&#x27;</span> || matrix[i + m][j + k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 若判断都是1，则更新，不是则退出本次循环，寻找下一个左上角</span></span><br><span class="line">                            maxSide = Math.max(maxSide, k + <span class="number">1</span>); <span class="comment">// 更新可能的最大正方形边长</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/185126/31/21226/19810/61284443E0d3f0dfd/b2db3058f56d7f8b.png" alt="image-20210827093335340.png"></p><h4 id="3总结"><a class="markdownIt-Anchor" href="#3总结">#</a> <strong>（3）总结</strong></h4><p>​暴力的思路比其他方法简单（但是我的描述可能会有些不顺畅），但是效率不高。</p><h3 id="2-dp算法动态规划来自题解"><a class="markdownIt-Anchor" href="#2-dp算法动态规划来自题解">#</a> <strong>2、dp 算法（动态规划）（来自题解）</strong></h3><p>​又一次见到了动态规划，还是有无从下手的感觉。</p><h4 id="1解题思路-2"><a class="markdownIt-Anchor" href="#1解题思路-2">#</a> <strong>（1）解题思路</strong></h4><p>​方法一虽然直观，但是时间复杂度太高，有没有办法降低时间复杂度呢？</p><p>可以使用动态规划降低时间复杂度。我们用 dp (i,j) 表示以 (i,j) 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp (i,j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 dp 中的每个元素值呢？对于每个位置 (i,j)，检查在矩阵中该位置的值：</p><ul><li><p>如果该位置的值是 0，则 dp (i,j)=0，因为当前位置不可能在由 1 组成的正方形中；</p></li><li><p>如果该位置的值是 11，则 dp (i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p><p>​dp(i,j) = min( dp(i−1,j) , dp(i−1,j−1) , dp(i,j−1) ) + 1</p><p>如果读者对这个状态转移方程感到不解，<a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-2/">可以参考 1277. 统计全为 1 的正方形子矩阵的官方题解</a>，其中给出了详细的证明。</p></li></ul><p>此外，还需要考虑边界条件。如果 i 和 j 中至少有一个为 0，则以位置 (i, j)(i,j) 为右下角的最大正方形的边长只能是 11，因此 dp (i,j)=1。</p><p>以下用一个例子具体说明。原始矩阵如下。</p><p>0 1 1 1 0<br>1 1 1 1 0<br>0 1 1 1 1<br>0 1 1 1 1<br>0 0 1 1 1<br> 对应的 dp 值如下。</p><p>0 1 1 1 0<br>1 1 2 2 0<br>0 1 2 3 1<br>0 1 2 3 2<br>0 0 1 2 3</p><p>下图也给出了计算 dp 值的过程。</p><p><img src="https://assets.leetcode-cn.com/solution-static/221/221_fig1.png" alt=""></p><h4 id="2代码-2"><a class="markdownIt-Anchor" href="#2代码-2">#</a> <strong>（2）代码</strong></h4><p><strong>配合题目链接食用</strong></p><h5 id="java-2"><a class="markdownIt-Anchor" href="#java-2">#</a> Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxSide;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h5 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(columns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = <span class="built_in">max</span>(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="3总结-2"><a class="markdownIt-Anchor" href="#3总结-2">#</a> <strong>（3）总结</strong></h4><p>​动态规划解题的思想还需要学习，现在还上不了手。</p><h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> <strong>题目总结</strong></h2><p>​这次的题目是数最大正方形，暴力方法还是最先考虑到的，之后菜知道动态规划也可以解决。（动态规划现在还属实不会）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>太平洋大西洋水流问题</title>
      <link href="/passages/%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/"/>
      <url>/passages/%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="太平洋大西洋水流问题"><a class="markdownIt-Anchor" href="#太平洋大西洋水流问题">#</a> 太平洋大西洋水流问题</h1><p>​大一 -&gt; 大二暑期算法作业</p><p>​<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p><h2 id="看到题目的感想"><a class="markdownIt-Anchor" href="#看到题目的感想">#</a> 看到题目的感想</h2><p>​刚看到这个题目的时候感觉他不是很熟悉，没有见过类似的题目，也没有见过类似的场景，感觉有点意思。</p><p>​题目不算很长，但感觉难度不小。</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。</p><p><strong>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</strong></p><p>请找出那些水流<strong>既可以</strong>流动到 “太平洋”，<strong>又能</strong>流动到 “大西洋” 的陆地单元的坐标。</p><p>提示：</p><p>输出坐标的<strong>顺序不重要</strong><br> m 和 n 都<strong>小于 150</strong></p><p>示例：</p><p>给定下面的 5x5 矩阵:</p><dl><dt>太平洋～~   ~   ~   ~</dt><dd>1   2   2   3  (5) /</dd><dd>3   2   3  (4) (4) /</dd><dd>2   4  (5)  3   1  /</dd><dd>(6) (7)  1   4   5  /</dd><dd>(5)  1   1   2   4  /</dd></dl><p>​            /    /    /    /    /   大西洋</p><p>返回:</p><p>[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元). （序号先左后上）</p><h2 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答">#</a> 题目解答</h2><p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p><h3 id="逆流而上"><a class="markdownIt-Anchor" href="#逆流而上">#</a> 逆流而上</h3><p>​最开始的名字叫<strong>逆着水流向上找</strong>，后面才想起来有<strong>逆流而上</strong>这个成语，才改了名字。</p><p>​最开始浮现的思路是想暴力解题，后来发现暴力解题太过于麻烦，效率也不高，索性就放弃了。之后才有的现在这个想法。</p><h3 id="1解题思路"><a class="markdownIt-Anchor" href="#1解题思路">#</a> （1）解题思路</h3><p>​本题找的是<strong>能够让水流留到两片水域</strong>的陆地单元的位置坐标，那么既然水能过去，那我们反过来找，<strong>分别找到两个水域的水能流到的地方，之后取交集</strong>，就得到了我们想要的答案。</p><h3 id="2代码"><a class="markdownIt-Anchor" href="#2代码">#</a> （2）代码</h3><p><strong>配合题目链接食用</strong></p><h4 id="java"><a class="markdownIt-Anchor" href="#java">#</a> Java</h4><p><strong>注：这个代码在 idea 上可以正常运行，但在力扣上会有报错。报错如下：</strong></p><p>error: incompatible types: List&lt;int[]&gt; cannot be converted to List&lt;List<Integer>&gt; [in <strong>Driver</strong>.java]</p><p>List&lt;List<Integer>&gt; ret = new Solution().pacificAtlantic(param_1);</p><p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/197276/28/5074/29323/612842a4E395ba9f9/a2ea88eb469c810c.png" alt="image-20210827093245188.png"></p><p><strong>List &amp; ArrayList：<a href="https://www.jianshu.com/p/25aa92f8d681">https://www.jianshu.com/p/25aa92f8d681</a> 来源：简书</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">                List&lt;<span class="keyword">int</span>[]&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 储存最终数据</span></span><br><span class="line">                <span class="keyword">int</span> m = matrix.length; <span class="comment">// 获取矩阵一边的长度</span></span><br><span class="line">                <span class="keyword">if</span>(m &lt; <span class="number">1</span>) <span class="keyword">return</span> ret; <span class="comment">// 矩阵大小为0时</span></span><br><span class="line">                <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length; <span class="comment">// 获取矩阵另一边的长度</span></span><br><span class="line">                <span class="keyword">boolean</span>[][] Pacific = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n]; <span class="comment">// 太平洋的</span></span><br><span class="line">                <span class="keyword">boolean</span>[][] Atlantic = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n]; <span class="comment">// 大西洋的</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123; <span class="comment">// 递归判断一条边</span></span><br><span class="line">                    dfs(matrix, i, <span class="number">0</span>, Pacific, matrix[i][<span class="number">0</span>]);</span><br><span class="line">                    dfs(matrix, i, n-<span class="number">1</span>, Atlantic, matrix[i][n-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 递归判断另一条边</span></span><br><span class="line">                    dfs(matrix, <span class="number">0</span>, i, Pacific, matrix[<span class="number">0</span>][i]);</span><br><span class="line">                    dfs(matrix, m-<span class="number">1</span>, i, Atlantic, matrix[m-<span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123; <span class="comment">// 取交集得到最终结果</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                        <span class="keyword">if</span>(Pacific[i][j] &amp;&amp; Atlantic[i][j])</span><br><span class="line">                            ret.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;); <span class="comment">// 放入数据</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret; <span class="comment">// 返回结果</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 超出边界 或 判断过是可以的 或 不能继续向上流动，则返回</span></span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= m.length || y &gt;= m[<span class="number">0</span>].length || visited[x][y] || m[x][y] &lt; pre)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                visited[x][y] = <span class="keyword">true</span>; <span class="comment">// 可以向上流</span></span><br><span class="line">                dfs(m, x+<span class="number">1</span>, y, visited, m[x][y]); <span class="comment">// 递归判断相邻行或列</span></span><br><span class="line">                dfs(m, x-<span class="number">1</span>, y, visited, m[x][y]); <span class="comment">// 递归判断相邻行或列</span></span><br><span class="line">                dfs(m, x, y+<span class="number">1</span>, visited, m[x][y]); <span class="comment">// 递归判断相邻行或列</span></span><br><span class="line">                dfs(m, x, y-<span class="number">1</span>, visited, m[x][y]); <span class="comment">// 递归判断相邻行或列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3总结"><a class="markdownIt-Anchor" href="#3总结">#</a> （3）总结</h3><p>​这个解题思路来看的话感觉还是可以的，就是会有一些<strong>奇怪的 bug</strong>，不知道怎么肥四。</p><h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2><p>​这个题目难度比之前的大一些，不好做，包括写的时候也查了一些资料（<strong>运用不熟练</strong>），好在最后搞出来了（虽然有一些奇怪的 bug）。</p><p>​（<strong>递归真香</strong>）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗马数字转整数</title>
      <link href="/passages/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/passages/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="罗马数字转整数"><a class="markdownIt-Anchor" href="#罗马数字转整数">#</a> 罗马数字转整数</h1><p>​大一 -&gt; 大二暑期算法作业</p><p>​<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p><h2 id="看到题目的想法"><a class="markdownIt-Anchor" href="#看到题目的想法">#</a> 看到题目的想法</h2><p>​这个题目看起来挺有意思的，但是好像不好解。</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ol><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ol><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><p>输入: “III”<br> 输出: 3</p><p><strong>示例 2:</strong></p><p>输入: “IV”<br> 输出: 4</p><p><strong>示例 3:</strong></p><p>输入: “IX”<br> 输出: 9</p><p><strong>示例 4:</strong></p><p>输入: “LVIII”<br> 输出: 58</p><p>解释: L = 50, V= 5, III = 3.</p><p><strong>示例 5:</strong></p><p>输入: “MCMXCIV”<br> 输出: 1994<br> 解释: M = 1000, CM = 900, XC = 90, IV = 4.</p><p><strong>提示：</strong></p><ol><li>1 &lt;= s.length &lt;= 15</li><li>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)</li><li>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内</li><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li><li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li><li>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/roman-to-integer">https://leetcode-cn.com/problems/roman-to-integer</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答">#</a> 题目解答</h2><p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p><h3 id="1暴力解题"><a class="markdownIt-Anchor" href="#1暴力解题">#</a> 1. 暴力解题</h3><h4 id="1解题思路"><a class="markdownIt-Anchor" href="#1解题思路">#</a> （1）解题思路</h4><p>​想了想还是选择了暴力解题（<strong>比较简单</strong>。</p><p>​将特殊情况转为另一个<strong>不在   I， V， X， L，C，D 和 M</strong>  中的单独的字母；再重新挨个求和。</p><h4 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码">#</a> （2） 代码</h4><p>​<strong>配合题目链接食用</strong></p><p><strong>C++</strong></p><p><strong>earse：</strong><a href="https://www.cnblogs.com/ylwn817/articles/1967689.html">C++ 中 string erase 函数的使用 (转载) - jackdesk - 博客园 (cnblogs.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++) <span class="comment">// 将特殊情况转换</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;I&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;I&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;X&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;X&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;C&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;C&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++) <span class="comment">// 挨个求和</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(s[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">5</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">50</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">100</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">500</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">9</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">40</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">90</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">400</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">900</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/177610/31/20874/22139/612842cbEa0f226ee/d8b14650ce07f5ff.png" alt="image-20210827092938870.png"></p><h4 id="3总结"><a class="markdownIt-Anchor" href="#3总结">#</a> （3）总结</h4><p>​暴力计算的方法想起来并不复杂，但是写起来麻烦（重复、相似比较多），而且代码的性能也不高，所以还是不建议采用暴力算法。</p><h3 id="2模拟来自题解"><a class="markdownIt-Anchor" href="#2模拟来自题解">#</a> 2. 模拟（来自题解）</h3><p>​很巧妙的一种方法，看完之后情不自禁的妙了起来。</p><p>​<strong>妙<sub>啊</sub>～</strong></p><p><strong>官方题解：<a href="https://leetcode-cn.com/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/">https://leetcode-cn.com/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/</a></strong></p><h4 id="1解题思路-2"><a class="markdownIt-Anchor" href="#1解题思路-2">#</a> （1）解题思路</h4><p>** 通常情况下，罗马数字中小的数字在大的数字的右边。** 若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。</p><p>例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。</p><p>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，<strong>若一个数字右侧的数字比它大，则将该数字的符号取反。</strong></p><p>例如 XIV 可视作 X−I+V=10−1+5=14。</p><h4 id="2代码"><a class="markdownIt-Anchor" href="#2代码">#</a> （2）代码</h4><p>这里用到了<strong> map</strong> 这个东西，可以看看</p><h5 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C++</h5><p><strong>C++map： <a href="https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html">https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html</a>  来源：某 C ++ 文档</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; symbolValues = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = symbolValues[s[i]];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; value &lt; symbolValues[s[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">                ans -= value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/196645/13/19919/22179/612842e5E892666a7/8ed9cac439b0d859.png" alt="image-20210827093012125.png"></p><h5 id="java"><a class="markdownIt-Anchor" href="#java">#</a> Java</h5><p><strong>java map：<a href="https://blog.csdn.net/qq_29373285/article/details/81487594">https://blog.csdn.net/qq_29373285/article/details/81487594</a></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; symbolValues = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = symbolValues.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; value &lt; symbolValues.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                ans -= value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/196645/13/19919/22179/612842e5E892666a7/8ed9cac439b0d859.png" alt="image-20210827093028025.png"></p><h4 id="3总结-2"><a class="markdownIt-Anchor" href="#3总结-2">#</a> （3）总结</h4><p>​很巧妙地方法，是我没想到的，很棒。</p><h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2><p>​听题解说是很经典的字符串匹配的题目，感觉很有意思，就是没有想到巧妙地方法。需要再接再厉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬楼梯</title>
      <link href="/passages/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/passages/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="爬楼梯"><a class="markdownIt-Anchor" href="#爬楼梯">#</a> 爬楼梯</h1><p>​大一 -&gt; 大二暑期算法作业</p><p>​<strong>本文档中有对动态规划的解读（来自题解）</strong></p><p>​<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p><h2 id="看到题目的想法"><a class="markdownIt-Anchor" href="#看到题目的想法">#</a> 看到题目的想法</h2><p>​这是一道比较经典的题目，之前好像见过类似的题目，所以上手还是有一些思路的。</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意</strong>：给定 n 是一个正整数。</p><p><strong>示例 1：</strong></p><p>输入： 2<br> 输出： 2<br> 解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol><p><strong>示例 2：</strong></p><p>输入： 3<br> 输出： 3<br> 解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li><li></li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs">https://leetcode-cn.com/problems/climbing-stairs</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答">#</a> 题目解答</h2><p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p><h3 id="1动态规划"><a class="markdownIt-Anchor" href="#1动态规划">#</a> 1. 动态规划</h3><h4 id="1解题思路"><a class="markdownIt-Anchor" href="#1解题思路">#</a> （1）解题思路</h4><p>​       刚开始事项用递归写一下的，后来发现递归会超时，于是选用了动态规划。</p><p>​       这是一道典型的动态规划题，<strong>由于每步只能走一或两阶台阶，所以到达这一阶的方法数是 跨一阶到达 + 跨两阶到达</strong>。所以走到第一阶有一种方法，走到第二阶有两种方法，<strong>从第三阶开始</strong>，每一阶的方法数等于前两阶的方法数的代数和（跨一阶到达 + 跨两阶到达）（ps：可以用数组储存，但没必要，因为我们需要的是最终结果。</p><p>​       （有斐波那契那味了。</p><h4 id="2代码"><a class="markdownIt-Anchor" href="#2代码">#</a> （2）代码</h4><p>​由于思路比较简单，也是顺利的写出了代码。（<strong>配合题目链接食用</strong>）</p><h5 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 遍历计算直到算出想要的结果</span></span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r; <span class="comment">// 返回想要的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img14.360buyimg.com/ddimg/jfs/t1/178109/1/21048/19824/612843b1Ebbddf701/64ca411d00d898bb.png" alt="image-20210827092530062.png"></p><h5 id="java"><a class="markdownIt-Anchor" href="#java">#</a> Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 遍历计算直到算出想要的结果</span></span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r; <span class="comment">// 返回想要的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/192688/38/20306/19931/612843c8Ead5d61e5/fbbd50516680a252.png" alt="image-20210827092554179.png"></p><h5 id="c-2"><a class="markdownIt-Anchor" href="#c-2">#</a> C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 遍历计算直到算出想要的结果</span></span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r; <span class="comment">// 返回想要的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/181789/27/21163/20033/612843d9E4033bcc2/15eb1d8b958eb431.png" alt="image-20210827092619237.png"></p><h4 id="3总结"><a class="markdownIt-Anchor" href="#3总结">#</a> （3）总结</h4><p>​这样直接计算的方法思路很简单，但是问题是计算的结果无法保留，用一次就要重新计算一次，十分的不方便。</p><h3 id="2斐波那契数列"><a class="markdownIt-Anchor" href="#2斐波那契数列">#</a> 2. 斐波那契数列</h3><h4 id="1解题思路-2"><a class="markdownIt-Anchor" href="#1解题思路-2">#</a> （1）解题思路</h4><p>​不难看出，此题的数据就是我们熟悉的<strong>斐波那契数列</strong>，因此我们可以<strong>借助斐波那契数列的通项公式</strong>来快速算出我们想要的结果（前一种解发是从头计算出来的，台阶数较大时效率低  。</p><p>​这种方法简单粗暴，就是通项公式不好记。</p><p>​通项公式的推导过程就不写了，可以去题解里面看一下。+</p><p><strong>题目链接（去看官方题解）：<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/">https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</a></strong></p><h4 id="2代码-2"><a class="markdownIt-Anchor" href="#2代码-2">#</a> （2）代码</h4><h5 id="c-3"><a class="markdownIt-Anchor" href="#c-3">#</a> C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibn = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>); <span class="comment">// 斐波那契数列通项公式</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">round</span>(fibn / sqrt5); <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/186997/39/20254/20066/612843eaE3f9c5968/88a470ca748a910b.png" alt="image-20210827092637917.png"></p><h5 id="java-2"><a class="markdownIt-Anchor" href="#java-2">#</a> Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibn = Math.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - Math.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>); <span class="comment">// 斐波那契数列通项公式</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.round(fibn / sqrt5); <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/197749/9/5098/19966/612843f7E025f4b3d/8647b6a5672410fd.png" alt="image-20210827092704192.png"></p><h5 id="c-4"><a class="markdownIt-Anchor" href="#c-4">#</a> C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">double</span> fibn = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>); <span class="comment">// 斐波那契数列通项公式</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) round(fibn / sqrt5); <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img12.360buyimg.com/ddimg/jfs/t1/197249/18/5090/19858/61284418E58cc0b79/4adf3d43edded4c7.png" alt="image-20210827092720313.png"></p><h4 id="3总结-2"><a class="markdownIt-Anchor" href="#3总结-2">#</a> （3）总结</h4><p>​这种解决办法方便快捷，也不会浪费多余的时间空间来计算，比较好用。<strong>（缺点就是通项公式并不容易记住）</strong></p><h3 id="3矩阵快速幂来自题解"><a class="markdownIt-Anchor" href="#3矩阵快速幂来自题解">#</a> 3. 矩阵快速幂（来自题解）</h3><h4 id="1解题思路-代码"><a class="markdownIt-Anchor" href="#1解题思路-代码">#</a> （1）解题思路 + 代码</h4><p>​说实话，行看到这种方法的时候<strong>感觉回到了线性代数的课堂上</strong>，又是熟悉的矩阵操作，让人头疼</p><p>​具体的解题思路和代码就不搬过来了，可以去<strong>官方题解</strong>下查看。</p><p><strong>题目链接（去看官方题解）：<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/">https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</a></strong></p><h4 id="2总结"><a class="markdownIt-Anchor" href="#2总结">#</a> （2）总结</h4><p>​<strong>利用矩阵运算解题</strong>的方法还是没见过的，对我来说比较新奇，还需要认真的研究研究。</p><h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2><p>​这道题的难度中规中矩，但也会有很奇妙很方便的解决方案，也让我知道了<strong>运用矩阵运算来解题</strong>的方法，很棒。</p><h2 id="拓展动态规划摘自题解"><a class="markdownIt-Anchor" href="#拓展动态规划摘自题解">#</a> 拓展（动态规划）（摘自题解）</h2><p>​<strong>本部分附带原作者对本题的总结</strong></p><p>不少同学对动态规划还处于朦胧状态，我特意<strong>录了一期视频</strong>，讲一讲<strong>动态规划解题方法论</strong>，这里详细介绍了动规五部曲，相信结合本篇题解，会对你学习动态规划有所帮助。</p><p><strong>视频链接：<a href="https://www.bilibili.com/video/BV13Q4y197Wg">https://www.bilibili.com/video/BV13Q4y197Wg</a>)</strong></p><p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目 AC 之后，都不太清楚 dp [i] 表示的是什么。</p><p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中。</strong></p><p>状态转移公式（递推公式）是很重要，但动规<strong>不仅仅只有</strong>递推公式。</p><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p><ol><li>确定 dp 数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp 数组如何初始化</li><li>确定遍历顺序</li><li>举例推导 dp 数组</li></ol><p>一些同学可能想<strong>为什么要先确定递推公式，然后在考虑初始化</strong>呢？</p><p><strong>因为一些情况是递推公式决定了 dp 数组要如何初始化！</strong></p><p>后面的讲解中我都是围绕着这五点来进行讲解。</p><p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p><p>其实 确定递推公式 仅仅是解题里的一步而已！</p><p>一些同学知道递推公式，但搞不清楚 dp 数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p><p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p><h3 id="动态规划应该如何debug"><a class="markdownIt-Anchor" href="#动态规划应该如何debug">#</a> 动态规划应该如何 debug</h3><p>相信动规的题目，很大部分同学都是这样做的。</p><p>看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp 数组的初始化，递归公式，遍历顺序，处于一种黑盒的理解状态。</p><p><strong>写动规题目，代码出问题很正常！</strong></p><p><strong>找问题的最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><p>一些同学对于 dp 的学习是黑盒的状态，就是不清楚 dp 数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。</p><p>这是一个很不好的习惯！</p><p><strong>做动规的题目，写代码之前一定要把状态转移在 dp 数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。</strong></p><p>然后再写代码，如果代码没通过就打印 dp 数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p><p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了。</strong></p><p>这也是我为什么在动规五步曲里强调推导 dp 数组的重要性。</p><p>举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？</p><p>发出这样的问题之前，其实可以自己先思考这三个问题：</p><ul><li>这道题目我举例推导状态转移公式了么？</li><li>我打印 dp 数组的日志了么？</li><li>打印出来了 dp 数组和我想的一样么？</li></ul><p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历 dp 数组的顺序。</p><p>然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。</p><p><strong>注意这里不是说不让大家问问题哈， 而是说问问题之前要有自己的思考，问题要问到点子上！</strong></p><p><strong>大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！</strong></p><p>如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。</p><p>所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h3><p>这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何 debug。</p><p>动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。</p><p>在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的 01 背包，leetcode 上的题目都是 01 背包的应用，而没有纯 01 背包的问题，那么就需要在把对应的理论知识讲解一下。</p><p>大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。</p><p>这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容，大家要重视起来哈。</p><h3 id="原作者对本题总结"><a class="markdownIt-Anchor" href="#原作者对本题总结">#</a> 原作者对本题总结</h3><p>这道题目和动态规划：斐波那契数题目基本是一样的，但是会发现本题相比动态规划：斐波那契数难多了，为什么呢？</p><p>关键是 动态规划：斐波那契数 题目描述就已经把动规五部曲里的递归公式和如何初始化都给出来了，剩下几部曲也自然而然的推出来了。</p><p>而本题，就需要逐个分析了，大家现在应该初步感受出关于动态规划，你该了解这些！里给出的动规五部曲了。</p><p>简单题是用来掌握方法论的，例如昨天斐波那契的题目够简单了吧，但昨天和今天可以使用一套方法分析出来的，这就是方法论！</p><p>所以不要轻视简单题，那种凭感觉就刷过去了，其实和没掌握区别不大，只有掌握方法论并说清一二三，才能触类旁通，举一反三哈！</p><h3 id="原作者的题目解答"><a class="markdownIt-Anchor" href="#原作者的题目解答">#</a> 原作者的题目解答</h3><p><strong>原作者的题目解答：<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/dai-ma-sui-xiang-lu-dong-tai-gui-hua-jin-y1hw/">https://leetcode-cn.com/problems/climbing-stairs/solution/dai-ma-sui-xiang-lu-dong-tai-gui-hua-jin-y1hw/</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的中序遍历</title>
      <link href="/passages/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/passages/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的中序遍历"><a class="markdownIt-Anchor" href="#二叉树的中序遍历">#</a> 二叉树的中序遍历</h1><p>​大一 -&gt; 大二暑期算法作业</p><p>​<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p><h2 id="看到题目的感想"><a class="markdownIt-Anchor" href="#看到题目的感想">#</a> 看到题目的感想</h2><p>​被离散数学<strong>折磨</strong>之后看见树就会想到离散数学，虽然学习离散数学的时候老师<strong>教过中序遍历</strong>，但是看到这个题的时候还是<strong>没有想起来</strong>中序遍历是个啥，索性就去搜索了一下（快进到被老师打死）。</p><p>​附上百度百科链接：</p><p>​<strong>中序遍历：<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">https://baike.baidu.com/item/ 中序遍历</a></strong></p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><p>输入：root = [1,null,2,3]<br> 输出：[1,3,2]</p><p><strong>示例 2：</strong></p><p>输入：root = []<br> 输出：[]</p><p><strong>示例 3：</strong></p><p>输入：root = [1]<br> 输出：[1]</p><p><strong>示例 4：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img"></p><p>输入：root = [1,2]<br> 输出：[2,1]</p><p><strong>示例 5：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img"></p><p>输入：root = [1,null,2]<br> 输出：[1,2]</p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内<br> - 100 &lt;= Node.val &lt;= 100</p><p>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a></p><h2 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答">#</a> 题目解答</h2><p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p><h3 id="1递归算法"><a class="markdownIt-Anchor" href="#1递归算法">#</a> 1. 递归算法</h3><p>利用递归的思想解题也是老朋友了，在之前的算法题里面有过接触，所以并不是很难理解。</p><h4 id="1解题思路"><a class="markdownIt-Anchor" href="#1解题思路">#</a> （1）解题思路</h4><p>​在解题的时候，了解到了一个名叫 <strong>vector</strong> 的东西，可以理解为 C++ 和 Java 中的一种动态数组。记得第一次听到这个名词的时候还是在翁恺老师的《C 语言程序设计》这门课上听到的，想想还真是怀念。（跑远了</p><p>附上一些链接（<strong>配合梯子一起食用</strong>）：</p><p><strong>vector：内存在堆上</strong></p><p>​    <strong>注意：vector 每添加一次都会把之前的全复制一遍，所以效率并不高。</strong></p><p>​    <strong>1）</strong> <strong><a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-160">https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-160</a>  来源：Microsoft C++、C 和汇编程序文档</strong></p><p>​    <strong>2） <a href="https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/package-summary.html">https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/package-summary.html</a>  来源：Java 官方文档里的包（纯英文比较难顶</strong></p><p>​    <strong>3） <a href="https://baike.baidu.com/item/Vector/3330482">https://baike.baidu.com/item/Vector/3330482</a> 来源：百度百科</strong></p><p>​    <strong>4） <a href="https://www.w3cschool.cn/cpp/cpp-i6da2pq0.html">https://www.w3cschool.cn/cpp/cpp-i6da2pq0.html</a>  来源：某不知名 C++ 教程</strong></p><p>​    <strong>《C 语言程序设计》：<a href="https://www.icourse163.org/learn/ZJU-9001?tid=9001#/learn/announce">https://www.icourse163.org/learn/ZJU-9001?tid=9001#/learn/announce</a>  来源：中国大学 MOOC</strong></p><p>​本题可以通过递归思想对给出的二叉树的<strong>左子树、根节点、右子树依次进行遍历（中序遍历）</strong>，并将各个数据存放在设置好的 vector<int>中（由于 vector 是<strong>动态分配内存</strong>的，所以比用担心大小会不够用），最后即可得到该二叉树的中序遍历。</p><h4 id="2代码"><a class="markdownIt-Anchor" href="#2代码">#</a> （2）代码</h4><p>​解题代码如下（<strong>配合题目链接食用</strong>）：</p><h5 id="c"><a class="markdownIt-Anchor" href="#c">#</a> <strong>C++</strong></h5><p><strong>有一种比较好用的 C++ 容器，比 vector 好用，只是不能自增。（本题未使用）</strong></p><p><strong>array：内存在栈上</strong></p><p><strong>array： <a href="http://c.biancheng.net/view/6688.html">http://c.biancheng.net/view/6688.html</a> 来源：C 语言中文网</strong></p><p><strong>array： <a href="https://www.bilibili.com/video/BV18b4y1X7EB?from=search&amp;seid=11718690349134275715">https://www.bilibili.com/video/BV18b4y1X7EB?from=search&amp;seid=11718690349134275715</a> 来源：哔哩哔哩（是一个油管的小哥哥，讲的很棒，圈粉了）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123; <span class="comment">// 如果碰到空节点，说明该部分遍历已完成，return出去</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, res); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将该节点的值增加在动态数组末尾</span></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, res); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 新建一个int类型的vector,用来存放遍历结果</span></span><br><span class="line">        <span class="built_in">inorder</span>(root, res); <span class="comment">// 从根节点root开始遍历，依次放入值</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回遍历结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><img src="https://img12.360buyimg.com/ddimg/jfs/t1/178612/13/21226/22498/61284220E9e541099/4f61f1de25898a99.png" alt="image-20210827092120481.png"></li></ul><h5 id="java"><a class="markdownIt-Anchor" href="#java">#</a> <strong>Java</strong></h5><p>List &amp; ArrayList 是 Java 中的一种列表。</p><p><strong>List &amp; ArrayList：<a href="https://www.jianshu.com/p/25aa92f8d681">https://www.jianshu.com/p/25aa92f8d681</a> 来源：简书</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// 新建Integer的List来存放数值</span></span><br><span class="line">        inorder(root, res); <span class="comment">// 从根节点root开始遍历，依次将数值放入</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回遍历结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 如果碰到空节点，说明该部分遍历已完成，return出去</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, res); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        res.add(root.val); <span class="comment">// 将该节点的值增加在末尾</span></span><br><span class="line">        inorder(root.right, res); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img14.360buyimg.com/ddimg/jfs/t1/200702/31/3771/22855/6128423eE4f6965f0/3afc9e3dfe9a422d.png" alt="image-20210827092151479.png"></p><h5 id="c来自题解"><a class="markdownIt-Anchor" href="#c来自题解">#</a> <strong>C（来自题解）</strong></h5><p>（C 语言中的动态数组不会玩，于是把题解拿过来）</p><p><strong>C 语言动态数组 <a href="https://www.runoob.com/w3cnote/c-dynamic-array.html">https://www.runoob.com/w3cnote/c-dynamic-array.html</a> 来源：菜鸟教程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* res, <span class="keyword">int</span>* resSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root-&gt;left, res, resSize);</span><br><span class="line">    res[(*resSize)++] = root-&gt;val;</span><br><span class="line">    inorder(root-&gt;right, res, resSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">inorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">501</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    inorder(root, res, returnSize);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="3总结"><a class="markdownIt-Anchor" href="#3总结">#</a> （3）总结</h4><p>​利用递归思想来解题还是比较舒服的，也很好用，适合我这种菜鸡。</p><h3 id="2迭代算法"><a class="markdownIt-Anchor" href="#2迭代算法">#</a> 2. 迭代算法</h3><p><strong>关于迭代算法的基本思想：</strong></p><p><strong>迭代算法 <a href="https://www.cnblogs.com/cs-whut/p/11024564.html">https://www.cnblogs.com/cs-whut/p/11024564.html</a> 来源：博客园</strong></p><p>​迭代算法之前没有接触过，上手有点看不懂。</p><h4 id="1解题思路-2"><a class="markdownIt-Anchor" href="#1解题思路-2">#</a> （1）解题思路</h4><p>​通过迭代 + 栈模型来清楚的展现解题流程（题解中有动画展示，配合食用比较好理解）。</p><h4 id="2代码-2"><a class="markdownIt-Anchor" href="#2代码-2">#</a> （2）代码</h4><p>​解题代码如下（<strong>配合题目链接食用</strong>）：</p><h5 id="c-2"><a class="markdownIt-Anchor" href="#c-2">#</a> <strong>C++</strong></h5><p>C++ 的栈：</p><p><strong>stack <a href="http://c.biancheng.net/view/478.html">http://c.biancheng.net/view/478.html</a> 来源：C 语言中文网</strong></p><p><strong>stack <a href="https://www.apiref.com/cpp-zh/cpp/container/stack.html">https://www.apiref.com/cpp-zh/cpp/container/stack.html</a> 来源：C++ 文档</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 新建一个int类型的vector,用来存放遍历结果</span></span><br><span class="line">        stack&lt;TreeNode*&gt; stk; <span class="comment">// 新建栈</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123; <span class="comment">// 节点有数值 或 栈不为空</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123; <span class="comment">// 当节点有值时</span></span><br><span class="line">                stk.<span class="built_in">push</span>(root); <span class="comment">// 数据入栈</span></span><br><span class="line">                root = root-&gt;left; <span class="comment">// 访问左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>(); <span class="comment">// 找到栈顶数据的节点</span></span><br><span class="line">            <span class="comment">// top()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// pop()：弹出栈顶元素。</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 在vector末尾添加当前节点数据</span></span><br><span class="line">            root = root-&gt;right; <span class="comment">// 访问右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/191173/7/19840/22319/6128425eE22b3e07d/1ca7845e69631535.png" alt="image-20210827092218700.png"></p><h5 id="java-2"><a class="markdownIt-Anchor" href="#java-2">#</a> <strong>Java</strong></h5><p>Java 的栈：</p><p><strong>Deque： <a href="https://www.jianshu.com/p/d78a7c982edb">https://www.jianshu.com/p/d78a7c982edb</a> 来源：简书</strong></p><p><strong>stack：</strong>**</p><p><strong>（1） <a href="https://www.javatpoint.com/java-stack">https://www.javatpoint.com/java-stack</a>  来源：某 Java 文档</strong></p><p><strong>（2） <a href="https://blog.csdn.net/YQYnsmile/article/details/78457539">https://blog.csdn.net/YQYnsmile/article/details/78457539</a>  来源：屑 C 某某 N</strong></p><p><strong>（3） <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Stack.html">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Stack.html</a>  来源：某全英文 Java 文档</strong></p><p>Deque 可以作为堆栈（LIFO 后进先出），此接口优于传统 Stack 类的使用。</p><p><strong>Stack 和 Deque 方法的比较</strong></p><table><thead><tr><th style="text-align:left">栈方法</th><th style="text-align:center">等效 Deque 方法</th></tr></thead><tbody><tr><td style="text-align:left">push(e)</td><td style="text-align:center">addFirst(e)</td></tr><tr><td style="text-align:left">pop()</td><td style="text-align:center">removeFirst()</td></tr><tr><td style="text-align:left">peek()</td><td style="text-align:center">peekFirst()</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// 新建List来保存数据</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); <span class="comment">// 新建栈</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stk.isEmpty()) &#123; <span class="comment">// 节点有数值 或 栈不为空</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123; <span class="comment">// 节点有数值时</span></span><br><span class="line">                stk.push(root); <span class="comment">// 将数据放入栈</span></span><br><span class="line">                root = root.left; <span class="comment">// 访问左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop(); <span class="comment">// pop()：弹出栈顶元素。</span></span><br><span class="line">            res.add(root.val); <span class="comment">// 在List末尾添加当前节点数据</span></span><br><span class="line">            root = root.right; <span class="comment">// 访问右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/177616/31/21117/22717/6128427aE9968827a/f401017322512ef0.png" alt="image-20210827092339328.png"></p><h5 id="c来自题解-2"><a class="markdownIt-Anchor" href="#c来自题解-2">#</a> <strong>C</strong>（来自题解）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">inorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">501</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>** <span class="title">stk</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode*) * <span class="number">501</span>);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            stk[top++] = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk[--top];</span><br><span class="line">        res[(*returnSize)++] = root-&gt;val;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="3总结-2"><a class="markdownIt-Anchor" href="#3总结-2">#</a> （3）总结</h4><p>​利用迭代算法来解题的思想还没有怎么接触过没上手感觉比较难。（<strong>还是递归香</strong>    <strong>确信</strong>）</p><h3 id="3morris-中序遍历来自题解"><a class="markdownIt-Anchor" href="#3morris-中序遍历来自题解">#</a> 3.Morris 中序遍历（来自题解）</h3><p>​这个就是真的闻所未闻了，看了题解，决定搬过来</p><h4 id="1思路与算法"><a class="markdownIt-Anchor" href="#1思路与算法">#</a> （1）思路与算法</h4><ol><li><p><strong>Morris 遍历算法</strong>是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O (1) O (1)。</p><p><strong>Morris 遍历算法</strong>整体步骤如下（假设当前遍历到的节点为 xx）：</p></li><li><p>如果 xx 无左孩子，先将 xx 的值加入答案数组，再访问 xx 的右孩子，即 x  =  x . right。<br>如果 xx 有左孩子，则找到 xx 左子树上最右的节点（<strong>即左子树中序遍历的最后一个节点，xx 在中序遍历中的前驱节点</strong>），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。</p><ul><li>如果 predecessor 的右孩子为空，则将其右孩子指向 xx，然后访问 xx 的左孩子，即  x  =  x . left。</li><li>如果 predecessor 的右孩子不为空，则此时其右孩子指向 xx，说明我们已经遍历完 xx 的左子树，我们将 predecessor 的右孩子置空，将 xx 的值加入答案数组，然后访问 xx 的右孩子，即  x  =  x . right。</li></ul></li><li><p>重复上述操作，直至访问完整棵树。</p><p>4. 其实整个过程我们就多做一步：假设当前遍历到的节点为 xx，将 xx 的左子树中最右边的节点的右孩子指向 xx，这样在左子树遍历完成后我们通过这个指向走回了 xx，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p></li></ol><h4 id="2代码-3"><a class="markdownIt-Anchor" href="#2代码-3">#</a> （2）代码</h4><p><strong>题解链接： <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</a> 来源：力扣</strong></p><p>​不想搬运代码了，就给出了链接。<strong>Morris 中序遍历</strong>是题解中的第三种解法，题解带有动画教程，可以看看。</p><h4 id="3总结-3"><a class="markdownIt-Anchor" href="#3总结-3">#</a> （3）总结</h4><p>​一种没听过的中序遍历算法，搬运题解来的。（主要还是太菜了没玩明白）</p><h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2><p>​此次题目中，出现了<strong>递归算法、迭代算法、Morris 遍历算法</strong>三种解题思路。</p><p>​总的来说，还是递归较好理解，写起来难度稍微低一些；迭代算法初次了解，试了试水；Morris 遍历算法第一次见，还是看题解叭（还是人菜）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO+GitHub搭建博客的小教程</title>
      <link href="/passages/HEXO+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%B0%8F%E6%95%99%E7%A8%8B/"/>
      <url>/passages/HEXO+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%B0%8F%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="如何用hexo搭建自己的博客及美化自己的博客"><a class="markdownIt-Anchor" href="#如何用hexo搭建自己的博客及美化自己的博客">#</a> 如何用 hexo 搭建自己的博客及美化自己的博客</h1><p>这是我配好环境使用 hexo 写的第一篇博客</p><p>这里特别感谢各位大佬们的支持与帮助 ε≡٩(๑&gt;₃&lt;)۶</p><h2 id="配置相关环境"><a class="markdownIt-Anchor" href="#配置相关环境">#</a> 配置相关环境</h2><p>要想创建自己的 hexo 博客需要配置相关的环境（我前几次就经常把环境搞炸），接下来开始配置创建博客所必须的环境</p><p>过程来源: <strong>Gaein nidb</strong>，<strong>Code Sheep</strong>.</p><p>相关视频链接: <a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=4666682153927695444">https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=4666682153927695444</a></p><h3 id="安装nodejs"><a class="markdownIt-Anchor" href="#安装nodejs">#</a> 安装 Node.js</h3><p>可以去<a href="https://www.nodejs.org/"> https://www.nodejs.org</a> 网址下载</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/1.png" alt=""></p><p>选择左边 LTS (长期支持版) 下载，安装时无脑下一步即可</p><p>安装完成之后会有两个组件，如图所示</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/2.png" alt=""></p><p>可以顺带检查一下它们俩的版本，按下键盘的 win + R 键，在弹出面板输入 cmd，打开 dos 命令窗口。</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/3.png" alt=""></p><p>输入 npm -v 和 node -v</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/4.png" alt=""></p><p>我们需要利用 npm 安装镜像包，但是因为国内的下载速度比较慢，所以我们需要下载一个 cnpm 淘宝的源</p><p>在 dos 命令窗口中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>如果安装成功，可以在 dos 命令窗口输入 cnpm 检查一下</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/5.png" alt=""></p><p>然后使用 cnpm 安装 hexo 框架</p><p>在 dos 命令窗口输入 cnpm install -g hexo-cli</p><p>如果安装成功，可以在 dos 命令窗口输入 hexo -v 检查一下</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/6.png" alt=""></p><p>那么你的环境已经配置好了，我们来正式搭建 hexo 博客</p><h2 id="在本地创建hexo的博客"><a class="markdownIt-Anchor" href="#在本地创建hexo的博客">#</a> 在本地创建 hexo 的博客</h2><p>首先我们需要一个存放你博客的文件夹，所以第一步我们需要新建一个文件夹。</p><p>举个栗子：C:\Users\fiower\Documents\blog 这是我的文件夹路径</p><p>我们终于可以创建自己的博客了 (๑╹◡╹)ﾉ”””</p><p>由于本人没有用过 powershell（菜），所以接下来我们使用 dos 命令窗口 (git bash）创建本地博客</p><p>只需要两种方法选一即可 (这里以 dos 命令窗口为例，git bash 和 dos 命令窗口的指令是完全一样的，搭建时没必要纠结使用哪个)</p><h3 id="使用dos命令窗口"><a class="markdownIt-Anchor" href="#使用dos命令窗口">#</a> 使用 dos 命令窗口</h3><p>按下键盘的 win + R 键，在弹出面板输入 cmd，打开 dos 命令窗口。</p><p>这时路径默认是 C:\Users\ 你的用户名字 &gt;</p><p>输入 cd 你的博客所在路径 转入你的博客路径</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/7.png" alt=""></p><h3 id="使用git-bash"><a class="markdownIt-Anchor" href="#使用git-bash">#</a> 使用 git bash</h3><p>在你的博客文件夹下按下右键，点击 git bash</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/8.jpg" alt=""></p><h2 id="开始创建本地博客"><a class="markdownIt-Anchor" href="#开始创建本地博客">#</a> 开始创建本地博客</h2><p>输入 hexo init 并按下回车等待</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/9.png" alt=""></p><p>这时你的目标文件夹就会多出一些文件</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/10.png" alt=""></p><p>那么恭喜你，现在 hexo 博客已经配置完毕了（bushi</p><p>继续在 dos 命令窗口输入 hexo s 并按下回车等待</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/10.png" alt=""></p><p>如图所示，这时候出现了一个 4000 端口的网址</p><p>让我们在浏览器内打开这个网址</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/13.png" alt=""></p><p>我们的第一个本地博客就搭建好了</p><p>但是你的程序还在运行着，这时候需要在 dos 窗口 /git bash 窗口中按下 Ctrl + C 键即可中断本地网址的建立（hexo s 以后会用于博客写入新东西时的调试工作）</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/14.png" alt=""></p><p>如果你没有成功到达这一步，不用害怕，只需要把你创建的文件夹<strong>干掉重来</strong>即可，多试试几次总会成功的</p><h2 id="将hexo博客同步到远端github"><a class="markdownIt-Anchor" href="#将hexo博客同步到远端github">#</a> 将 hexo 博客同步到远端 (Github)</h2><p>我相信你已经非常兴奋而且想要把你的博客让朋友们看到，别急，现在我们就把自己的博客部署到远端</p><p>接下来我们要把自己的博客部署到 Github 上 (毫无疑问需要你的账号，没有的小伙伴需注册)</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/15.png" alt=""></p><p>新建一个仓库</p><p><em><strong>* 注意，用户部署个人博客的 Github 仓库的命名必须符合特定要求 *</strong></em></p><p><em><strong>* 命名格式为：  <a href="http://xn--Github-on9i027mnx4aga157g.github.io">你的 Github 的昵称.github.io</a>*</strong></em></p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/16.png" alt=""></p><p>建立了空仓库之后，我们需要装一个插件</p><p>在命令行中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/17.png" alt=""></p><p>然后用 vscode 打开你的 blog 的根目录_config.yml 文件 (没有安装 vscode 的话也可以选择记事本打开)</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/18.png" alt=""></p><p>由于我没有新建空仓库，放一张 CodeSheep 的图片 (这样获取你部署到远端的网址)</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/19.png" alt="aaa"></p><p>然后在 dos 命令窗口输入 hexo d</p><p>这样你的 hexo 博客就部署到了远端 (所有人都可以用这个网址访问你的博客了)</p><h2 id="美化自己的hexo博客"><a class="markdownIt-Anchor" href="#美化自己的hexo博客">#</a> 美化自己的 hexo 博客</h2><p>首先你需要下载一个博客的主题 (如果你认为你的博客默认主题已经非常好看的了请忽略我说的话)</p><p>我们以 ad 主题为例（分站使用的是 ad 主题</p><p>你需要先找见 ad 主题在 github 的网址，以便把这个主题克隆到自己的文件夹里面</p><p>ad 主题地址:<a href="https://github.com/dongyuanxin/theme-ad">https://github.com/dongyuanxin/theme-ad</a></p><p>然后我们需要在命令行中输入 git clone <a href="https://github.com/dongyuanxin/theme-ad.git">https://github.com/dongyuanxin/theme-ad.git</a> themes/ad</p><p>这样就能把 ad 的主题文件克隆到你的 themes 文件夹里面了</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/20.png" alt=""></p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/21.png" alt="aaa"></p><p>用 vscode 打开你的 blog 的根目录_config.yml 文件，修改<strong> themes: landscape 为 themes: ad</strong></p><p>然后保存退出</p><p>在命令行输入 hexo s 进行调试，打开 4000 端口</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/22.png" alt=""></p><p>然后输入 hexo clean 清楚临时缓存的文件，输入 hexo d 部署到远端</p><p>这样我们的主题就修改好了</p><h3 id="如何修改博客上的一些内容"><a class="markdownIt-Anchor" href="#如何修改博客上的一些内容">#</a> 如何修改博客上的一些内容</h3><p>这里的内容指的是超链接，修改博客文字内容等操作，可以使你的博客更加个性化 (也许 (っ・̀ω・́) っ✎⁾⁾)</p><p>相信你已经发现了，blog 的根目录_config.yml 文件很重要，打开发现有很多设置的东西</p><p>其实你 themes 目录下的主题也有_config.yml 文件，只要你打开它，我相信你就会知道怎么使用它了 (确信)</p><h3 id="如何在文章中加入超链接"><a class="markdownIt-Anchor" href="#如何在文章中加入超链接">#</a> 如何在文章中加入超链接</h3><p>你可以使用 Typora 来写文章，可以直接使用超链接的格式，当然也可以用其他的软件来写 (<s>比如记事本</s>)</p><p>格式:[你想写的内容]+(你想加入的链接)</p><p>这是基于 markdown 语法的格式，markdown 格式的参考网址可以参考我在下文放出的链接</p><h3 id="如何写文章及在写文章时加入图片不推荐建议使用图片链接"><a class="markdownIt-Anchor" href="#如何写文章及在写文章时加入图片不推荐建议使用图片链接">#</a> 如何写文章及在写文章时加入图片（不推荐，建议使用图片链接）</h3><p>我们只需在命令行输入 hexo new “文章标题” 就可以创建一个空文件夹了，然后可以打开改.md 文件进行写入内容</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/23.png" alt=""></p><p>那么问题来了，如何才能写出像我一样带有图片的文章呢？</p><p>我们需要再下载一个插件</p><p>我们需要打开 git bash (dos 也可以) 输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>然后打开 hexo 的配置文件_config.yml</p><p>找到 post_asset_folder，把这个选项从 false 改成 true</p><p>这样我们每次新建的文章都会带有一个同名的文件夹 (原来的文件可以直接新建同名文件夹食用)</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/24.png" alt="aaa"></p><p>由于 hexo 文章是基于 markdown 语法写的，我们需要如何用 markdown 语法插入图片</p><p>参考网址:<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p><p>格式：比如我这篇文章就是这样写的:</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/25.png" alt=""></p><p>这样就可以在文章中间加入图片了 qwq</p><h3 id="如何写文章及在写文章时加入音乐播放器"><a class="markdownIt-Anchor" href="#如何写文章及在写文章时加入音乐播放器">#</a> 如何写文章及在写文章时加入音乐播放器</h3><p>我相信有些人喜欢和我一样在博客中加入音乐播放器 (显得有 13 格)，所以和我一起在自己的博客中加入这个好玩的东西吧</p><p>由于是我自学的如何插入，本文只能简单的进行插入工作 (菜)</p><p>原文链接 <a href="https://blog.csdn.net/thewindkee/article/details/55086735?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-4.control">https://blog.csdn.net/thewindkee/article/details/55086735?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-4.control</a></p><p>我接下来展示如何在 ad 主题下添加网易云音乐播放器</p><p>首先我们打开网页版网易云，选择一首你喜欢的歌曲</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/26.png" alt=""></p><p>点击” 生成外链播放器”</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/27.png" alt="aaa"></p><p>复制这个 HTML 代码</p><p>然后打开路径 themes\ad\layout\partials 下的 head.ejs 文件</p><p>(选择 head 是为了让播放器放到博客的左上角，当然我们也可以选择这个文件夹的任意文件进行修改)</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/28.png" alt="aaa"></p><p>加入这段代码</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/29.png" alt="aaa"></p><p>这样播放器就可以部署到你的博客里面了，但是我们还需要调一下 css 样式</p><p>打开路径 themes\ad\source\css</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/30.png" alt=""></p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/31.png" alt="aaa"></p><p margin-top:="" 80px;="">.header-music</p><p>这样我们的播放器就可以部署到博客上了</p><p>![<img src="https://water-boiled-fish.github.io/2020/09/03/hexo/32.png" alt="aaa"></p><h3 id="如何写文章及在写文章时加入音乐播放器升级版"><a class="markdownIt-Anchor" href="#如何写文章及在写文章时加入音乐播放器升级版">#</a> 如何写文章及在写文章时加入音乐播放器 (升级版）</h3><p>由于我看了隔壁学长 farewell 的博客发现他的播放器和我上面配置的不一样 (我的太菜了)</p><p>所以我决定我也要搞一个，但是这个过程并不顺利。。。经过我艰苦卓绝的努力，终于找到一个教程，现在用我的方法呈现出来</p><p>原文链接 <a href="https://www.cnblogs.com/fby698/p/12663089.html">https://www.cnblogs.com/fby698/p/12663089.html</a></p><p>Aplayer 官网文档：<a href="https://aplayer.js.org/#/">https://aplayer.js.org/#/</a></p><p>Metingjs 官网文档：<a href="https://github.com/metowolf/MetingJS">https://github.com/metowolf/MetingJS</a><br>| 选项                        | 默认        | 描述                                                         |<br>| ————————— | ———– | ———————————————————— |<br>| server (平台)                | <strong>require</strong> | 音乐平台： <code>netease</code> ， <code>tencent</code> ， <code>kugou</code> ， <code>xiami</code> ， <code>baidu</code>     |<br>| id (编号)                    | <strong>require</strong> | 歌曲 ID / 播放列表 ID / 专辑 ID / 搜索关键字                       |<br>| auto（支持类种 类）         | options     | 音乐链接，支持： <code>netease</code> ， <code>tencent</code> ， <code>xiami</code>                 |<br>| type（类型）                | <strong>require</strong> |  <code>song</code> ， <code>playlist</code> ， <code>album</code> ， <code>search</code> ， <code>artist</code>               |<br>| fixed（固定模式）           |  <code>false</code>      | 启用固定模式，默认 <code>false</code>                                     |<br>| mini（迷你模式）            |  <code>false</code>      | 启用迷你模式，默认 <code>false</code>                                      |<br>| autoplay（自动播放）        |  <code>false</code>      | 音频自动播放，默认 <code>false</code>                                     |<br>| theme (主题颜色)             |  <code>#2980b9</code>    | 默认 <code>#2980b9</code>                                                 |<br>| loop（循环）                |  <code>all</code>        | 播放器循环播放，值：“all”，one”，“none”                      |<br>| order (顺序)                 |  <code>list</code>       | 播放器播放顺序，值：“list”，“random”                         |<br>| preload (加载)               |  <code>auto</code>       | 值：“none”，“metadata”，“’auto”                              |<br>| volume（声量）              |  <code>0.7</code>        | 默认音量，请注意播放器会记住用户设置，用户自己设置音量后默认音量将不起作用 |<br>| mutex（限制）               |  <code>true</code>       | 防止同时播放多个玩家，在该玩家开始播放时暂停其他玩家         |<br>| lrc-type（歌词）            |  <code>0</code>          | 歌词显示                                                     |<br>| list-folded（列表折叠）     |  <code>false</code>      | 指示列表是否应该首先折叠                                     |<br>| list-max-height（最大高度） |  <code>340px</code>      | 列出最大高度                                                 |<br>| storage-name（储存名称）    |  <code>metingjs</code>   | 存储播放器设置的 localStorage 键                               |<br> 然后在你博客的适当位置加入以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">         &lt;!-- 引用Aplayer和metingjs --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;div id=&quot;my-aplayer&quot;</span><br><span class="line">class=&quot;aplayer&quot; </span><br><span class="line">data-id=&quot;706800324&quot; </span><br><span class="line">  data-server=&quot;netease&quot; </span><br><span class="line">  data-mini=&quot;false&quot;</span><br><span class="line">data-type=&quot;playlist&quot; </span><br><span class="line">data-fixed=&quot;false&quot; // 吸底模式可以固定播放器于页面底部(这个底部指的是你屏幕下方，并非指的网页下方)</span><br><span class="line">data-autoplay=&quot;fals&quot; </span><br><span class="line">data-order=&quot;list&quot; </span><br><span class="line">  data-volume=&quot;0.55&quot; </span><br><span class="line">  data-list-folded=&quot;ture&quot;</span><br><span class="line">  data-theme=&quot;#66CCFF&quot; </span><br><span class="line">  data-list-max-height=&quot;340px&quot;</span><br><span class="line">  data-preload=&quot;auto&quot; </span><br></pre></td></tr></table></figure><p><strong>适当位置</strong>指的是你博客的主界面的文件中的位置，举个栗子</p><p>选择 themes\ad\layout\partials\footer.ejs (因为我使用的 ad 主题，所以这里以 ad 主题为例，若使用其他主题，只需要点开对应主题的.ejs 文件)</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/26.png" alt=""></p><p>然后在适当位置加入代码 (该代码在文件中的位置直接对应到播放器在你的博客页面的位置)</p><p>比如我的就是在这里加的</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/27.png" alt="aaa"></p><p>需要注意的是，你这样拷贝的是我的播放器列表 (当然用我的歌单我将感激不尽)，我相信你肯定想拥有一个属于自己的播放列表</p><p>这里就拿网易云音乐举例，仔细看上面的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data-id=&quot;706800324&quot; </span><br><span class="line">data-server=&quot;netease&quot; </span><br></pre></td></tr></table></figure><p>我相信你如果仔细看过上面的表格的话一定知道我想表达什么了 (<s>可能</s>)</p><p>你首先需要选择你需要播放的音乐平台，比如你想使用网易云，就在 data-serve 后面输入 <code>netease</code> ，你想使用 qq 音乐，就在 data-serve 后面输入 <code>tencent</code> ，以此类推。。。</p><p>不管你是哪个平台的忠实听众，你的每个歌单都有属于它自己的 id，你需要的是把这个 id 找到然后 cv 到你的 data-id 上</p><p>接下来让我们看看这么才能找到你歌单的 id</p><p>首先打开网页版的网易云音乐，然后<s>登陆</s>，找到自己的歌单</p><p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/28.png" alt="aaa"></p><p>看见最上方链接的那一串数字了没？那就是我们想要的东西</p><p>赶快 cv 一下，然后粘贴替换掉上面我的 id (<s>悲</s>)</p><p>然后你的这段代码就是你自己的了，赶快 hexo s 试一试</p><p>该播放器的更多使用方法在上方表格内都写出来了，如果看见代码里面没有的但是表格中确实有使用方法的，可以手动添加，在代码末端加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data-选项名称(英文)=“ ”</span><br></pre></td></tr></table></figure><p>这样达到你需要的目的，其他选项可以自行修改，更多使用方法请自行尝试 (<s>因为那些也就改几个字的事情，没必要教</s>)</p><p><s>emmmmm 其实有的主题在主题对应的_config.yml 文件中就已经配置好了</s></p><h3 id="如何在博客中加入live_2d看板娘"><a class="markdownIt-Anchor" href="#如何在博客中加入live_2d看板娘">#</a> 如何在博客中加入 live_2d 看板娘</h3><p>因为我还没有学过 HTML 的用法，所以我只能部署一个比较简单的 live_2d 看板娘</p><p>在命令行输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>安装</p><p>但是这个 live2d 的插件真的一言难尽 (我和学长一致认为这个 live2d 插件自带的人物很少 (<s>且不对我 xp</s>) 且不能自行添加)</p><p>安装截图我就不放了，毕竟能看到这里的都安装过不下 10 次了吧 (</p><p>安装好了之后就可以去下载 live2d 文件了 (其实你也可以边等边下载的)</p><p>下载地址:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</span><br></pre></td></tr></table></figure><p>下载的文件是文件夹格式的，我们需要把它们移到（）文件路径中</p><p>然后你还需要再次修改根目录中的_config.yml 文件，修改代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">live2d:  enable: true  pluginModelPath: assets/  model:    use: live2d-widget-model-xxx  #这是你需要把模板放入的目录，在node_modules里，xxx表示你的live_2d的具体文件  display:    position: right      #放置在你的博客的左下还是右下    width: 150     height: 300  mobile:    show: false  #是否在手机进行显示</span><br></pre></td></tr></table></figure><p>原文章代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">live2d:  enable: true  scriptFrom: local  pluginRootPath: live2dw/  pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  log: false  model:    use: live2d-widget-model-wanko  display:    position: right    width: 150    height: 300  mobile:    show: true  react:    opacity: 0.7</span><br></pre></td></tr></table></figure><p>如图所示</p><p>（）</p><p>然后你就可以在命令行中输入 hexo s 来进行本地调试了</p><p>选择一个你喜欢的 live_2d 吧ヾ (๑╹◡╹)ﾉ”</p><p><strong>未完待续（文章有点小问题，找时间改改）</strong></p><p><strong>原文链接：<a href="https://water-boiled-fish.github.io/2020/09/03/hexo/">使用 hexo 搭建自己的博客及美化与上传 Github | Little_Flower_Fa (water-boiled-fish.github.io)</a></strong></p><p>（白嫖什么的，真香）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First Blog</title>
      <link href="/passages/First-Blog/"/>
      <url>/passages/First-Blog/</url>
      
        <content type="html"><![CDATA[<p>First Blog 完成啦！</p><p>博客可算是搭好了，等了好久终于等到今天～～</p><p>想说的话：现在保证能跑就行</p><p>‘Text.’</p><p><a href="https://cn.bing.com/?mkt=zh-CN">必应 (bing.com)</a></p><p><code>printf()</code>  函数</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/passages/hello-world/"/>
      <url>/passages/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start">#</a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post">#</a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server">#</a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files">#</a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites">#</a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: [Deployment](<a href="https://hexo.io/docs/one-command-deployment.html">https://hexo.io/docs/one-command-deployment.html</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
