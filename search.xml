<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言快速入门</title>
    <url>/passages/C%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="序言"><a class="markdownIt-Anchor" href="#序言">#</a> 序言</h1>
<p>​        C 语言是一种面向过程的计算机编程语言，多用于嵌入式开发（电路硬件编程）与系统底层编写， 比如我们常用的 Linux 系统，Windows 系统就是主要由 C 语言编写的。同时 c 语言也是最早出现的编程语 言之一，最早在 1972 年就已经被使用，并且直到现在它也是使用率最多的编程语言之一。</p>
<h2 id="计算机的内存"><a class="markdownIt-Anchor" href="#计算机的内存">#</a> 计算机的内存</h2>
<p>代码本身存储在计算机的硬盘里，不管计算机开机还是关机，你写的程序的代码都是存在的，但是 一个程序要想运行起来就需要运行在计算机的内存里。</p>
<p>可以将计算机的内存想象成一个大的空间，这个空间中有各种各样的程序在运行着，并且每个程序 都会占用一定的空间，而所占空间的大小由程序本身所有的一些变量，函数等决定。</p>
<h2 id="什么是编译器"><a class="markdownIt-Anchor" href="#什么是编译器">#</a> 什么是编译器</h2>
<p>我们的计算机只能够识别由 0 和 1 的二进制码，因此我们写出来的代码要想运行起来必须经过软件的 编译，将英文的编程语句转换为电脑能够识别的二进制码，不论哪种编程语言，最终都会经过编译转换 为计算机可识别的二进制码。** 将代码转换为二进制机器码的过程就叫做编译，负责进行转换的程序叫做 编译器。** 例如 gcc 编译器 等</p>
<h2 id="ide集成开发环境是什么"><a class="markdownIt-Anchor" href="#ide集成开发环境是什么">#</a> IDE (集成开发环境) 是什么</h2>
<p>​        IDE 是 Intergreated Development Environment 的缩写，中文称为集成开发环境，是指辅助程序 员开发的应用软件。</p>
<p>​        我们已经知道，想要运行一个 C 语言程序必须有编译器，但是在实际开发过程中，除运行程序必须 的编译器之外，我们往往还需要很多其他的辅助工具，比如 语言编辑器、自动建立工具、除错器等等 。这些被打包在一起成为一个开发软件， 统一发布和安装，统称为集成开发环境（IDE）。比如我们使 用的 VS2010，devc++，CLion 等都是 IDE。</p>
<p><strong>IDE 与编译器的区别</strong></p>
<p>​       IDE 是编译器与其它各种开发工具的集合体。</p>
<p><strong>面向过程思想</strong></p>
<p>​		面向过程是一种以过程为中心的编程思想，其原理就是将问题分解成一个一个详细的步骤，然后通 过函数实现每一个步骤，并依次调用。 面向过程我们所关心的是解决一个问题的步骤，举个例子，汽车发动、汽车熄火，这是两个不同 的事件，对于面向过程而言，我们关心的是事件本身，因此我们会使用两个函数完成以上两个动作，然 后依次调用即可。</p>
<p>​		再比如 进入游戏，开始游戏，游戏结算，这是三个不同的事件，我们在玩游戏时只会关注这三个事 件，我们可以使用函数来表示这三个不同的动作，依次调用。</p>
<p>计算机基本快捷键的使用</p>
<ol>
<li>ctrl + 空格 /ctrl+shift : 快速切换中英文输入法</li>
<li>Ctrl-X：剪切所选项并拷贝到剪贴板。</li>
<li>Ctrl-C：将所选项拷贝到剪贴板。</li>
<li>Ctrl-V：将剪贴板的内容粘贴到当前文稿或应用中。</li>
<li>Ctrl-Z：撤销上一个命令。</li>
<li>Ctrl-A：全选各项。</li>
<li>Ctrl-S: 保存当前文件</li>
<li>Ctrl-F：查找文稿中的项目或打开 “查找” 窗口。</li>
<li>win+R: 唤起 “运行” 对话框，快速运行特定程序</li>
<li>win+X: 唤起系统菜单</li>
</ol>
<h2 id="第一个程序hello-world"><a class="markdownIt-Anchor" href="#第一个程序hello-world">#</a> 第一个程序（Hello World!)</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 我的第一个 C 程序 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World! \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="程序解析"><a class="markdownIt-Anchor" href="#程序解析">#</a> 程序解析</h2>
<p>一个最基础的 C 语言程序由 <strong>预处理器指令，函数，变量，语句和表达式 以及 注释</strong>组成</p>
<p>接下来我们讲解一下上面这段程序：</p>
<ol>
<li>程序的第一行 <strong>#include</strong> 是预处理器指令，告诉 C 编译器在实际编译之前要包含<strong> stdio.h</strong> 文 件，可以将头文件理解为一个工具箱，在我们开始工作前，需要先拿好工具箱才能开始我们的 工作。</li>
<li>下一行<strong> int main ()</strong> 是主函数，程序从这里开始执行。</li>
<li>下一行 <strong>/<em>…</em>/</strong> 将会被编译器忽略，不会执行，这里放置程序的注释内容。它们用来告诉读者 这个程序或者这些代码要做什么。</li>
<li>下一行 **printf (…)** 是 C 中另一个可用的函数，会在屏幕上显示消息 “Hello, World!”。</li>
<li>下一行 <strong>return 0;</strong> 终止 main () 函数，并返回值 0，表示程序完整地结束。</li>
</ol>
<h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法">#</a> 基本语法</h1>
<p>​		分号：在 c 语言中，每个语句之后必须跟一个 <strong>英文分号</strong>表示一个语句的结束</p>
<p>​		注释：C 语言有两种注释方式，分别是 <strong>//<strong> 和</strong>上文那种</strong>，// 是单行注释，只会将一行标注为注释，而<strong>上文那种</strong>是多行注释。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释 //</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>​		<strong>标识符:</strong></p>
<p>​		C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 语言是<strong>区分大小写</strong>的编程语言。因此，在 C 中， Manpower 和 manpower 是两个不同的标识符。</p>
<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型">#</a> 数据类型</h1>
<h2 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型">#</a> 基本类型</h2>
<h3 id="int整型"><a class="markdownIt-Anchor" href="#int整型">#</a> <strong>int（整型）</strong></h3>
<p>​		可以用来声明一个整数变量</p>
<h3 id="short短字节类型"><a class="markdownIt-Anchor" href="#short短字节类型">#</a> <strong>short（短字节类型）</strong></h3>
<p>​		可以用来声明短整形（节约内存）</p>
<h3 id="long-int长字节类型"><a class="markdownIt-Anchor" href="#long-int长字节类型">#</a> <strong>long int（长字节类型）</strong></h3>
<p>​		当数据的大小超出 int 类型的上限时，可以使用 long int 甚至是 long long int 来扩大取值范围</p>
<h3 id="double和float浮点类型"><a class="markdownIt-Anchor" href="#double和float浮点类型">#</a> <strong>double 和 float（浮点类型）</strong></h3>
<p>​		double 和 float 用来表示浮点数（小数）</p>
<p>​		区别：</p>
<p>​		 double 可以存储到小数点后 15 位，float 可以存储到小数点后 6 位</p>
<h3 id="char字符类型"><a class="markdownIt-Anchor" href="#char字符类型">#</a> <strong>char（字符类型）</strong></h3>
<p>​		char 是最小的基本类型，只占 1 个字节的存储空间，主要用来表示字符，例如‘a’,‘b’,‘c’,‘d’等。</p>
<p>​		 值得注意的是，<strong>char 类型的‘1’和 int 类型的 1 是不一样的</strong>，在实际编写代码时需要注意。</p>
<h3 id="unsigned无符号修饰符"><a class="markdownIt-Anchor" href="#unsigned无符号修饰符">#</a> <strong>unsigned（无符号）修饰符</strong></h3>
<p>​		unsigned 可以用来修饰前面的数据类型，例如 unsigned int,unsigned char,unsigned double 等， 被 unsigned 修饰的数据类型其所占的存储空间大小不变，但是最大值会扩大为原来的 2 倍，最小值变为 0. 也就是说，一个数据类型被 unsigned 修饰以后，这个数据类型将变为无符号类型，也就是其不再有负 数值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">20201022</span>;</span><br><span class="line"><span class="keyword">int</span> year = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">short</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> num = <span class="number">1234567890</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> weight = <span class="number">188.5326</span>;</span><br><span class="line"><span class="keyword">float</span> high = <span class="number">100.25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> a=<span class="number">32767</span>,b=a+<span class="number">1</span>;<span class="comment">//定义短整型无符号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%u\nb=%u\n&quot;</span>,a,b);<span class="comment">//以无符号输出</span></span><br></pre></td></tr></table></figure>
<p>​		<strong>相对于 unsigned，还有一个 signed 修饰符，signed 是有符号修饰符，但是我们一般省略他，c 语 言默认的数据类型都是有符号的</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>储存空间大小</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>（与 signed char 或 unsigned char 相同）</td>
<td>（与 signed char 或 unsigned char 相同）</td>
<td>（与 signed char 或 unsigned char 相同）</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1 个字节</td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>signed char</td>
<td>1 个字节</td>
<td>-128</td>
<td>127</td>
</tr>
<tr>
<td>int</td>
<td>2 个或 4 个字节</td>
<td>-32 768 或 -2 147 483 684</td>
<td>32 768 或 2 147 483 684</td>
</tr>
<tr>
<td>unsigned int</td>
<td>2 个或 4 个字节</td>
<td>0</td>
<td>65 535 或 4 294 967 295</td>
</tr>
<tr>
<td>short</td>
<td>2 个字节</td>
<td>-32 768</td>
<td>32 767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2 个字节</td>
<td>0</td>
<td>65 535</td>
</tr>
<tr>
<td>long</td>
<td>4 个字节</td>
<td>-2 147 483 648</td>
<td>2 147 483 647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4 个字节</td>
<td>0</td>
<td>4 294 967 295</td>
</tr>
<tr>
<td>long long（C99）</td>
<td>8 个字节</td>
<td>-9 223 372 036 854 755 808</td>
<td>9 223 372 036 854 755 808</td>
</tr>
<tr>
<td>unsigned long long（C99）</td>
<td>8 个字节</td>
<td>0</td>
<td>18 446 744 073 709 551 615</td>
</tr>
</tbody>
</table>
<p>​		<strong>注：int 类型在 16 位系统中占 2 个字节，在 32 和 64 位系统中占 4 个字节</strong></p>
<h2 id="基本类型转换"><a class="markdownIt-Anchor" href="#基本类型转换">#</a> 基本类型转换</h2>
<h4 id="1自动类型转换"><a class="markdownIt-Anchor" href="#1自动类型转换">#</a> 1. 自动类型转换</h4>
<p>当两个不同类型的变量进行运算时，编译器会自动进行类型转换，自动类型转换遵从以下规则：</p>
<p><img src="https://s3.bmp.ovh/imgs/2021/10/95b6bbcb25e8bb2f.png" alt></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">1.2</span>;</span><br><span class="line"><span class="keyword">double</span> c = a+b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,c);</span><br></pre></td></tr></table></figure>
<p>​		在执行 a+b 运算的时候编译器会先把 int 类型的 a 转为 double 类型，然后再和 b 进行运算</p>
<h4 id="2强制类型转换"><a class="markdownIt-Anchor" href="#2强制类型转换">#</a> 2. 强制类型转换</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">3.641593</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="keyword">int</span>)a ); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,a );<span class="comment">// 3.641593</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注：在进行由高到低的强制类型转换时，数据会有部分丢失</strong></p>
<p><strong>强制类型转换是临时的，不会修改变量本来的类型</strong></p>
</blockquote>
<h2 id="基本类型书写"><a class="markdownIt-Anchor" href="#基本类型书写">#</a> 基本类型书写</h2>
<p><strong>整数</strong></p>
<ul>
<li>
<p>默认为 10 进制 ，10 ，20。</p>
</li>
<li>
<p>以 0 开头为 8 进制，012，024。</p>
</li>
<li>
<p>以 0b 开头为 2 进制，0b1010, 0b10100。</p>
</li>
<li>
<p>以 0x 开头为 16 进制，0xa，0x14。</p>
</li>
</ul>
<p><strong>小数</strong></p>
<p>单精度常量（float）：2.3f 。</p>
<p>双精度常量（double）：2.3，默认为双精度。</p>
<p><strong>字符型常量</strong></p>
<p>用英文单引号括起来，只保存一个字符，‘a’、‘b’ 、’*’ ，还有转义字符 ‘\n’ 、’\t’。</p>
<p><strong>字符串常量</strong></p>
<p>用英文的双引号引起来 可以保存多个字符：“abc”。</p>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量">#</a> 变量</h2>
<p>​		变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存 储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>​		这里的 age 就是一个变量，变量 age 的值为 5，而”age“叫做变量名。</p>
<p>​		同一类型的多个变量的声明之间可以用逗号隔开</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line"><span class="comment">//声明并定义了变量 i、j 和 k，</span></span><br><span class="line"><span class="comment">//这指示编译器创建类型为 int 的名为 i、j、k 的变量。下面同理</span></span><br><span class="line"><span class="keyword">char</span> c, ch;</span><br><span class="line"><span class="keyword">float</span> f, salary;</span><br><span class="line"><span class="keyword">double</span> d;</span><br></pre></td></tr></table></figure>
<h3 id="变量的输入和输出"><a class="markdownIt-Anchor" href="#变量的输入和输出">#</a> 变量的输入和输出</h3>
<p>1.scanf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入char变量：</span></span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入int变量：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入double/float变量：</span></span><br><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a);</span><br><span class="line"><span class="keyword">float</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;a);</span><br></pre></td></tr></table></figure>
<p>2.printf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出char变量：</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a); <span class="comment">// c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出int变量：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出double/float变量：</span></span><br><span class="line"><span class="keyword">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,a); <span class="comment">// 3.140000 默认保留六位小数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,a);<span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,a);<span class="comment">// 3.1</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>unsigned int</td>
<td>以十六进制小写输出</td>
<td>printf(&quot;%x&quot;,11);</td>
<td>b</td>
</tr>
<tr>
<td>X</td>
<td>unsigned int</td>
<td>以十六进制大写输出</td>
<td>printf(&quot;%X&quot;,11);</td>
<td>B</td>
</tr>
<tr>
<td>o</td>
<td>unsigned int</td>
<td>以八进制无符号整 S 输出</td>
<td>printf( &quot;%o”,100);</td>
<td>144</td>
</tr>
<tr>
<td>u</td>
<td>unsigned int</td>
<td>以无符号整型输出</td>
<td>printf( “%u,%u”,100u,100);</td>
<td>100,100</td>
</tr>
<tr>
<td>d、i</td>
<td>int</td>
<td>以整型输出</td>
<td>printf(&quot;%i,%d&quot;, 100,100);</td>
<td>100,100</td>
</tr>
</tbody>
</table>
<h2 id="常量"><a class="markdownIt-Anchor" href="#常量">#</a> 常量</h2>
<p>​		常量是固定值，在程序执行期间不会改变。</p>
<p>​		常量可以是任何的基本数据类型，比如 int,double,char</p>
<h3 id="常量的定义"><a class="markdownIt-Anchor" href="#常量的定义">#</a> 常量的定义：</h3>
<ol>
<li>
<p>使用 <strong>#define</strong> 预处理器。</p>
</li>
<li>
<p>使用 <strong>const</strong> 关键字。 <strong>被 const 和 define 修饰的变量不可变</strong></p>
<p><strong>#define 预处理器</strong></p>
<p>下面是使用 #define 预处理器定义常量的形式：</p>
<p>注意：define 定义之后不需要加分号</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//模式：</span></span><br><span class="line"><span class="comment">//#define identifier value</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEWLINE <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> area;</span><br><span class="line">area = LENGTH * WIDTH;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value of area : %d\n&quot;</span>, area);</span><br><span class="line"><span class="keyword">double</span> r_area;</span><br><span class="line">r_area = PI * R * R;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value of double area:%lf\n&quot;</span>, r_area);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, NEWLINE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>const 关键字</strong></p>
<p>​		可以使用 const 前缀声明指定类型的常量，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LENGTH = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> WIDTH = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> NEWLINE = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> area;</span><br><span class="line">area = LENGTH * WIDTH;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value of area : %d&quot;</span>, area);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, NEWLINE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="运算符"><a class="markdownIt-Anchor" href="#运算符">#</a> 运算符</h1>
<h2 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符">#</a> 算术运算符</h2>
<ol>
<li>
<p>”+“运算符：把两个数相加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = 7</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>”-“运算符：把两个数相减</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = a - b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = -3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>“*” 运算符：把两个数相乘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = a * b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = 10</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>“/” 运算符：把两个数相除，左边是被除数，右边的是除数（右边的数不能为 0）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = a / b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = 0</span></span><br><span class="line"><span class="comment">/*这里因为a，b，c都是int类型，a/b=0.4,所以会直接舍去后面的.4，只剩0*/</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">double</span> e = <span class="number">3.0</span>;</span><br><span class="line"><span class="keyword">double</span> f = e / d;</span><br><span class="line"><span class="comment">//double类型允许小数的存在，因此这里的f就是1.5了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：C 语言不会对计算结果进行四舍五入，会直接全部舍去，比如 3.9，转为 int 类型的时候 就会变成 3</p>
</li>
<li>
<p>”%“：取余运算符，可以直接取整除之后的余数：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = b % a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = 1</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>”++“运算符：自增运算符，让变量的值加 1：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a++;<span class="comment">//也可以写成 c = ++a;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c); <span class="comment">// c = </span></span><br></pre></td></tr></table></figure>
<p><strong>a<ins> 与</ins> a 的区别:</strong></p>
<p>​		在进行 a++ 运算时，程序会先对 a 复制一次，然后让其 + 1，执行的操作类似 a = a + 1</p>
<p>​		在进行 ++a 运算时，程序会直接让 a+1</p>
<ol start="7">
<li>
<p>“–” 运算符：自减运算符，让变量的值 - 1：</p>
<p>​	与 ++ 运算符同理，a–运算会对 a 先复制一次，再让其 - 1，–a 会直接让其 - 1</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,--a);<span class="comment">//输出0</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b--);<span class="comment">//输出1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b);<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
<p><strong>关系运算符</strong></p>
<ol>
<li>== 运算符：</li>
</ol>
<p>在 c 语言中 ” = “表示的是对一个变量进行赋值，而要想判断两个变量的值是否相同所用到的 是” == “运算符，该运算符返回的是一个真假值（在 c 语言中 1 表示真值，0 表示假值）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a == b);<span class="comment">// 1</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a == b); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>!= 运算符:</li>
</ol>
<p>这个运算符表示两个变量是否不同，返回值为真假值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a != b);<span class="comment">// 0</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a != b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>&gt; 运算符：</li>
</ol>
<p>判断运算符左边的变量是否大于右边的变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &gt; b);<span class="comment">// 0</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &gt; b); <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>&lt; 运算符：</li>
</ol>
<p>判断运算符左边的变量是否小于右边的变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &lt; b);<span class="comment">// 1</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &lt; b); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>&gt;= 运算符：</li>
</ol>
<p>判断运算符左边的变量是否大于等于右边的变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &gt;= b);<span class="comment">// 1</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &gt;= b); <span class="comment">// 1 </span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>&lt;= 运算符：</li>
</ol>
<p>判断运算符左边的变量是否小于等于右边的变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>,b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &lt; b);<span class="comment">// 1</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a &lt; b); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符">#</a> 逻辑运算符</h2>
<ol>
<li>&amp;&amp; 运算符： 表示 “且”，如果左右两个操作全部为真，则该表达式返回真</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>,b = <span class="number">3</span>;</span><br><span class="line">(a &lt; b &amp;&amp; a == <span class="number">2</span>) <span class="comment">// 这个表达式为 1</span></span><br><span class="line">(a &lt; b &amp;&amp; a == <span class="number">3</span>) <span class="comment">// 这个表达式为 0</span></span><br><span class="line">(a &lt; b &amp;&amp; a == <span class="number">3</span>) <span class="comment">// 这个表达式为 0</span></span><br><span class="line">(a &gt; b &amp;&amp; a == <span class="number">2</span>) <span class="comment">// 这个表达式为 0</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>|| 运算符： 表示 “或”，左右两个操作有一个为真，则该表达式为真</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>,b = <span class="number">3</span>;</span><br><span class="line">(a &lt; b || a == <span class="number">2</span>) <span class="comment">// 这个表达式为 1</span></span><br><span class="line">(a &lt; b || a == <span class="number">3</span>) <span class="comment">// 这个表达式为 1</span></span><br><span class="line">(a &gt; b || a == <span class="number">2</span>) <span class="comment">// 这个表达式为 1</span></span><br><span class="line">(a &gt; b || a == <span class="number">3</span>) <span class="comment">// 这个表达式为 0</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>! 运算符： 表示 “非”，如果修饰的条件表达式为真，则该表达式为假，反之为真。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>,b = <span class="number">3</span>;</span><br><span class="line">(a &lt; b || a == <span class="number">2</span>) <span class="comment">// 这个表达式为 1</span></span><br><span class="line">!(a &lt; b || a == <span class="number">2</span>) <span class="comment">// 这个表达式为 0</span></span><br><span class="line">(a &gt; b &amp;&amp; a == <span class="number">2</span>) <span class="comment">// 这个表达式为 0</span></span><br><span class="line">!(a &gt; b &amp;&amp; a == <span class="number">2</span>) <span class="comment">// 这个表达式为 1</span></span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符">#</a> 赋值运算符</h2>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td>C = A + B 将把 A + B 的 值赋给 C</td>
</tr>
<tr>
<td>+=</td>
<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋 值给左边操作数</td>
<td>C += A 相当于 C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋 值给左边操作数</td>
<td>C -= A 相当于 C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋 值给左边操作数</td>
<td>C *= A 相当于 C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋 值给左边操作数</td>
<td>C /= A 相当于 C = C / A</td>
</tr>
<tr>
<td>%=</td>
<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td>C %= A 相当于 C = C % A</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">a += <span class="number">3</span>; <span class="comment">// a = a + 3</span></span><br><span class="line">a -= <span class="number">3</span>; <span class="comment">// a = a - 3</span></span><br><span class="line">a *= <span class="number">3</span>; <span class="comment">// a = a * 3</span></span><br><span class="line">a /= <span class="number">3</span>; <span class="comment">// a = a / 3</span></span><br><span class="line">a %= <span class="number">3</span>; <span class="comment">// a = a % 3</span></span><br><span class="line">a = <span class="number">3</span>; <span class="comment">// a = 3</span></span><br></pre></td></tr></table></figure>
<h1 id="判断语句"><a class="markdownIt-Anchor" href="#判断语句">#</a> 判断语句</h1>
<p><img src="https://static.runoob.com/wp-content/uploads/c/C-decision-20200923-1.svg" alt></p>
<p>​		判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需 的）和条件为假时要执行的语句（可选的）。</p>
<h2 id="if-语句"><a class="markdownIt-Anchor" href="#if-语句">#</a> if 语句</h2>
<p>​	模式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件语句)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = b!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	一个 if 语句由一个条件语句后跟一个或多个语句组成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b &amp;&amp; a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = b!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="else语句"><a class="markdownIt-Anchor" href="#else语句">#</a> else 语句</h2>
<p>​	当条件不满足 if 中的条件语句时会跳入 else 语句执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式/条件语句)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果布尔表达式为真将执行的语句 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果布尔表达式为假将执行的语句 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://static.runoob.com/wp-content/uploads/c/c-if-else-20200923.svg" alt></p>
<p>​		示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>,b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a&lt;b!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a&gt;=b!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="else-if-语句"><a class="markdownIt-Anchor" href="#else-if-语句">#</a> else if 语句</h2>
<p>​		当需要进行多次判断时，可以使用 else if 语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>/条件语句<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果布尔表达式1为真将执行的语句 */</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>/条件语句<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果布尔表达式1为假,布尔表达式2为真将执行的语句 */</span></span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*如果两个布尔表达式都为假要执行的语句*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>,b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a&lt;b!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=b!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a&gt;b!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="switch-case-语句"><a class="markdownIt-Anchor" href="#switch-case-语句">#</a> switch case 语句</h2>
<p>​		如果需要判断的语句很多的时候，if else 未免显得非常繁琐，因此我们可以使用效率更高，更加精 简的 switch case 语句。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)&#123;<span class="keyword">case</span> 值<span class="number">1</span> :statement(s);<span class="comment">//执行语句break; /* 可选的 */case 值2 :statement(s);//执行语句break; /* 可选的 *//* 可以有任意数量的 case 语句 */default : /* 可选的 如果匹配不成功就会跳到这个标签下面去执行这个标签下面的语句*/statement(s);&#125;</span></span><br></pre></td></tr></table></figure>
<p>​		示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;<span class="keyword">switch</span>(x)&#123;<span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">&quot;x=0&quot;</span>);<span class="comment">//执行语句break; /* 可选的 */case 5:printf(&quot;x=5&quot;);//执行语句break; /* 可选的 *//* 可以有任意数量的 case 语句 */default : /* 可选的 如果匹配不成功就会跳到这个标签下面去执行这个标签下面的语句*/printf(&quot;no pattern&quot;);&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>switch</strong> 语句必须遵循下面的规则：</p>
<ul>
<li>
<p>switch 语句中 case 后面是一个常量（不能为浮点数） 在一个 switch 中可以有任意数量的 case 语句。</p>
</li>
<li>
<p>case 后面的常量 必须与 switch 中的变量具有相同的数据类型。</p>
</li>
<li>
<p>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为 止。</p>
</li>
<li>
<p>当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</p>
</li>
<li>
<p>不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会继续后续的 case，直到遇到 break 为止。</p>
</li>
<li>
<p>一个 switch 语句可以有一个可选的 default，出现在 switch 的结尾。在上面所有的 case 都 不执行时执行。default 中的 break 语句不是必需的。</p>
<p>​	示例：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> grade = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span>(grade)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;很棒！\n&quot;</span> );</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span> :</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;做得好\n&quot;</span> );</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;您通过了\n&quot;</span> );</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最好再试一下\n&quot;</span> );</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;无效的成绩\n&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;成绩是 %c\n&quot;</span>, grade );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="循环"><a class="markdownIt-Anchor" href="#循环">#</a> 循环</h1>
<p>​		当我们需要重复执行同一块代码时，我们可以使用循环操作来减少代码量。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/12/loop.png" alt></p>
<h2 id="1while循环"><a class="markdownIt-Anchor" href="#1while循环">#</a> 1.while 循环</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件语句)</span><br><span class="line">&#123;</span><br><span class="line">statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,n);</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次打印出0--9</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/09/BFE13459-897C-41A5-AE94-D71B0CA50FB6.jpg" alt></p>
<h2 id="2for循环"><a class="markdownIt-Anchor" href="#2for循环">#</a> 2.for 循环</h2>
<h2 id><a class="markdownIt-Anchor" href="#">#</a> </h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( init; condition; increment )</span><br><span class="line">&#123;</span><br><span class="line">statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//依次打印出从0到9</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/09/69978E61-0BA5-4D66-A115-D3AD15B16F47.jpg" alt></p>
<h2 id="3do"><a class="markdownIt-Anchor" href="#3do">#</a> <a href="http://3.do">3.do</a>…while 循环：</h2>
<p>​		不像 <strong>for</strong> 和 while 循环，它们是在循环头部测试循环条件。在 C 语言中，do…while 循环是 在循环的尾部检查它的条件。</p>
<p>​		do…while 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。也就是 说，do…while 结构会先执行循环，后进行条件判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">statement(s);</span><br><span class="line">&#125;<span class="keyword">while</span>( condition );</span><br></pre></td></tr></table></figure>
<p>​		示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">++n;</span><br><span class="line">&#125; <span class="keyword">while</span>(n &lt; <span class="number">0</span>); <span class="comment">// 输出 0</span></span><br><span class="line"><span class="keyword">while</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">++n;</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/09/B2FE1EC7-6477-439B-8F50-82D537673799.jpg" alt></p>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数">#</a> 函数</h1>
<p>​		函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main () ，所有简 单的程序都可以定义其他额外的函数。</p>
<p>​		定义方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回类型 函数名(参数)&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 返回类型：** 一个函数可以返回一个值。指函数返回的值的数据类型。有些函数执行所需的操作而不 返回值，在这种情况下，返回类型是 void。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_a</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明">#</a> 函数声明</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int max(int ,int );</span><br><span class="line">void print_a(int );</span><br><span class="line">int max(int a,int b)&#123;</span><br><span class="line">if(a &gt; b)&#123;</span><br><span class="line">return a;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void print_a(int a)&#123;</span><br><span class="line">printf(&quot;%d&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n = 0,m = 5;</span><br><span class="line">int num = max(n,m);</span><br><span class="line">print_a(num);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数组"><a class="markdownIt-Anchor" href="#数组">#</a> 数组</h1>
<p>​		当我们需要声明或使用同一类型的多个变量时，一个个声明未免太过繁琐，我们可以使用数组来达 到这个目的。</p>
<blockquote>
<p>数组是一个 <strong>固定大小</strong> 的 <strong>相同类型元素</strong> 的 <strong>顺序集合</strong>。</p>
</blockquote>
<p>​		声明方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">类型 数组名[数组大小];</span><br></pre></td></tr></table></figure>
<p>​		示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>]; <span class="comment">// 声明一个大小为10的int类型数组,它可以存储10个int类型的元素</span></span><br><span class="line"><span class="keyword">double</span> <span class="built_in">array</span>[<span class="number">10</span>]; <span class="comment">// 声明一个大小为10的double类型数组，它可以存储10个double类型的元素</span></span><br></pre></td></tr></table></figure>
<h2 id="初始化数组"><a class="markdownIt-Anchor" href="#初始化数组">#</a> 初始化数组</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>​		<strong>注意： 大括号 {} 之间的值的数目不能大于我们在数组声明时在方括号 [] 中指定的元素数目。</strong></p>
<p>​		有时我们会开一个超级大的数组，这时使用大括号来进行初始化就非常麻烦了，因此我们结合之前 的循环操作来对数组进行初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line"><span class="built_in">array</span>[i] = i+<span class="number">100</span>; <span class="comment">// 设置元素i的值为i+100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问数组元素</strong></p>
<p>​		数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。 例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> num = <span class="built_in">array</span>[<span class="number">0</span>]; <span class="comment">// num = 0;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ )<span class="comment">//利用循环打印整个数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Array[%d] = %d\n&quot;</span>, j, <span class="built_in">array</span>[j] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		<strong>注意：数组元素只被创建而没有被初始化的时候是不能进行正常访问的，只有数组中元素被赋值才 可以正常访问。</strong></p>
<h1 id="指针"><a class="markdownIt-Anchor" href="#指针">#</a> 指针</h1>
<h2 id="使用指针"><a class="markdownIt-Anchor" href="#使用指针">#</a> 使用指针</h2>
<p>​		想要在函数中完成变量的交换，不被形参所限制。</p>
<p>​		<strong>指针</strong>可以达成我们的目的。</p>
<p>​		在程序运行时，变量被创建时， 变量都会被分配到一个内存位置。</p>
<p>​		内存位置可以通过 **&amp; 运算符<strong>获取</strong>地址 **。</p>
<p>​		<strong>注意： 指针变量的类型必须要跟被取地址变量类型一致</strong></p>
<h2 id="怎么理解指针"><a class="markdownIt-Anchor" href="#怎么理解指针">#</a> 怎么理解指针</h2>
<p>让我们把 *p ，拆分成两部分去理解。</p>
<p><strong>’p’ 部分 ：是一个变量，能存储地址。</strong></p>
<p><strong>’*’ 部分 ：获取变量 p 储存的地址，并找到该地址上存储的值。</strong></p>
<p>​		运行上面的代码，输出 *p 的值就是 var 的值。</p>
<p>​		** 注意：** 多数时候指针初始化置 <strong>NULL</strong> 很有必要。</p>
<h2 id="指针基本运算"><a class="markdownIt-Anchor" href="#指针基本运算">#</a> 指针基本运算</h2>
<p>​		指针就是地址，地址在内存中也是以数的形式存在，所以指针也能进行基本运算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);</span><br><span class="line">p++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);</span><br><span class="line">p -= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="指向一维数组的指针"><a class="markdownIt-Anchor" href="#指向一维数组的指针">#</a> 指向一维数组的指针</h2>
<ul>
<li>
<p>数组中的每个数据都会保存在一个储存单元里面，只要是储存单元就会有地址，所以就可以用 指针保存数组储存单元的地址。</p>
<p><em>为指针赋数组数据的地址</em></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = &amp;num[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以使用指针操作一维数组</strong></p>
<ul>
<li>第一种</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br><span class="line">p++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = &amp;num[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h2 id="指向二维数组的指针"><a class="markdownIt-Anchor" href="#指向二维数组的指针">#</a> 指向二维数组的指针</h2>
<p>​		跟一维数组相似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;num[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>注意： 不能为指针直接赋予二维数组的数组名，即上面的代码不能写成： int *p = num；</li>
</ul>
<h2 id="数组指针"><a class="markdownIt-Anchor" href="#数组指针">#</a> 数组指针</h2>
<p>​		<strong>顾名思义：</strong> 指向数组的指针</p>
<p>​		如果一个指针指向了数组，就称它为数组指针。c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>​		在概念上的矩阵是像这种矩阵的样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>​		但实际上它在内存中是链式存储的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>​		定义一个数组指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br></pre></td></tr></table></figure>
<p><strong>括号里面的 * 代表 p 是一个指针，[3] 代表这个 指针 p 指向了类型为 int [3] 的数组</strong></p>
<ul>
<li>
<p>p 指向数组 a 的开头，就是指向数组的第 0 行元素，p + 1 指向数组的第一行元素</p>
</li>
<li>
<p>所以 *(p+1) 就表示数组的第一行元素的值，有多个数据</p>
</li>
<li>
<p>*(p+1) + 1 表示第一行的第一个数据的地址</p>
</li>
</ul>
<h2 id="二级指针"><a class="markdownIt-Anchor" href="#二级指针">#</a> 二级指针</h2>
<p>​		<strong>顾名思义：</strong> 指向指针的指针</p>
<p>​		假设有一个 int 类型的变量 a ， p1 是指向 a 的指针变量， p2 又是指向 p1 的指针变量。</p>
<p>​		用代码形式展现就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **p2 = &amp;p1;</span><br></pre></td></tr></table></figure>
<p>​		指针变量也是一种变量，也会占用存储空间，也可以使用 &amp; 获取它的地址。C 语言不限制指针的级 数，每增加一级指针，在定义指针变量时就得增加一个星号。p1 是一级指针，指向普通类型的数据， 定义时有一个；p2 是二级指针，指向一级指针 p1，定义时有两个 *。</p>
<p>​		** 同理：** 指针可以有三级指针、四级指针等等。</p>
<h2 id="指针在函数中的作用"><a class="markdownIt-Anchor" href="#指针在函数中的作用">#</a> 指针在函数中的作用</h2>
<p><strong>指针作为函数的参数</strong></p>
<p>写一个函数并调用，实现交换变量的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp= a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">swap(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>,a,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		运行上面的代码，<strong>a 和 b 的值并没有发生交换</strong></p>
<h2 id="形参形式参数"><a class="markdownIt-Anchor" href="#形参形式参数">#</a> 形参（形式参数）</h2>
<p>​		在函数定义中出现的参数，它没有数据，只能在函数被调用时接收传递进来的数据，所以称为<strong>形式参数</strong>。</p>
<h2 id="实参实际参数"><a class="markdownIt-Anchor" href="#实参实际参数">#</a> 实参（实际参数）</h2>
<p>​		函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为<strong>实际参数</strong>。 形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp= a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">swap(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>,a,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		<strong>main 函数</strong> 中调用的 <strong>swap 函数</strong> <strong>swap(a, b);</strong> 中的 a，b 是<strong>实参</strong>。</p>
<p>​		<strong>swap 函数</strong> 定义的 <strong>void swap(int a,int b)</strong> 中的 a，b 是<strong>形参。</strong></p>
<p>​		在 c 语言中实参和形参之间的数据传输是单向的 “值传递” 方式，也就是实参可以影响形参，而形参不 能影响实参。指针变量作为参数也不例外，但是可以改变实参指针变量所指向的变量的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确的变量交换代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *temp= a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">swap(&amp;a, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>,a,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		上面代码在调用 scanf 或者 swap 函数的时候，传入变量时，变量前都使用了 &amp; 运算符</p>
<p>​		这两个函数通过传入的地址去改变了实参。</p>
<h2 id="指针函数"><a class="markdownIt-Anchor" href="#指针函数">#</a> 指针函数</h2>
<p>​		C 语言允许函数的返回值是一个指针（地址），我们将这样的函数称为指针函数。</p>
<p>​		下面的例子定义了一个函数 strlong () ，用来返回两个字符串中较长的一个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strlong</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span>&#123;<span class="comment">//返回类型是(char*)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(str1) &gt;= <span class="built_in">strlen</span>(str2))&#123;</span><br><span class="line"><span class="keyword">return</span> str1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> str2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">30</span>], str2[<span class="number">30</span>], *str;</span><br><span class="line">gets(str1);</span><br><span class="line">gets(str2);</span><br><span class="line">str = strlong(str1, str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Longer string: %s\n&quot;</span>, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		<strong>注意：函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数。</strong></p>
<h1 id="结构体"><a class="markdownIt-Anchor" href="#结构体">#</a> 结构体</h1>
<p>​		如果我们想存储多个学生的信息，比如身高、体重、学习成绩，等等。</p>
<p>​		在学结构体前，我们可以使用多个数组，用相同下标去存储一个学生的所有信息。</p>
<p>​		或者使用很多的变量，去储存信息，上述实现方法显得相当麻烦。</p>
<p>​		C 语言向我们提供了一种数据类型 <strong>：结构体（struct）</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">double</span> weight;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;student1;</span><br></pre></td></tr></table></figure>
<p>​		这是一个结构体的定义，拆分看。</p>
<p>​		<strong>struct student:</strong> struct 是定义结构体必备的前缀。student 是结构体标签。 struct student 可 以像 int、double、float 作为定义变量的数据类型。</p>
<p>​		**{} 内的变量：** 结构体就像个模板，能规定好里面填什么变量。</p>
<p>​		**student1：** 定义 struct student 类型的变量 .</p>
<p><strong>typedef</strong></p>
<p>​		<strong>typedef</strong> 这是一个重命名的关键字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typedef + 数据类型 + 你想要重命名的英文</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">double</span> weight;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;Stu;</span><br></pre></td></tr></table></figure>
<p>​		typedef 在这段代码中将 stu 等效成了  <code>struct student ，而不是一个 struct student</code>  类型的变量。</p>
<p>​		<strong>结构体变量的初始化</strong></p>
<p>​		结构体也是一种数据类型，从某种程度上说与 int 等类似，属于同级，所以定义变量的方式也是一样的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">truct Stu stu1,stu2; <span class="comment">//这里定义了Stu类型的变量</span></span><br></pre></td></tr></table></figure>
<p>​		<strong>结构体成员的赋值</strong></p>
<p>​		结构体成员的获取形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">结构体变量名.成员名;</span><br></pre></td></tr></table></figure>
<p>​		<strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Stu stu1;</span><br><span class="line">stu1.height = <span class="number">175</span>;</span><br><span class="line">stu1.name = <span class="string">&#x27;辰灏&#x27;</span>;</span><br><span class="line">stu1.weight = <span class="number">100.0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;身高：%d,姓名：%s,体重：%lf\n&quot;</span>,stu1.height,stu1.name,stu1.weight);</span><br></pre></td></tr></table></figure>
<h2 id="结构体的使用"><a class="markdownIt-Anchor" href="#结构体的使用">#</a> 结构体的使用</h2>
<ul>
<li>在结构体中使用数组</li>
</ul>
<p><strong>结构体中的成员变量可以是数组，没有什么特别的。</strong></p>
<ul>
<li>结构体与指针</li>
</ul>
<p><strong>结构体可以作为函数的参数传进子函数中，然后在子函数中使用.</strong></p>
<p><strong>下面是一个输出函数</strong></p>
<p><strong>Node 是一个结构体，print () 是一个子函数，这个子函数有一个 Node 类型的参数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Stu *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,stu-&gt;height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a class="markdownIt-Anchor" href="#链表">#</a> 链表</h2>
<p>结构体变量指针</p>
<ul>
<li>结构体变量指向自身</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">table</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">table</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在初始化时，变量next,会指向自身，所以在初始化变量时要把next指针置NULL。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>指向其它结构变量</p>
<p>​	即将定义的两个结构体变量，比方说定义了 st1 和 st2 两个结构体变量，只需要将 st2 的地址 赋给 st1 的指针域，这样 st1 的指针就指向了 st2。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">table</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">strcut table st1 = &#123;<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">table</span> <span class="title">st2</span> =</span> &#123;<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">st1.next = &amp;st2;</span><br></pre></td></tr></table></figure>
<h3 id="动态创建链表"><a class="markdownIt-Anchor" href="#动态创建链表">#</a> 动态创建链表</h3>
<ul>
<li>
<p>构造一个结构类型，此结构类型必须包含至少一个成员指针，此指针要指向此结构类型</p>
</li>
<li>
<p>定义 3 个结构体类型的指针，按照用途可以命名为，p_head,p_rail,p_new</p>
</li>
<li>
<p>动态生成新的结点，为各成员变量赋值，最后加到链表当中。</p>
</li>
<li>
<p>动态创建的链表，没有一个单独的变量名去寻找到节点，全部都是由结构体中的 next 指针找 到下一个节点</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">short</span> i; <span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">char</span> c; <span class="comment">///数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span> <span class="comment">//指针域，用于指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure>
<p>​		定义结构体指针，不一定要在 main 函数中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Node *p_head,*p_rail,*p_new ;</span><br></pre></td></tr></table></figure>
<h3 id="使用malloc函数申请存储空间"><a class="markdownIt-Anchor" href="#使用malloc函数申请存储空间">#</a> 使用 malloc 函数申请存储空间</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p_head = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>（struct node*) 强制类型转换</p>
</li>
<li>
<p>malloc () 申请空间函数</p>
</li>
<li>
<p>sizeof () 申请的大小函数 在使用完这个结构体以后可以使用函数</p>
</li>
<li>
<p>free () 将申请的空间释放。</p>
</li>
</ul>
<p>​	示例：</p>
<p>​		构造结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> i;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">//定义变量</span></span><br><span class="line">Node node1 = &#123;<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>&#125;;</span><br><span class="line">Node node2 = &#123;<span class="number">2</span>,<span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line">Node node3 = &#123;<span class="number">3</span>,<span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//链表连接</span></span><br><span class="line">node1.next = &amp;node2;</span><br><span class="line">node2.next = &amp;node3;</span><br><span class="line"><span class="comment">//动态申请节点并添加到链表中</span></span><br><span class="line">Node *p_new;</span><br><span class="line">p_new = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">p_new-&gt;i = <span class="number">4</span>;</span><br><span class="line">p_new-&gt;c = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">node3.next = p_new;</span><br></pre></td></tr></table></figure>
<h3 id="链表操作"><a class="markdownIt-Anchor" href="#链表操作">#</a> 链表操作</h3>
<p>插入</p>
<p><img src="https://s3.bmp.ovh/imgs/2021/10/0bf521dd435c6a14.png" alt></p>
<ul>
<li>插入节点到头节点之前</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Node p_new = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//创建新结点，并为其开辟空间</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;(p_new-&gt;i),&amp;(p_new-&gt;c)); <span class="comment">//录入结点数据</span></span><br><span class="line"><span class="comment">//插入节点</span></span><br><span class="line">p_new-&gt;next = p_head;</span><br><span class="line">p_head = p_new;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入节点到链表中间</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Node *p_new = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//创建新结点，并为其开辟空间</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;(p_new-&gt;i),&amp;(p_new-&gt;c)); <span class="comment">//录入结点数据</span></span><br><span class="line">Node *p_front = p_head-&gt;next;</span><br><span class="line">p_new-&gt;next = p_front-&gt;next;</span><br><span class="line">p_front-&gt;next = p_new;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入节点到末尾</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!p)&#123; <span class="comment">//如果p是空的</span></span><br><span class="line">p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;(p-&gt;i),&amp;(p-&gt;c)); <span class="comment">//录入结点数据</span></span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//next节点置空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node p_loop = p;</span><br><span class="line"><span class="keyword">while</span>(p_loop)&#123;</span><br><span class="line">p_loop = p_loop-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p_new = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;(p_new-&gt;i),&amp;(p_new-&gt;c)); <span class="comment">//录入结点数据</span></span><br><span class="line">p_new-&gt;next = <span class="literal">NULL</span>;<span class="comment">//next节点置空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除某一位置节点</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2021/10/9c1b67676cb5017d.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_list</span><span class="params">(struct node *p_head,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	strct node *p_front,*p_del;</span><br><span class="line">	p_front = p_head;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= pos - <span class="number">1</span>;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">	p_front = p_front-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">    p_del = p_front-&gt;next;</span><br><span class="line">	p_front-&gt;next = p_del-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p_del);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中Synchronized的用法（简单介绍）</title>
    <url>/passages/Java%E4%B8%ADSynchronized%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%89/</url>
    <content><![CDATA[<h1 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍">#</a> 简单介绍</h1>
<h3 id="synchronized-是java中的关键字是一种同步锁-它修饰的对象有以下几种"><a class="markdownIt-Anchor" href="#synchronized-是java中的关键字是一种同步锁-它修饰的对象有以下几种">#</a>  <code>synchronized</code>  是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种：</h3>
<p>1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号  <code>&#123;&#125;</code>  括起来的代码，作用的对象是调用这个代码块的对象；<br>
　　2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；<br>
　　3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；<br>
　　4. 修改一个类，其作用的范围是  <code>synchronized</code>  后面括号括起来的部分，作用主的对象是这个类的所有对象。</p>
<h1 id="修饰一个代码块"><a class="markdownIt-Anchor" href="#修饰一个代码块">#</a> 修饰一个代码块</h1>
<p>1、一个线程访问一个对象中的  <code>synchronized(this)</code>  同步代码块时，其他试图访问该对象的线程将被阻塞。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wbg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字synchronized&quot;</span>);</span><br><span class="line">        SyncThread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程名:&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用关键字-synchronized-运行结果"><a class="markdownIt-Anchor" href="#使用关键字-synchronized-运行结果">#</a> 使用关键字  <code>synchronized</code>  运行结果</h2>
<p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813202814267-1084435693.png" alt="img"></p>
<h2 id="不使用关键字-synchronized-运行结果"><a class="markdownIt-Anchor" href="#不使用关键字-synchronized-运行结果">#</a> 不使用关键字  <code>synchronized</code>  运行结果</h2>
<p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813215801141-1864858293.png" alt="img"></p>
<p>当两个并发线程 (  <code>thread1</code>  和  <code>thread2</code>  ) 访问同一个对象 (  <code>syncThread</code>  ) 中的  <code>synchronized</code>  代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。  <code>Thread1</code>  和  <code>thread2</code>  是互斥的，因为在执行  <code>synchronized</code>  代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。<br>
我们再把  <code>SyncThread</code>  的调用稍微改一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字synchronized每次调用进行new SyncThread()&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread( <span class="keyword">new</span> SyncThread(), <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread( <span class="keyword">new</span> SyncThread(), <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果">#</a> 运行结果</h2>
<p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813220831864-787748019.png" alt="img"></p>
<p>为什么上面的例子中  <code>thread1</code>  和  <code>thread2</code>  同时在执行。这是因为  <code>synchronized</code>  只锁定对象，每个对象只有一个锁（  <code>lock</code>  ）与之相关联，而上面的代码等同于下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字synchronized每次调用进行new SyncThread()&quot;</span>);</span><br><span class="line">        SyncThread syncThread1 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        SyncThread syncThread2 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncThread1, <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncThread2, <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这时创建了两个  <code>SyncThread</code>  的对象  <code>syncThread1</code>  和  <code>syncThread2</code>  ，线程  <code>thread1</code>  执行的是  <code>syncThread1</code>  对象中的  <code>synchronized</code>  代码 (  <code>run</code>  )，而线程  <code>thread2</code>  执行的是  <code>syncThread2</code>  对象中的  <code>synchronized</code>  代码 (  <code>run</code>  )；我们知道  <code>synchronized</code>  锁定的是对象，这时会有两把锁分别锁定  <code>syncThread1</code>  对象和  <code>syncThread2</code>  对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。</p>
<h2 id="二-当一个线程访问对象的一个-synchronizedthis-同步代码块时另一个线程仍然可以访问该对象中的非-synchronizedthis-同步代码块"><a class="markdownIt-Anchor" href="#二-当一个线程访问对象的一个-synchronizedthis-同步代码块时另一个线程仍然可以访问该对象中的非-synchronizedthis-同步代码块">#</a> 二、当一个线程访问对象的一个  <code>synchronized(this)</code>  同步代码块时，另一个线程仍然可以访问该对象中的非  <code>synchronized(this)</code>  同步代码块。</h2>
<h3 id="多个线程访问-synchronized-和非-synchronized-代码块"><a class="markdownIt-Anchor" href="#多个线程访问-synchronized-和非-synchronized-代码块">#</a> 多个线程访问  <code>synchronized</code>  和非  <code>synchronized</code>  代码块</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字synchronized&quot;</span>);</span><br><span class="line">        Mthreads mt=<span class="keyword">new</span> Mthreads();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(mt, <span class="string">&quot;mt1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(mt, <span class="string">&quot;mt2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mthreads</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mthreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非synchronized代码块，未对count进行读写操作，所以可以不用synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; count:&quot;</span> + count);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">if</span> (threadName.equals(<span class="string">&quot;mt1&quot;</span>)) &#123;</span><br><span class="line">            countAdd();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threadName.equals(<span class="string">&quot;mt2&quot;</span>)) &#123;</span><br><span class="line">            printCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-2"><a class="markdownIt-Anchor" href="#运行结果-2">#</a> 运行结果</h3>
<p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813222142309-231904508.png" alt="img"></p>
<p>上面代码中  <code>countAdd</code>  是一个  <code>synchronized</code>  的，  <code>printCount</code>  是非  <code>synchronized</code>  的。从上面的结果中可以看出一个线程访问一个对象的  <code>synchronized</code>  代码块时，别的线程可以访问该对象的非  <code>synchronized</code>  代码块而不受阻塞。</p>
<h1 id="修饰一个方法"><a class="markdownIt-Anchor" href="#修饰一个方法">#</a> 修饰一个方法</h1>
<p><code>Synchronized</code>  修饰一个方法很简单，就是在方法的前面加  <code>synchronized</code>  ，  <code>public synchronized void method()&#123;&#125;</code>  ;   <code>synchronized</code>  修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。如将的  <code>run</code>  方法改成如下的方式，实现的效果一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;线程名:&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                   Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813222952717-956438905.png" alt="img"></p>
<h2 id="synchronized-作用于整个方法的写法"><a class="markdownIt-Anchor" href="#synchronized-作用于整个方法的写法">#</a>  <code>Synchronized</code>  作用于整个方法的写法。</h2>
<p>写法一:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法二:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。</p>
<p>在用  <code>synchronized</code>  修饰方法时要注意以下要点：</p>
<p><strong> <code>synchronized</code>  关键字不能继承。</strong><br>
虽然可以使用  <code>synchronized</code>  来定义方法，但  <code>synchronized</code>  并不属于方法定义的一部分，因此，  <code>synchronized</code>  关键字不能被继承。如果在父类中的某个方法使用了  <code>synchronized</code>  关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上  <code>synchronized</code>  关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下：<br>
在子类方法中加上  <code>synchronized</code>  关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lass Parent &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子类方法中调用父类的同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; <span class="keyword">super</span>.method();   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><font color="Red">在定义接口方法时不能使用 synchronized 关键字。</font></p>
<p><font color="Red">构造方法不能使用 synchronized 关键字，但可以使用 synchronized 代码块来进行同步。</font></p>
<h1 id="修饰一个静态的方法"><a class="markdownIt-Anchor" href="#修饰一个静态的方法">#</a> 修饰一个静态的方法</h1>
<p><code>Synchronized</code>  也可修饰一个静态方法，用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道静态方法是属于类的而不属于对象的。同样的，  <code>synchronized</code>  修饰的静态方法锁定的是这个类的所有对象。</p>
<h2 id="synchronized-修饰静态方法"><a class="markdownIt-Anchor" href="#synchronized-修饰静态方法">#</a>  <code>synchronized</code>  修饰静态方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wbg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字静态synchronized&quot;</span>);</span><br><span class="line">        SyncThread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果-3"><a class="markdownIt-Anchor" href="#运行结果-3">#</a> 运行结果</h2>
<p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813224017511-578390484.png" alt="img"></p>
<p><code>syncThread1</code>  和  <code>syncThread2</code>  是  <code>SyncThread</code>  的两个对象，但在  <code>thread1</code>  和  <code>thread2</code>  并发执行时却保持了线程同步。这是因为  <code>run</code>  中调用了静态方法  <code>method</code>  ，而静态方法是属于类的，所以  <code>syncThread1</code>  和  <code>syncThread2</code>  相当于用了同一把锁。这与使用关键字  <code>synchronized</code>  运行结果相同</p>
<h1 id="修饰一个类"><a class="markdownIt-Anchor" href="#修饰一个类">#</a> 修饰一个类</h1>
<p><code>Synchronized</code>  还可作用于一个类，用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wbg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用ClassName&quot;</span>);</span><br><span class="line">        SyncThread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ClassName.class) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(SyncThread.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果-4"><a class="markdownIt-Anchor" href="#运行结果-4">#</a> 运行结果</h2>
<p><img src="https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180813224557391-772452008.png" alt="img"></p>
<p>效果和上面  <code>synchronized</code>  修饰静态方法是一样的，  <code>synchronized</code>  作用于一个类  <code>T</code>  时，是给这个类  <code>T</code>  加锁，  <code>T</code>  的所有对象用的是同一把锁。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h1>
<p>1、 无论  <code>synchronized</code>  关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果  <code>synchronized</code>  作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。<br>
2、每个对象只有一个锁（  <code>lock</code>  ）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。<br>
3、实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</p>
<p>原文链接：<a href="https://www.cnblogs.com/weibanggang/p/9470718.html">Java 中 Synchronized 的用法（简单介绍）</a></p>
]]></content>
      <tags>
        <tag>算法作业</tag>
      </tags>
  </entry>
  <entry>
    <title>First Blog</title>
    <url>/passages/First-Blog/</url>
    <content><![CDATA[<p>First Blog 完成啦！</p>
<p>博客可算是搭好了，等了好久终于等到今天～～</p>
<p>想说的话：现在保证能跑就行</p>
<p>‘Text.’</p>
<p><a href="https://cn.bing.com/?mkt=zh-CN">必应 (bing.com)</a></p>
<p><code>printf()</code>  函数</p>
]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO+GitHub搭建博客的小教程</title>
    <url>/passages/HEXO+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%B0%8F%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="如何用hexo搭建自己的博客及美化自己的博客"><a class="markdownIt-Anchor" href="#如何用hexo搭建自己的博客及美化自己的博客">#</a> 如何用 hexo 搭建自己的博客及美化自己的博客</h1>
<p>这是我配好环境使用 hexo 写的第一篇博客</p>
<p>这里特别感谢各位大佬们的支持与帮助 ε≡٩(๑&gt;₃&lt;)۶</p>
<h2 id="配置相关环境"><a class="markdownIt-Anchor" href="#配置相关环境">#</a> 配置相关环境</h2>
<p>要想创建自己的 hexo 博客需要配置相关的环境（我前几次就经常把环境搞炸），接下来开始配置创建博客所必须的环境</p>
<p>过程来源: <strong>Gaein nidb</strong>，<strong>Code Sheep</strong>.</p>
<p>相关视频链接: <a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=4666682153927695444">https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=4666682153927695444</a></p>
<h3 id="安装nodejs"><a class="markdownIt-Anchor" href="#安装nodejs">#</a> 安装 Node.js</h3>
<p>可以去<a href="https://www.nodejs.org/"> https://www.nodejs.org</a> 网址下载</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/1.png" alt></p>
<p>选择左边 LTS (长期支持版) 下载，安装时无脑下一步即可</p>
<p>安装完成之后会有两个组件，如图所示</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/2.png" alt></p>
<p>可以顺带检查一下它们俩的版本，按下键盘的 win + R 键，在弹出面板输入 cmd，打开 dos 命令窗口。</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/3.png" alt></p>
<p>输入 npm -v 和 node -v</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/4.png" alt></p>
<p>我们需要利用 npm 安装镜像包，但是因为国内的下载速度比较慢，所以我们需要下载一个 cnpm 淘宝的源</p>
<p>在 dos 命令窗口中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>如果安装成功，可以在 dos 命令窗口输入 cnpm 检查一下</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/5.png" alt></p>
<p>然后使用 cnpm 安装 hexo 框架</p>
<p>在 dos 命令窗口输入 cnpm install -g hexo-cli</p>
<p>如果安装成功，可以在 dos 命令窗口输入 hexo -v 检查一下</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/6.png" alt></p>
<p>那么你的环境已经配置好了，我们来正式搭建 hexo 博客</p>
<h2 id="在本地创建hexo的博客"><a class="markdownIt-Anchor" href="#在本地创建hexo的博客">#</a> 在本地创建 hexo 的博客</h2>
<p>首先我们需要一个存放你博客的文件夹，所以第一步我们需要新建一个文件夹。</p>
<p>举个栗子：C:\Users\fiower\Documents\blog 这是我的文件夹路径</p>
<p>我们终于可以创建自己的博客了 (๑╹◡╹)ﾉ”””</p>
<p>由于本人没有用过 powershell（菜），所以接下来我们使用 dos 命令窗口 (git bash）创建本地博客</p>
<p>只需要两种方法选一即可 (这里以 dos 命令窗口为例，git bash 和 dos 命令窗口的指令是完全一样的，搭建时没必要纠结使用哪个)</p>
<h3 id="使用dos命令窗口"><a class="markdownIt-Anchor" href="#使用dos命令窗口">#</a> 使用 dos 命令窗口</h3>
<p>按下键盘的 win + R 键，在弹出面板输入 cmd，打开 dos 命令窗口。</p>
<p>这时路径默认是 C:\Users\ 你的用户名字 &gt;</p>
<p>输入 cd 你的博客所在路径 转入你的博客路径</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/7.png" alt></p>
<h3 id="使用git-bash"><a class="markdownIt-Anchor" href="#使用git-bash">#</a> 使用 git bash</h3>
<p>在你的博客文件夹下按下右键，点击 git bash</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/8.jpg" alt></p>
<h2 id="开始创建本地博客"><a class="markdownIt-Anchor" href="#开始创建本地博客">#</a> 开始创建本地博客</h2>
<p>输入 hexo init 并按下回车等待</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/9.png" alt></p>
<p>这时你的目标文件夹就会多出一些文件</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/10.png" alt></p>
<p>那么恭喜你，现在 hexo 博客已经配置完毕了（bushi</p>
<p>继续在 dos 命令窗口输入 hexo s 并按下回车等待</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/10.png" alt></p>
<p>如图所示，这时候出现了一个 4000 端口的网址</p>
<p>让我们在浏览器内打开这个网址</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/13.png" alt></p>
<p>我们的第一个本地博客就搭建好了</p>
<p>但是你的程序还在运行着，这时候需要在 dos 窗口 /git bash 窗口中按下 Ctrl + C 键即可中断本地网址的建立（hexo s 以后会用于博客写入新东西时的调试工作）</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/14.png" alt></p>
<p>如果你没有成功到达这一步，不用害怕，只需要把你创建的文件夹<strong>干掉重来</strong>即可，多试试几次总会成功的</p>
<h2 id="将hexo博客同步到远端github"><a class="markdownIt-Anchor" href="#将hexo博客同步到远端github">#</a> 将 hexo 博客同步到远端 (Github)</h2>
<p>我相信你已经非常兴奋而且想要把你的博客让朋友们看到，别急，现在我们就把自己的博客部署到远端</p>
<p>接下来我们要把自己的博客部署到 Github 上 (毫无疑问需要你的账号，没有的小伙伴需注册)</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/15.png" alt></p>
<p>新建一个仓库</p>
<p><em><strong>* 注意，用户部署个人博客的 Github 仓库的命名必须符合特定要求 *</strong></em></p>
<p><em><strong>* 命名格式为：  <a href="http://xn--Github-on9i027mnx4aga157g.github.io">你的 Github 的昵称.github.io</a>*</strong></em></p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/16.png" alt></p>
<p>建立了空仓库之后，我们需要装一个插件</p>
<p>在命令行中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/17.png" alt></p>
<p>然后用 vscode 打开你的 blog 的根目录_config.yml 文件 (没有安装 vscode 的话也可以选择记事本打开)</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/18.png" alt></p>
<p>由于我没有新建空仓库，放一张 CodeSheep 的图片 (这样获取你部署到远端的网址)</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/19.png" alt="aaa"></p>
<p>然后在 dos 命令窗口输入 hexo d</p>
<p>这样你的 hexo 博客就部署到了远端 (所有人都可以用这个网址访问你的博客了)</p>
<h2 id="美化自己的hexo博客"><a class="markdownIt-Anchor" href="#美化自己的hexo博客">#</a> 美化自己的 hexo 博客</h2>
<p>首先你需要下载一个博客的主题 (如果你认为你的博客默认主题已经非常好看的了请忽略我说的话)</p>
<p>我们以 ad 主题为例（分站使用的是 ad 主题</p>
<p>你需要先找见 ad 主题在 github 的网址，以便把这个主题克隆到自己的文件夹里面</p>
<p>ad 主题地址:<a href="https://github.com/dongyuanxin/theme-ad">https://github.com/dongyuanxin/theme-ad</a></p>
<p>然后我们需要在命令行中输入 git clone <a href="https://github.com/dongyuanxin/theme-ad.git">https://github.com/dongyuanxin/theme-ad.git</a> themes/ad</p>
<p>这样就能把 ad 的主题文件克隆到你的 themes 文件夹里面了</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/20.png" alt></p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/21.png" alt="aaa"></p>
<p>用 vscode 打开你的 blog 的根目录_config.yml 文件，修改<strong> themes: landscape 为 themes: ad</strong></p>
<p>然后保存退出</p>
<p>在命令行输入 hexo s 进行调试，打开 4000 端口</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/22.png" alt></p>
<p>然后输入 hexo clean 清楚临时缓存的文件，输入 hexo d 部署到远端</p>
<p>这样我们的主题就修改好了</p>
<h3 id="如何修改博客上的一些内容"><a class="markdownIt-Anchor" href="#如何修改博客上的一些内容">#</a> 如何修改博客上的一些内容</h3>
<p>这里的内容指的是超链接，修改博客文字内容等操作，可以使你的博客更加个性化 (也许 (っ・̀ω・́) っ✎⁾⁾)</p>
<p>相信你已经发现了，blog 的根目录_config.yml 文件很重要，打开发现有很多设置的东西</p>
<p>其实你 themes 目录下的主题也有_config.yml 文件，只要你打开它，我相信你就会知道怎么使用它了 (确信)</p>
<h3 id="如何在文章中加入超链接"><a class="markdownIt-Anchor" href="#如何在文章中加入超链接">#</a> 如何在文章中加入超链接</h3>
<p>你可以使用 Typora 来写文章，可以直接使用超链接的格式，当然也可以用其他的软件来写 (<s>比如记事本</s>)</p>
<p>格式:[你想写的内容]+(你想加入的链接)</p>
<p>这是基于 markdown 语法的格式，markdown 格式的参考网址可以参考我在下文放出的链接</p>
<h3 id="如何写文章及在写文章时加入图片不推荐建议使用图片链接"><a class="markdownIt-Anchor" href="#如何写文章及在写文章时加入图片不推荐建议使用图片链接">#</a> 如何写文章及在写文章时加入图片（不推荐，建议使用图片链接）</h3>
<p>我们只需在命令行输入 hexo new “文章标题” 就可以创建一个空文件夹了，然后可以打开改.md 文件进行写入内容</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/23.png" alt></p>
<p>那么问题来了，如何才能写出像我一样带有图片的文章呢？</p>
<p>我们需要再下载一个插件</p>
<p>我们需要打开 git bash (dos 也可以) 输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>然后打开 hexo 的配置文件_config.yml</p>
<p>找到 post_asset_folder，把这个选项从 false 改成 true</p>
<p>这样我们每次新建的文章都会带有一个同名的文件夹 (原来的文件可以直接新建同名文件夹食用)</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/24.png" alt="aaa"></p>
<p>由于 hexo 文章是基于 markdown 语法写的，我们需要如何用 markdown 语法插入图片</p>
<p>参考网址:<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p>
<p>格式：比如我这篇文章就是这样写的:</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/25.png" alt></p>
<p>这样就可以在文章中间加入图片了 qwq</p>
<h3 id="如何写文章及在写文章时加入音乐播放器"><a class="markdownIt-Anchor" href="#如何写文章及在写文章时加入音乐播放器">#</a> 如何写文章及在写文章时加入音乐播放器</h3>
<p>我相信有些人喜欢和我一样在博客中加入音乐播放器 (显得有 13 格)，所以和我一起在自己的博客中加入这个好玩的东西吧</p>
<p>由于是我自学的如何插入，本文只能简单的进行插入工作 (菜)</p>
<p>原文链接 <a href="https://blog.csdn.net/thewindkee/article/details/55086735?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-4.control">https://blog.csdn.net/thewindkee/article/details/55086735?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-4.control</a></p>
<p>我接下来展示如何在 ad 主题下添加网易云音乐播放器</p>
<p>首先我们打开网页版网易云，选择一首你喜欢的歌曲</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/26.png" alt></p>
<p>点击” 生成外链播放器”</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/27.png" alt="aaa"></p>
<p>复制这个 HTML 代码</p>
<p>然后打开路径 themes\ad\layout\partials 下的 head.ejs 文件</p>
<p>(选择 head 是为了让播放器放到博客的左上角，当然我们也可以选择这个文件夹的任意文件进行修改)</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/28.png" alt="aaa"></p>
<p>加入这段代码</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/29.png" alt="aaa"></p>
<p>这样播放器就可以部署到你的博客里面了，但是我们还需要调一下 css 样式</p>
<p>打开路径 themes\ad\source\css</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/30.png" alt></p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/31.png" alt="aaa"></p>
<p margin-top: 80px;>.header-music</p>
<p>这样我们的播放器就可以部署到博客上了</p>
<p>![<img src="https://water-boiled-fish.github.io/2020/09/03/hexo/32.png" alt="aaa"></p>
<h3 id="如何写文章及在写文章时加入音乐播放器升级版"><a class="markdownIt-Anchor" href="#如何写文章及在写文章时加入音乐播放器升级版">#</a> 如何写文章及在写文章时加入音乐播放器 (升级版）</h3>
<p>由于我看了隔壁学长 farewell 的博客发现他的播放器和我上面配置的不一样 (我的太菜了)</p>
<p>所以我决定我也要搞一个，但是这个过程并不顺利。。。经过我艰苦卓绝的努力，终于找到一个教程，现在用我的方法呈现出来</p>
<p>原文链接 <a href="https://www.cnblogs.com/fby698/p/12663089.html">https://www.cnblogs.com/fby698/p/12663089.html</a></p>
<p>Aplayer 官网文档：<a href="https://aplayer.js.org/#/">https://aplayer.js.org/#/</a></p>
<p>Metingjs 官网文档：<a href="https://github.com/metowolf/MetingJS">https://github.com/metowolf/MetingJS</a><br>
| 选项                        | 默认        | 描述                                                         |<br>
| ————————— | ———– | ———————————————————— |<br>
| server (平台)                | <strong>require</strong> | 音乐平台： <code>netease</code> ， <code>tencent</code> ， <code>kugou</code> ， <code>xiami</code> ， <code>baidu</code>     |<br>
| id (编号)                    | <strong>require</strong> | 歌曲 ID / 播放列表 ID / 专辑 ID / 搜索关键字                       |<br>
| auto（支持类种 类）         | options     | 音乐链接，支持： <code>netease</code> ， <code>tencent</code> ， <code>xiami</code>                 |<br>
| type（类型）                | <strong>require</strong> |  <code>song</code> ， <code>playlist</code> ， <code>album</code> ， <code>search</code> ， <code>artist</code>               |<br>
| fixed（固定模式）           |  <code>false</code>      | 启用固定模式，默认 <code>false</code>                                     |<br>
| mini（迷你模式）            |  <code>false</code>      | 启用迷你模式，默认 <code>false</code>                                      |<br>
| autoplay（自动播放）        |  <code>false</code>      | 音频自动播放，默认 <code>false</code>                                     |<br>
| theme (主题颜色)             |  <code>#2980b9</code>    | 默认 <code>#2980b9</code>                                                 |<br>
| loop（循环）                |  <code>all</code>        | 播放器循环播放，值：“all”，one”，“none”                      |<br>
| order (顺序)                 |  <code>list</code>       | 播放器播放顺序，值：“list”，“random”                         |<br>
| preload (加载)               |  <code>auto</code>       | 值：“none”，“metadata”，“’auto”                              |<br>
| volume（声量）              |  <code>0.7</code>        | 默认音量，请注意播放器会记住用户设置，用户自己设置音量后默认音量将不起作用 |<br>
| mutex（限制）               |  <code>true</code>       | 防止同时播放多个玩家，在该玩家开始播放时暂停其他玩家         |<br>
| lrc-type（歌词）            |  <code>0</code>          | 歌词显示                                                     |<br>
| list-folded（列表折叠）     |  <code>false</code>      | 指示列表是否应该首先折叠                                     |<br>
| list-max-height（最大高度） |  <code>340px</code>      | 列出最大高度                                                 |<br>
| storage-name（储存名称）    |  <code>metingjs</code>   | 存储播放器设置的 localStorage 键                               |<br>
 然后在你博客的适当位置加入以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         &lt;!-- 引用Aplayer和metingjs --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;div id=&quot;my-aplayer&quot;</span><br><span class="line">	class=&quot;aplayer&quot; </span><br><span class="line">	data-id=&quot;706800324&quot; </span><br><span class="line">  data-server=&quot;netease&quot; </span><br><span class="line">  data-mini=&quot;false&quot;</span><br><span class="line">	data-type=&quot;playlist&quot; </span><br><span class="line">	data-fixed=&quot;false&quot; // 吸底模式可以固定播放器于页面底部(这个底部指的是你屏幕下方，并非指的网页下方)</span><br><span class="line">	data-autoplay=&quot;fals&quot; </span><br><span class="line">	data-order=&quot;list&quot; </span><br><span class="line">  data-volume=&quot;0.55&quot; </span><br><span class="line">  data-list-folded=&quot;ture&quot;</span><br><span class="line">  data-theme=&quot;#66CCFF&quot; </span><br><span class="line">  data-list-max-height=&quot;340px&quot;</span><br><span class="line">  data-preload=&quot;auto&quot; </span><br></pre></td></tr></table></figure>
<p><strong>适当位置</strong>指的是你博客的主界面的文件中的位置，举个栗子</p>
<p>选择 themes\ad\layout\partials\footer.ejs (因为我使用的 ad 主题，所以这里以 ad 主题为例，若使用其他主题，只需要点开对应主题的.ejs 文件)</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/26.png" alt></p>
<p>然后在适当位置加入代码 (该代码在文件中的位置直接对应到播放器在你的博客页面的位置)</p>
<p>比如我的就是在这里加的</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/27.png" alt="aaa"></p>
<p>需要注意的是，你这样拷贝的是我的播放器列表 (当然用我的歌单我将感激不尽)，我相信你肯定想拥有一个属于自己的播放列表</p>
<p>这里就拿网易云音乐举例，仔细看上面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data-id=&quot;706800324&quot; </span><br><span class="line">data-server=&quot;netease&quot; </span><br></pre></td></tr></table></figure>
<p>我相信你如果仔细看过上面的表格的话一定知道我想表达什么了 (<s>可能</s>)</p>
<p>你首先需要选择你需要播放的音乐平台，比如你想使用网易云，就在 data-serve 后面输入 <code>netease</code> ，你想使用 qq 音乐，就在 data-serve 后面输入 <code>tencent</code> ，以此类推。。。</p>
<p>不管你是哪个平台的忠实听众，你的每个歌单都有属于它自己的 id，你需要的是把这个 id 找到然后 cv 到你的 data-id 上</p>
<p>接下来让我们看看这么才能找到你歌单的 id</p>
<p>首先打开网页版的网易云音乐，然后<s>登陆</s>，找到自己的歌单</p>
<p><img src="https://water-boiled-fish.github.io/2020/09/03/hexo/28.png" alt="aaa"></p>
<p>看见最上方链接的那一串数字了没？那就是我们想要的东西</p>
<p>赶快 cv 一下，然后粘贴替换掉上面我的 id (<s>悲</s>)</p>
<p>然后你的这段代码就是你自己的了，赶快 hexo s 试一试</p>
<p>该播放器的更多使用方法在上方表格内都写出来了，如果看见代码里面没有的但是表格中确实有使用方法的，可以手动添加，在代码末端加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data-选项名称(英文)=“ ”</span><br></pre></td></tr></table></figure>
<p>这样达到你需要的目的，其他选项可以自行修改，更多使用方法请自行尝试 (<s>因为那些也就改几个字的事情，没必要教</s>)</p>
<p><s>emmmmm 其实有的主题在主题对应的_config.yml 文件中就已经配置好了</s></p>
<h3 id="如何在博客中加入live_2d看板娘"><a class="markdownIt-Anchor" href="#如何在博客中加入live_2d看板娘">#</a> 如何在博客中加入 live_2d 看板娘</h3>
<p>因为我还没有学过 HTML 的用法，所以我只能部署一个比较简单的 live_2d 看板娘</p>
<p>在命令行输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
<p>安装</p>
<p>但是这个 live2d 的插件真的一言难尽 (我和学长一致认为这个 live2d 插件自带的人物很少 (<s>且不对我 xp</s>) 且不能自行添加)</p>
<p>安装截图我就不放了，毕竟能看到这里的都安装过不下 10 次了吧 (</p>
<p>安装好了之后就可以去下载 live2d 文件了 (其实你也可以边等边下载的)</p>
<p>下载地址:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</span><br></pre></td></tr></table></figure>
<p>下载的文件是文件夹格式的，我们需要把它们移到（）文件路径中</p>
<p>然后你还需要再次修改根目录中的_config.yml 文件，修改代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">live2d:  enable: true  pluginModelPath: assets/  model:    use: live2d-widget-model-xxx  #这是你需要把模板放入的目录，在node_modules里，xxx表示你的live_2d的具体文件  display:    position: right      #放置在你的博客的左下还是右下    width: 150     height: 300  mobile:    show: false  #是否在手机进行显示</span><br></pre></td></tr></table></figure>
<p>原文章代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">live2d:  enable: true  scriptFrom: local  pluginRootPath: live2dw/  pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  log: false  model:    use: live2d-widget-model-wanko  display:    position: right    width: 150    height: 300  mobile:    show: true  react:    opacity: 0.7</span><br></pre></td></tr></table></figure>
<p>如图所示</p>
<p>（）</p>
<p>然后你就可以在命令行中输入 hexo s 来进行本地调试了</p>
<p>选择一个你喜欢的 live_2d 吧ヾ (๑╹◡╹)ﾉ”</p>
<p><strong>未完待续（文章有点小问题，找时间改改）</strong></p>
<p><strong>原文链接：<a href="https://water-boiled-fish.github.io/2020/09/03/hexo/">使用 hexo 搭建自己的博客及美化与上传 Github | Little_Flower_Fa (water-boiled-fish.github.io)</a></strong></p>
<p>（白嫖什么的，真香）</p>
]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1226-哲学家进餐</title>
    <url>/passages/Leetcode-1226-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90/</url>
    <content><![CDATA[<h1 id="leetcode-1226-哲学家进餐"><a class="markdownIt-Anchor" href="#leetcode-1226-哲学家进餐">#</a> Leetcode 1226. 哲学家进餐</h1>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2>
<p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p>
<p>所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p>
<p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p>
<p>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/23/an_illustration_of_the_dining_philosophers_problem.png" alt></p>
<p>问题描述和图片来自维基百科 <a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">https://en.wikipedia.org/wiki/Dining_philosophers_problem</a></p>
<p>哲学家从 <strong>0</strong> 到 <strong>4</strong> 按 <strong>顺时针</strong> 编号。请实现函数  <code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code> ：</p>
<ul>
<li>
<p><code>philosopher</code>  哲学家的编号。</p>
</li>
<li>
<p><code>pickLeftFork</code>  和  <code>pickRightFork</code>  表示拿起左边或右边的叉子。</p>
</li>
<li>
<p><code>eat</code>  表示吃面。</p>
</li>
<li>
<p><code>putLeftFork</code>  和  <code>putRightFork</code>  表示放下左边或右边的叉子。</p>
</li>
<li>
<p>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。</p>
</li>
</ul>
<p>给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：[[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">解释:</span><br><span class="line">n 表示每个哲学家需要进餐的次数。</span><br><span class="line">输出数组描述了叉子的控制和进餐的调用，它的格式如下：</span><br><span class="line">output[i] = [a, b, c] (<span class="number">3</span>个整数)</span><br><span class="line"></span><br><span class="line">- a 哲学家编号。</span><br><span class="line">- b 指定叉子：&#123;<span class="number">1</span> : 左边, <span class="number">2</span> : 右边&#125;.</span><br><span class="line">- c 指定行为：&#123;<span class="number">1</span> : 拿起, <span class="number">2</span> : 放下, <span class="number">3</span> : 吃面&#125;。</span><br><span class="line">  如 [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>] 表示 <span class="number">4</span> 号哲学家拿起了右边的叉子。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 60</code></li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/the-dining-philosophers">https://leetcode-cn.com/problems/the-dining-philosophers</a><br>
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2>
<p>​		本题要求 (题意)：设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p>
<p>​		刚开始的话，简单了解到了信号量  <code>Semaphore</code>  的用法，并写了一个感觉不是很切合题意的解决方法（一个一个吃）。</p>
<p>​		之后又简单学习了  <code>synchronized</code>  的用法 (详见上一篇博客)，并按照  <code>synchronized</code>  的限制思路来写了一个  <code>synchronized</code>  修饰类内方法的解决方法（感觉也不是很符合题意）。</p>
<h3 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore">#</a> Semaphore</h3>
<p>​		  <code>Semaphore</code>  可以控制同一时间访问资源的线程总数，通过  <code>acquire()</code>  和  <code>release()</code>  来获取和释放信号量从而实现对线程数量的控制。所以我们在解体的时候可以通过限制线程总数为 1 的方法来实现一个一个吃的暴力解决办法。</p>
<p><code>Semaphore semaphore = new Semaphore(1);</code>   -&gt; 限制线程总数为 1（只有一个信号量）</p>
<p><code>semaphore.acquire(1);</code>   -&gt; 获取一个信号量，并将信号量数量 - 1</p>
<p><code>semaphore.release(1);</code>   -&gt; 释放一个信号量，并将信号量数量 + 1</p>
<h3 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized">#</a> synchronized</h3>
<p>​		被  <code>synchronized</code>  修饰的代码同一时间只能被一个作用的对象访问，  <code>synchronized</code>  修饰的位置不同，相对应的作用对象不同。例如：</p>
<p>​		  <code>synchronized</code>  修饰一个普通方法： -&gt; 作用对象为调用这个方法的对象。</p>
<p>​		  <code>synchronized</code>  修饰一个  <code>static</code>  方法： -&gt; 作用对象为这个类的所有对象。</p>
<p>由于本题中使用的是  <code>DiningPhilosophers</code>  类的同一个对象，所以两种方法均可（不过个人感觉还是  <code>synchronized</code>  修饰一个普通方法）好一些。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2>
<h3 id="semaphore-2"><a class="markdownIt-Anchor" href="#semaphore-2">#</a> Semaphore</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制线程总数为1（只有一个信号量）</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 一个一个吃</span></span><br><span class="line">        semaphore.acquire(<span class="number">1</span>); <span class="comment">// 获取一个信号量，并将信号量数量 - 1</span></span><br><span class="line">        pickLeftFork.run();</span><br><span class="line">        pickRightFork.run();</span><br><span class="line">        eat.run();</span><br><span class="line">        putLeftFork.run();</span><br><span class="line">        putRightFork.run();</span><br><span class="line">        semaphore.release(<span class="number">1</span>); <span class="comment">// 释放一个信号量，并将信号量数量 + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/f412682f61fb2cf2.png" alt></p>
<h3 id="synchronized-2"><a class="markdownIt-Anchor" href="#synchronized-2">#</a> synchronized</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于 i 号哲学家，需要获取 [i, i%5] 号筷子。但是获取筷子之前需要让synchronized获取到对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="comment">// 由于本题中使用的是DiningPhilosophers类的同一个对象，所以该方法可以是普通方法也可以是static方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable eat,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        pickLeftFork.run();</span><br><span class="line">        pickRightFork.run();</span><br><span class="line">        eat.run();</span><br><span class="line">        putLeftFork.run();</span><br><span class="line">        putRightFork.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/a1b53eabd78d26cd.png" alt></p>
<h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2>
<p>​		在思路上，我解决本体的方法大体上是每次只允许一个人访问资源，通过  <code>Semaphore</code>  限制进程数量和  <code>synchronized</code>  修饰方法来实现，个人感觉这两种解法不是很符合题意，但是其他的方法还未学会，只能先这样解题了。</p>
<p>​		还是有很多东西需要学习的呜呜呜 (菜鸡嘤嘤～~ ~ doge)</p>
]]></content>
      <tags>
        <tag>算法作业</tag>
      </tags>
  </entry>
  <entry>
    <title>LXRの烤箱入门食谱</title>
    <url>/passages/LXR%E3%81%AE%E7%83%A4%E7%AE%B1%E5%85%A5%E9%97%A8%E9%A3%9F%E8%B0%B1/</url>
    <content><![CDATA[<h1 id="这里来自料理菜鸟lxrの烤箱入门食谱~~"><a class="markdownIt-Anchor" href="#这里来自料理菜鸟lxrの烤箱入门食谱~~">#</a> 这里来自料理菜鸟 LXR の烤箱入门食谱～～</h1>
<p>翻到了家里落灰的烤箱  <s>因为馋</s>  所以搞了这样一份入门食谱，想把烤箱重新启用。</p>
<p>之后做料理的时候可能会保留一些照片回来补档（<s>如果还记得的话</s></p>
<p>菜鸟の菜谱内容如下：</p>
<h2 id="烤地瓜"><a class="markdownIt-Anchor" href="#烤地瓜">#</a> 烤地瓜</h2>
<h3 id="用料"><a class="markdownIt-Anchor" href="#用料">#</a> 用料</h3>
<p>地瓜 3 个，约 500 克</p>
<h3 id="做法"><a class="markdownIt-Anchor" href="#做法">#</a> 做法</h3>
<p>1、将地瓜清洗干净，擦干</p>
<p>2、将地瓜放到烤箱的烤网上，240 度，烤箱中层，烤 40 分钟即可</p>
<h3 id="小贴士"><a class="markdownIt-Anchor" href="#小贴士">#</a> 小贴士</h3>
<p>1、地瓜要选小一点的，否则烤制时间太长，费电；</p>
<p>2、地瓜的个头要均匀，否则有的熟了，有的还没熟；</p>
<p>3、用烤网烤地瓜时，下面要放一层烤盘，防止汁液流到烤箱里；</p>
<h2 id="烤玉米"><a class="markdownIt-Anchor" href="#烤玉米">#</a> 烤玉米</h2>
<h3 id="用料-2"><a class="markdownIt-Anchor" href="#用料-2">#</a> 用料</h3>
<p>玉米 2 根、黄油适量、盐适量、黑胡椒适量</p>
<h3 id="做法-2"><a class="markdownIt-Anchor" href="#做法-2">#</a> 做法</h3>
<p>1、将玉米煮熟</p>
<p>2、均匀的抹上黄油、盐、黑胡椒，入烤箱 200°15 分钟（喜欢吃口感较嫩的烤玉米可以包锡纸，喜欢有嚼劲的直接放在烤盘上即可）</p>
<h2 id="糖烤栗子"><a class="markdownIt-Anchor" href="#糖烤栗子">#</a> 糖烤栗子</h2>
<h3 id="用料-3"><a class="markdownIt-Anchor" href="#用料-3">#</a> 用料</h3>
<p>栗子一斤、色拉油一勺、糖 20 克、水 10 克</p>
<h3 id="做法-3"><a class="markdownIt-Anchor" href="#做法-3">#</a> 做法</h3>
<p>1、栗子洗净晾干，用刀在表面划一刀</p>
<p>2、栗子放入容器中，倒入色拉油拌匀</p>
<p>3、烤箱预热 200°，将栗子放入铺了锡纸的烤盘中，25 分钟。</p>
<p>4、糖和水加热混合均匀</p>
<p>5、栗子拿出烤箱，用刷子蘸糖水刷栗子表面，栗子裂开处多刷点，刷好糖水后再入烤箱烤 5 分钟左右即可（因为每家烤箱不同，可以先尝一个，再根据口感是否延长烘烤时间）</p>
<h2 id="太阳蛋烤土司"><a class="markdownIt-Anchor" href="#太阳蛋烤土司">#</a> 太阳蛋烤土司</h2>
<h3 id="用料-4"><a class="markdownIt-Anchor" href="#用料-4">#</a> 用料</h3>
<p>土司 4 片、鸡蛋两个、培根若干、沙拉酱适量、盐少许</p>
<h3 id="做法-4"><a class="markdownIt-Anchor" href="#做法-4">#</a> 做法</h3>
<p>1、首先将沙拉酱均匀涂在两片土司面包上。</p>
<p>2、另外两块面包用杯子倒扣切下一个圆型的圈。</p>
<p>3、把切好的面包盖到涂抹沙拉酱的面包上。</p>
<p>4、把鸡蛋打到两个窟窿里面，在鸡蛋上撒上少许的盐，在四周涂抹上沙拉酱，放一些培根。</p>
<p>5、烤箱 170 度，15~20 分钟即可。</p>
<h2 id="蜜汁烤翅"><a class="markdownIt-Anchor" href="#蜜汁烤翅">#</a> 蜜汁烤翅</h2>
<h3 id="用料-5"><a class="markdownIt-Anchor" href="#用料-5">#</a> 用料</h3>
<p>鸡翅若干、蜂蜜，料酒，生抽，香油，胡椒粉，糖，盐，辣椒粉（可选择）少许</p>
<h3 id="做法-5"><a class="markdownIt-Anchor" href="#做法-5">#</a> 做法</h3>
<p>1、把鸡翅放在一个比较深的碗里，加料酒，生抽（1：2，加一起能到和鸡翅齐平的高度），盐糖少许，再放些姜片去腥，加几滴香油，腌制一个小时</p>
<p>2、烤箱预热 175 度，鸡翅放入铺好锡纸的烤盘，上下火 15 分钟，拿出来刷蜂蜜</p>
<p>3、再放入烤箱烤 20 分钟，拿出来翻个面，再烤 20 分钟到鸡翅金黄即可</p>
<h2 id="盐烤虾"><a class="markdownIt-Anchor" href="#盐烤虾">#</a> 盐烤虾</h2>
<h3 id="用料-6"><a class="markdownIt-Anchor" href="#用料-6">#</a> 用料</h3>
<p>虾、姜、葱、盐、黑胡椒、料酒适量</p>
<h3 id="做法-6"><a class="markdownIt-Anchor" href="#做法-6">#</a> 做法</h3>
<p>1、虾洗净，去掉头尾尖刺，挑去虾线后沥水备用</p>
<p>2、将虾用葱、姜、料酒拌匀腌制 10 分钟</p>
<p>3、用竹签将虾串好，撒上盐、黑胡椒</p>
<p>4、烤箱预热 200 度，烤 15 分钟即可</p>
<h2 id="芝士焗生蚝"><a class="markdownIt-Anchor" href="#芝士焗生蚝">#</a> 芝士焗生蚝</h2>
<h3 id="用料-7"><a class="markdownIt-Anchor" href="#用料-7">#</a> 用料</h3>
<p>生蚝、马苏里拉芝士、培根碎、洋葱碎、蒜茸、鲜奶油适量</p>
<h3 id="做法-7"><a class="markdownIt-Anchor" href="#做法-7">#</a> 做法</h3>
<p>1、生蠔开盖后洗刷干净，用开水蒸 7 分钟后取出备用</p>
<p>2、培根碎、洋葱碎、蒜茸炒香后加入鲜奶油，放少许盐、胡椒粉，熬煮成汁，淋在蚝肉上</p>
<p>3、随后再洒满芝士，入烤箱 180 度 10 分钟左右，焗至芝士上色即可</p>
<h2 id="烤排骨"><a class="markdownIt-Anchor" href="#烤排骨">#</a> 烤排骨</h2>
<h3 id="用料-8"><a class="markdownIt-Anchor" href="#用料-8">#</a> 用料</h3>
<p>排骨、烤肉酱、土豆</p>
<h3 id="做法-8"><a class="markdownIt-Anchor" href="#做法-8">#</a> 做法</h3>
<p>1、排骨分割成条状，用烤肉酱涂匀，腌制一夜。</p>
<p>2、土豆切成大片垫在排骨下。</p>
<p>3、200 度上下火，烤 50 分钟。排骨上色后，可以加盖层锡纸。</p>
<h2 id="烤丸子"><a class="markdownIt-Anchor" href="#烤丸子">#</a> 烤丸子</h2>
<h3 id="用料-9"><a class="markdownIt-Anchor" href="#用料-9">#</a> 用料</h3>
<p>鱼丸、香菇、烧烤酱</p>
<h3 id="做法-9"><a class="markdownIt-Anchor" href="#做法-9">#</a> 做法</h3>
<p>1、鱼丸室温软化，香菇洗净，烤盘垫一层锡纸，将鱼丸和香菇们摆放在烤盘上，均匀的抹上烧烤酱。</p>
<p>2、烤箱预热 200 度，烤 15 分钟即可。</p>
<h2 id="烤布丁"><a class="markdownIt-Anchor" href="#烤布丁">#</a> 烤布丁</h2>
<h3 id="用料-10"><a class="markdownIt-Anchor" href="#用料-10">#</a> 用料</h3>
<p>牛奶 250ml、鸡蛋 2 个、细砂糖 30 克、香草精 3 滴（没有可以不加）</p>
<h3 id="做法-10"><a class="markdownIt-Anchor" href="#做法-10">#</a> 做法</h3>
<p>1、将鸡蛋打散，加入细砂糖搅拌均匀备用。</p>
<p>2、把牛奶倒入锅中，加入香草精煮到 80 度左右，关火，晾凉。</p>
<p>3、将晾凉的牛奶缓缓倒入蛋液中，一边倒入一边搅拌，直到完全混合均匀。然后将蛋奶液过一遍筛，使其更顺滑。</p>
<p>4、将蛋奶液倒入布丁碗内，并在烤盘内注入 1-2cm 高的热水。放入预热好的烤箱内，以 160 度烤约 40 分钟左右即可。</p>
<h2 id="蛋挞"><a class="markdownIt-Anchor" href="#蛋挞">#</a> 蛋挞</h2>
<h3 id="用料-11"><a class="markdownIt-Anchor" href="#用料-11">#</a> 用料</h3>
<p>现成蛋挞皮、250 毫升牛奶、2 个鸡蛋、适量糖</p>
<h3 id="做法-11"><a class="markdownIt-Anchor" href="#做法-11">#</a> 做法</h3>
<p>1、蛋挞皮提前拿出冰箱融化；</p>
<p>2、将三分一的牛奶微波炉加热，加糖搅匀，再加入剩下的牛奶；鸡蛋打散加入牛奶中，再将蛋奶液倒入蛋挞皮内，七八分满即可。</p>
<p>3、烤箱 150 度、中层、上下火、大概二十几分钟，挞皮酥松、颜色焦黄就好了。（在订阅号中回复蛋挞，可以查看更多蛋挞配方哟！）</p>
<h2 id="奶酪小饼干"><a class="markdownIt-Anchor" href="#奶酪小饼干">#</a> 奶酪小饼干</h2>
<h3 id="用料-12"><a class="markdownIt-Anchor" href="#用料-12">#</a> 用料</h3>
<p>奶油奶酪 100g、糖粉 45g、蛋黄 2 个、低粉 150g、黄油 15ml、盐 1g</p>
<h3 id="做法-12"><a class="markdownIt-Anchor" href="#做法-12">#</a> 做法</h3>
<p>1.100g 奶油奶酪，45g 白糖，2 只蛋黄，坐热水搅拌。</p>
<p>2. 搅拌至光滑无颗粒后加入 15ml 黄油。继续搅拌均匀。</p>
<p>3. 筛入 150g 低粉，1g 盐。</p>
<p>4. 揉成面团即可。擀成 2mm 厚的面饼。用饼干切模切成小块。</p>
<p>5. 摆盘，入预热好的烤箱，上火 170 度，下火 150 度烤 20 分钟左右即可。</p>
<h2 id="焗烤蔓越莓土司布丁"><a class="markdownIt-Anchor" href="#焗烤蔓越莓土司布丁">#</a> 焗烤蔓越莓土司布丁</h2>
<h3 id="用料-13"><a class="markdownIt-Anchor" href="#用料-13">#</a> 用料</h3>
<p>吐司 4 片、淡奶油 / 牛奶 180ml、蔓越梅干 / 葡萄干 / 蓝莓干 20 克、鸡蛋 3 个、细砂糖 45 克、黄油 10 克</p>
<h3 id="做法-13"><a class="markdownIt-Anchor" href="#做法-13">#</a> 做法</h3>
<p>1、吐司去边切小块</p>
<p>2、将室温软化的黄油均匀涂抹在焗碗的内部，蔓越梅干切碎</p>
<p>3、把淡奶油、鸡蛋、细砂糖在一个大碗中搅匀备用</p>
<p>4、将吐司块放入蛋奶液中浸泡，待其充分吸收汁液后捞出放入焗盘内，撒上蔓越梅干</p>
<p>5、放入预热好的烤箱中，170 度 30 分钟左右，直至表面金黄色（根据焗烤盘的大小，自己调整烘焙的时间，以表面出现漂亮的金黄色为准）</p>
<h2 id="烤香蕉"><a class="markdownIt-Anchor" href="#烤香蕉">#</a> 烤香蕉</h2>
<h3 id="用料-14"><a class="markdownIt-Anchor" href="#用料-14">#</a> 用料</h3>
<p>香蕉 4 根、黄油 20 克、细砂糖 5 克、朗姆酒 5ml、橙汁 5ml、蜂蜜 10ml</p>
<h3 id="做法-14"><a class="markdownIt-Anchor" href="#做法-14">#</a> 做法</h3>
<p>1、黄油和细砂糖放入锅中，小火融化，然后放入去皮的香蕉，用小火煎至双面金黄。</p>
<p>2、将朗姆酒倒在香蕉上，让朗姆酒遇热挥发出酒的清香，浇上橙汁后关火。</p>
<p>3、将香蕉放在铺有锡纸的烤盘中，表面刷上蜂蜜，放入预热好的烤箱中中层，160 度烤 8–10 分钟即可。</p>
<h2 id="烤水果片"><a class="markdownIt-Anchor" href="#烤水果片">#</a> 烤水果片</h2>
<h3 id="用料-15"><a class="markdownIt-Anchor" href="#用料-15">#</a> 用料</h3>
<p>菠萝、猕猴桃、苹果、梨、淡盐水、糖粉</p>
<h3 id="做法-15"><a class="markdownIt-Anchor" href="#做法-15">#</a> 做法</h3>
<p>1、将菠萝、猕猴桃去皮，切成 3 毫米厚的薄片。苹果和香梨洗净后，带皮切成 3 毫米厚的薄片。</p>
<p>2、苹果和梨切好后，放入淡盐水中浸泡。</p>
<p>3、烤盘内铺锡纸，向烤盘中筛入一层糖粉。</p>
<p>4、水果用厨房纸巾吸干表面的水份，把水果片码放在烤盘中，再在水果的表面上筛一层糖粉。</p>
<p>5、放入预热好的烤箱中，160 度烘烤 15 分钟。然后把水果片移至烤网上继续烘烤约 1 小时左右（不同水果的烤制时间不同，以烤到色泽金黄，口感筋道为准）</p>
<h1 id="补充几点"><a class="markdownIt-Anchor" href="#补充几点">#</a> 补充几点：</h1>
<p><strong>1、烤箱一定要摆放在通风的地方，不要太靠墙，便于散热。</strong></p>
<p><strong>2、烤箱最好不要放在靠近水源的地方，因为工作的时候烤箱整体温度都很高，如果碰到水的话会造成温差。</strong></p>
<p><strong>3、烤箱长时间工作时不要长时间守在烤箱前面。</strong></p>
<p><strong>4、如果烤箱的玻璃门发现有裂痕之类的请立刻停止使用。</strong></p>
<p>END</p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>料理</tag>
        <tag>菜谱</tag>
      </tags>
  </entry>
  <entry>
    <title>LXRの微波炉入门食谱</title>
    <url>/passages/LXR%E3%81%AE%E5%BE%AE%E6%B3%A2%E7%82%89%E5%85%A5%E9%97%A8%E9%A3%9F%E8%B0%B1/</url>
    <content><![CDATA[<h1 id="这里是来自料理菜鸟lxrの微波炉入门食谱~~"><a class="markdownIt-Anchor" href="#这里是来自料理菜鸟lxrの微波炉入门食谱~~">#</a> 这里是来自料理菜鸟 LXR の微波炉入门食谱～～</h1>
<p>自上次出了烤箱入门食谱之后，最近没事就翻腾家里落灰的厨房用品，发现了许久没用的微波炉，心血来潮再开个坑  <s>绝对不是因为馋</s>  所以搞了一点入门食谱过来给微波炉开开光（√。</p>
<p>最后可以拍照回来补档（<s>希望不会咕咕咕</s></p>
<p>菜鸟の菜谱内容如下：</p>
<h2 id="1蒜蓉茄子"><a class="markdownIt-Anchor" href="#1蒜蓉茄子">#</a> 1. 蒜蓉茄子</h2>
<p>蒜蓉茄子是烧烤摊上的扛把子，贼拉解馋。我好多次在深夜点烤串外卖，就为了吃烤茄子…… 后来我学会了用微波炉做烤茄子！</p>
<h3 id="原料"><a class="markdownIt-Anchor" href="#原料">#</a> 原料：</h3>
<p>茄子；酱油；孜然；十三香；耗油；醋；椒盐粉；蒜蓉酱；小辣椒（可以根据口味增删）</p>
<h3 id="步骤"><a class="markdownIt-Anchor" href="#步骤">#</a> 步骤：</h3>
<p>（1）茄子洗净，放微波炉里中高火叮 6 分钟</p>
<p>（2）将适量十三香、耗油、醋、酱油放在碗里混合</p>
<p>（3）茄子拿出来，剖开，用刀把茄子肉划几刀，不要划透</p>
<p>（4）把前面调的酱汁均匀涂在茄子上，抹上蒜蓉酱，撒上孜然、椒盐粉，喜欢吃辣可以放点辣椒碎。调料不全也没事，可以根据口味调整调料种类和用量。（建议用蒜蓉酱，自己切的蒜末没有那么入味）</p>
<p>（5）放微波炉里继续叮 5-6 分钟，中途撒上点葱末。</p>
<h2 id="2微波炉烤红薯"><a class="markdownIt-Anchor" href="#2微波炉烤红薯">#</a> 2. 微波炉烤红薯</h2>
<p>我经常在晚上用微波炉烤红薯，吃着没有罪恶感，还顶饿，关键是超级超级容易做</p>
<h3 id="原料-2"><a class="markdownIt-Anchor" href="#原料-2">#</a> 原料：</h3>
<p>红薯；厨房纸；餐巾纸</p>
<h3 id="步骤-2"><a class="markdownIt-Anchor" href="#步骤-2">#</a> 步骤：</h3>
<p>（1）挑选粗细均匀的中小号红心红薯，不要选白瓤的，没有红心的甜。把红薯洗净，切成两半，如果是比较胖的红薯可以竖着对半剖开。切开红薯熟得更快，也可以防止加热爆炸。（如果不喜欢剥皮可以在这步把皮削掉）</p>
<p>（2）红薯外面包上一层厨房纸或餐巾纸（纸薄可以包两层），把纸用水淋湿，防止红薯烤得太干。</p>
<p>（3）放微波炉里加热，根据大小不同用中高火烤 6-10 分钟，捏一下软了就可以拿出来吃了。</p>
<h2 id="3煎蛋可做无油版"><a class="markdownIt-Anchor" href="#3煎蛋可做无油版">#</a> 3. 煎蛋（可做无油版）</h2>
<p>用锅煎蛋太大材小用了，还得刷锅，还是微波炉最省事！</p>
<h3 id="原料-3"><a class="markdownIt-Anchor" href="#原料-3">#</a> 原料：</h3>
<p>鸡蛋；酱油或其他喜欢的调味料</p>
<h3 id="步骤-3"><a class="markdownIt-Anchor" href="#步骤-3">#</a> 步骤：</h3>
<p>（1）拿个可以进微波炉的盘子，里面倒点油，把油弄均匀一点。如果想做无油版可以不放油，更健康。</p>
<p>（2）把鸡蛋打进去，在蛋黄上戳几个洞，防止爆炸。（一定要扎洞！！！）</p>
<p>（3）盖上保鲜膜，保鲜膜扎几个洞，或者用盘子加个盖子。（此步可省略）</p>
<p>（4）放进微波炉中火加热 30-50 秒，看你喜欢吃几分熟的蛋了，我自己比较喜欢吃溏心的。不确定自己家微波炉的 “性格” 可以先叮 30 秒，熟度不够再继续叮一会。切记不要叮太久，口感会很差的。</p>
<p>（5）根据口味撒上点酱油、香油、盐之类的调味料，健康快手的煎蛋就做好啦。</p>
<h2 id="4三分钟鸡蛋三明治"><a class="markdownIt-Anchor" href="#4三分钟鸡蛋三明治">#</a> 4. 三分钟鸡蛋三明治</h2>
<p>早上花不到 10 分钟就能做好一个三明治，如果前一天晚上把料备好，早上 3 分钟就能做好，非常省事。</p>
<h3 id="原料-4"><a class="markdownIt-Anchor" href="#原料-4">#</a> 原料：</h3>
<p>面包片；鸡蛋；生菜；火腿</p>
<h3 id="步骤-4"><a class="markdownIt-Anchor" href="#步骤-4">#</a> 步骤：</h3>
<p>（1）鸡蛋打散均匀涂在一片面包片上，上面铺上生菜、火腿或其他喜欢的配料，另拿一片面包片盖上。可以根据自己的喜好做多层豪华版，加入芝士、培根、西红柿片也很好吃。</p>
<p>（2）入微波炉中高火烤 3-5 分钟，中间翻一次面。</p>
<h2 id="5微波炉金针菇"><a class="markdownIt-Anchor" href="#5微波炉金针菇">#</a> 5. 微波炉金针菇</h2>
<p>金针菇细细的很容易熟，烤肉的时候放边上稍微加热一会就爽口又鲜美，用微波炉做那就是轻松加愉快。我给这道菜取了个别名叫微波 see you tomorrow，有人懂我的梗吗。</p>
<h3 id="原料-5"><a class="markdownIt-Anchor" href="#原料-5">#</a> 原料：</h3>
<p>金针菇；盐；酱油；孜然粉；辣椒粉；香油</p>
<h3 id="步骤-5"><a class="markdownIt-Anchor" href="#步骤-5">#</a> 步骤：</h3>
<p>（1）金针菇去根、洗净、装盘</p>
<p>（2）把调料均匀洒在金针菇上，调料可以根据口味增删，加一点蒜泥也蛮好吃的。</p>
<p>（3）入微波炉中高火叮 2-3 分钟，别叮太久，金针菇很容易熟的，软了闻着有香味就是好了，拿出来搅拌均匀，凉一凉就能吃了。喜欢葱可以加一点葱花，又香又爽口。</p>
<h2 id="6奥尔良烤翅"><a class="markdownIt-Anchor" href="#6奥尔良烤翅">#</a> 6. 奥尔良烤翅</h2>
<p>看成品绝对想不到竟然那么容易做，味道超级好～</p>
<h3 id="原料-6"><a class="markdownIt-Anchor" href="#原料-6">#</a> 原料：</h3>
<p>鸡翅；奥尔良腌料；蜂蜜（可不用）</p>
<h3 id="步骤-6"><a class="markdownIt-Anchor" href="#步骤-6">#</a> 步骤：</h3>
<p>（1）鸡翅洗净划口，放在盘子里滤水备用</p>
<p>（2）超市买来的奥尔良腌料和水 1:1 调配，将鸡翅放在调料汁里，把每一个鸡翅都均匀裹上调料汁</p>
<p>（3）放入冰箱冷藏几个小时腌入味</p>
<p>（4）把鸡翅均匀刷上蜂蜜（可省略此步骤）</p>
<p>（5）微波炉中高火叮 10 分钟（鸡翅量少要缩短时间），不熟继续叮 2 分钟，如果鸡翅量比较多可能需要更多时间，每次加 2 分钟直到熟透为止，中间可以翻面。</p>
<h2 id="7微波炉红片"><a class="markdownIt-Anchor" href="#7微波炉红片">#</a> 7. 微波炉红片</h2>
<p>高中的时候学校门口有卖红薯片的，酥酥甜甜非常好吃。其实有微波炉可以自己做，闲着没事可以磨磨牙。</p>
<h3 id="原料-7"><a class="markdownIt-Anchor" href="#原料-7">#</a> 原料：</h3>
<p>红薯；油</p>
<h3 id="步骤-7"><a class="markdownIt-Anchor" href="#步骤-7">#</a> 步骤：</h3>
<p>（1）红薯去皮擦成薄片，不建议用刀切，除非刀工了得，能切得很薄。我的刀工超级差，比较喜欢借助工具。</p>
<p>（2）红薯片用凉水过一下，沥干水分备用</p>
<p>（3）平盘涂薄薄一层油（可不涂），红薯片铺在平盘里，每一片不能重叠也不要挨着，会黏在一起</p>
<p>（4）微波炉高火叮 1 分钟，翻面再叮 1 分钟，不干重复以上步骤。有些微波炉 3 分钟就能叮好，有些要叮很久才能彻底干。千万不要贪心，每次加 1 分钟或半分钟就好，小心别叮糊了。</p>
<h2 id="8微波炉烤豆腐"><a class="markdownIt-Anchor" href="#8微波炉烤豆腐">#</a> 8. 微波炉烤豆腐</h2>
<p>江月路地铁站附近有个卖煎豆腐和狼牙土豆的三轮车，后来没有了，不知道是不是被清走了…… 我想吃煎豆腐啊！但是我家那锅煎豆腐粘锅，嫩豆腐还容易碎。后来发现微波炉烤出来的味道差不多，还更好操作。</p>
<h3 id="原料-8"><a class="markdownIt-Anchor" href="#原料-8">#</a> 原料：</h3>
<p>豆腐；耗油；甜面酱；孜然；辣椒粉；葱；香菜；芝麻</p>
<h3 id="步骤-8"><a class="markdownIt-Anchor" href="#步骤-8">#</a> 步骤：</h3>
<p>（1）豆腐洗净切片，把表面水分晾干或用厨房纸吸干</p>
<p>（2）平盘（能入微波炉的盘子）刷油或铺一张油纸，豆腐平铺在盘子里</p>
<p>（3）适量耗油、甜面酱、孜然、辣椒粉混合，均匀涂在豆腐上</p>
<p>（4）微波炉高火 5 分钟，豆腐翻面刷酱继续叮 5 分钟，根据自家微波炉特性可适当增加时间</p>
<p>（5）出炉撒芝麻、葱花、香菜</p>
<h2 id="9微波炉牛轧糖"><a class="markdownIt-Anchor" href="#9微波炉牛轧糖">#</a> 9. 微波炉牛轧糖</h2>
<p>很多人知道可以用棉花糖做牛轧糖，其实用微波炉就可以做，超级简单。</p>
<h3 id="原料-9"><a class="markdownIt-Anchor" href="#原料-9">#</a> 原料：</h3>
<p>棉花糖；奶粉；花生仁（杏仁）</p>
<p>棉花糖、奶粉、花生仁比例是 2:1:1</p>
<h3 id="步骤-9"><a class="markdownIt-Anchor" href="#步骤-9">#</a> 步骤：</h3>
<p>（1）花生仁打碎，可以放在袋子里碾碎</p>
<p>（2）棉花糖放在大一点的容器里，高火叮 1 分钟</p>
<p>（3）把融化的棉花糖拿出来，加入奶粉和花生碎疯狂快速搅拌，如果凝固了搅不动就再叮一下下</p>
<p>（4）借助保鲜膜把搅拌好的一坨放在平盘里压平，晾凉放进冰箱冷藏凝固</p>
<p>（5）取出用刀切块，可以买糖纸包装一下</p>
<h2 id="10红糖苹果"><a class="markdownIt-Anchor" href="#10红糖苹果">#</a> 10. 红糖苹果</h2>
<p>煮熟的苹果软软的很好吃，我之前经常用苹果块、红枣、冰糖一起炖，暖暖甜甜的吃着很满足。微波炉叮苹果也是很好吃的，可以加一点红糖，很适合女孩经期吃，暖暖的吃下去有个心理安慰。</p>
<h3 id="原料-10"><a class="markdownIt-Anchor" href="#原料-10">#</a> 原料：</h3>
<p>苹果、红糖、红枣（可不放）</p>
<h3 id="步骤-10"><a class="markdownIt-Anchor" href="#步骤-10">#</a> 步骤：</h3>
<p>（1）选一个小一点的苹果洗净，用刀在中间去核挖个洞，如果嫌麻烦可以直接切块</p>
<p>（2）把苹果放碗里，在洞里放一点红糖，别放多了，太甜就不好吃了。有红枣可以把一颗红枣切成两半去核放进去，味道也很好。</p>
<p>（3）微波炉高火叮 2 分钟，拿出来把苹果翻个个继续叮 2 分钟，如果不够软可以稍微增加点时间</p>
<p>上面就是今天的 10 个微波炉菜谱啦，其实用微波炉做蛋羹也很方便，不过有一次我在做的时候蛋飞得到处都是，微波炉变成事故现场，蛋羹变成了蜂窝炸弹，后来我就不敢再尝试了…… 还是乖乖用水蒸……</p>
<p>下次再找到什么有意思的东西再继续写菜谱系列叭～</p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>料理</tag>
        <tag>菜谱</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-133-克隆图</title>
    <url>/passages/Leetcode-133-%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="leetcode-133克隆图"><a class="markdownIt-Anchor" href="#leetcode-133克隆图">#</a> Leetcode 133. 克隆图</h1>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2>
<p>给你无向<a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin">连通</a>图中一个节点的引用，请你返回该图的<a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a>（克隆）。</p>
<p>图中的每个节点都包含它的值  <code>val</code> （ <code>int</code> ） 和其邻居的列表（ <code>list[Node]</code> ）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试用例格式：</strong></p>
<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（ <code>val = 1</code> ），第二个节点值为 2（ <code>val = 2</code> ），以此类推。该图在测试用例中使用邻接列表表示。</p>
<p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p>
<p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：adjList = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">解释：</span><br><span class="line">图中有 <span class="number">4</span> 个节点。</span><br><span class="line">节点 <span class="number">1</span> 的值是 <span class="number">1</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">2</span> 的值是 <span class="number">2</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br><span class="line">节点 <span class="number">3</span> 的值是 <span class="number">3</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">4</span> 的值是 <span class="number">4</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 <span class="number">1</span> 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：adjList = [[<span class="number">2</span>],[<span class="number">1</span>]]</span><br><span class="line">输出：[[<span class="number">2</span>],[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ol>
<li>节点数不超过 100 。</li>
<li>每个节点值  <code>Node.val</code>  都是唯一的， <code>1 &lt;= Node.val &lt;= 100</code> 。</li>
<li>无向图是一个<a href="https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%9B%BE/1680528?fr=aladdin">简单图</a>，这意味着图中没有重复的边，也没有自环。</li>
<li>由于图是无向的，如果节点 <code>p</code>  是节点 <code>q</code>  的邻居，那么节点  <code>q </code> 也必须是节点  <code>p </code> 的邻居。</li>
<li>图是连通图，你可以从给定节点访问到所有节点。</li>
</ol>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/clone-graph">https://leetcode-cn.com/problems/clone-graph</a><br>
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2>
<p>​		对一个图进行深拷贝时，我们可以对它进行遍历，并在遍历时进行拷贝，最后得到该图的深拷贝结果。</p>
<p>​		通过一个节点遍历一个连通图的有效方法为<a href="https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2?fromtitle=%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86&amp;fromid=9796166">深度优先遍历 (DFS)</a> 和<a href="https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2?fromtitle=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86&amp;fromid=9796192">广度优先遍历 (BFS)</a>。(层序遍历不适合无向图)</p>
<p>​		我们知道，无向图中，若 A、B 两点相连，则可以从 A 连接 B 也可以从 B 连接 A，这一点使得我们在使用深度优先遍历和广度优先遍历克隆 (深拷贝) 一个无向图时需要对结点进行标记，来代表它们是否已经被克隆过。</p>
<p>​		关于这一点的解决，最开始时想对每一个节点加一个 <code>tag</code>  来表示是否已经克隆过，后来发现不太行；之后也尝试了使用队列、栈和列表来实现 <code>tag</code> ，也没有达到想要的效果，最后选取了 ** <code>哈希表HashMap</code> ** 来实现对克隆的记录。</p>
<p>​		在 HashMap 中， <code>key</code> / <code>value</code>  分别为 <strong> <code>原始图节点</code>  / <code>克隆图节点</code> </strong>，这样表示比较清晰且便于查找 (也做过储存节点值 / 克隆图节点，但不如上文方法清晰)。我们从给定节点开始对图进行遍历。如果某个节点已经被访问过，则返回其克隆图中的对应节点 (查找 HashMap)。如果当前访问的节点不在哈希表中，则创建它的克隆节点并存储在哈希表中。<strong>注意：<strong>在需要递归的时候，克隆节点并保存在哈希表中的操作</strong>需要放在进入递归之前</strong>，不然有可能在递归中遇到相同的节点，陷入死循环 (再次遍历此节点)。</p>
<p>​		<strong>递归操作：<strong>在递归时，会递归每个节点的邻接点，递归次数由邻接点数量决定，每一次都返回对应邻接点的克隆节点 (注意：克隆前需要先</strong>判断该点是否已经被克隆过</strong>)，最后返回这些克隆节点的列表，放入对应克隆节点的邻接表中，这样就可以克隆给定的节点和其邻接点。</p>
<h3 id="1深度优先遍历递归"><a class="markdownIt-Anchor" href="#1深度优先遍历递归">#</a> 1. 深度优先遍历（递归）</h3>
<p>​		通过递归实现深度优先遍历，在遍历的中间对节点进行克隆并将克隆节点保存在哈希表中（<strong>注意克隆保存和进入递归的先后</strong>）</p>
<h3 id="2广度优先遍历栈"><a class="markdownIt-Anchor" href="#2广度优先遍历栈">#</a> 2. 广度优先遍历（栈）</h3>
<p>​		用栈实现广度优先遍历，这种做法不需要递归，但仍需要在遍历的中间对节点进行克隆并将克隆节点保存在哈希表中</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2>
<h3 id="1深度优先遍历递归-2"><a class="markdownIt-Anchor" href="#1深度优先遍历递归-2">#</a> 1. 深度优先遍历（递归）</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义一个哈希表来记录访问过的节点以及克隆过的节点</span></span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果为空</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">find</span>(node) != visited.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> visited[node];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 新建克隆节点并储存</span></span><br><span class="line">        Node* cloneNode = <span class="keyword">new</span> <span class="built_in">Node</span>(node -&gt; val);</span><br><span class="line">        visited[node] = cloneNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor : node -&gt; neighbors) </span><br><span class="line">            cloneNode -&gt; neighbors.<span class="built_in">push_back</span>(<span class="built_in">cloneGraph</span>(neighbor));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="ac截图"><a class="markdownIt-Anchor" href="#ac截图">#</a> AC 截图：</h5>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/585d97e015a7a791.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/e1246a181a6aed25.png" alt></p>
<h3 id="2广度优先遍历栈-2"><a class="markdownIt-Anchor" href="#2广度优先遍历栈-2">#</a> 2. 广度优先遍历（栈）</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果为空</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 新建克隆节点并储存</span></span><br><span class="line">        Node* cloneNode = <span class="keyword">new</span> <span class="built_in">Node</span>(node -&gt; val);</span><br><span class="line">        visited[node] = cloneNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建队列</span></span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="comment">// 节点入队</span></span><br><span class="line">        que.<span class="built_in">push</span>(node);</span><br><span class="line">        <span class="comment">// 如果队列不为空</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取队首并出栈</span></span><br><span class="line">            Node* temp = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor : temp -&gt; neighbors)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited.<span class="built_in">find</span>(neighbor) == visited.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 新建克隆节点并入栈</span></span><br><span class="line">                    visited[neighbor] = <span class="keyword">new</span> <span class="built_in">Node</span>(neighbor -&gt; val);</span><br><span class="line">                    que.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新克隆节点的邻居列表（在哈希表中找到该克隆节点并更新克隆节点的邻居列表）</span></span><br><span class="line">                visited[temp] -&gt; neighbors.<span class="built_in">push_back</span>(visited[neighbor]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="ac截图-2"><a class="markdownIt-Anchor" href="#ac截图-2">#</a> AC 截图：</h5>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/585d97e015a7a791.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/01cedf0345728be0.png" alt></p>
<h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2>
<p>​		做完这个题之后，我感觉主要思路就是对该图进行遍历并同时深拷贝，无论哪种遍历方法都需要给节点打上 tag 来标志该节点是否被克隆过（通过哈希表实现）。在深度优先遍历中使用递归时需要注意操作的先后顺序（克隆保存和进入递归的先后），否则会陷入死循环；广度优先遍历则不需要担心这一点。</p>
]]></content>
      <tags>
        <tag>算法作业</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-208-实现Trie(前缀树)</title>
    <url>/passages/Leetcode-208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<h1 id="leetcode-208-实现-trie-前缀树"><a class="markdownIt-Anchor" href="#leetcode-208-实现-trie-前缀树">#</a> Leetcode 208. 实现 Trie (前缀树)</h1>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2>
<p><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code>  初始化前缀树对象。</li>
<li><code>void insert(String word)</code>  向前缀树中插入字符串 <code> word</code> 。</li>
<li><code>boolean search(String word) </code>  如果字符串  <code>word</code>  在前缀树中，返回  <code>true</code>  （即，在检索之前已经插入）；否则，返回  <code>false</code>  。</li>
<li><code>boolean startsWith(String prefix)</code>  如果之前已经插入的字符串  <code>word</code>   的前缀之一为  <code>prefix</code>  ，返回  <code>true</code>  ；否则，返回  <code>false</code> 。</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;Trie&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;search&quot;</span>, <span class="string">&quot;search&quot;</span>, <span class="string">&quot;startsWith&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;search&quot;</span>]</span><br><span class="line">[[], [<span class="string">&quot;apple&quot;</span>], [<span class="string">&quot;apple&quot;</span>], [<span class="string">&quot;app&quot;</span>], [<span class="string">&quot;app&quot;</span>], [<span class="string">&quot;app&quot;</span>], [<span class="string">&quot;app&quot;</span>]]</span><br><span class="line">输出</span><br><span class="line">[null, null, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, null, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">trie.<span class="built_in">insert</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">trie.<span class="built_in">search</span>(<span class="string">&quot;apple&quot;</span>);   <span class="comment">// 返回 True</span></span><br><span class="line">trie.<span class="built_in">search</span>(<span class="string">&quot;app&quot;</span>);     <span class="comment">// 返回 False</span></span><br><span class="line">trie.<span class="built_in">startsWith</span>(<span class="string">&quot;app&quot;</span>); <span class="comment">// 返回 True</span></span><br><span class="line">trie.<span class="built_in">insert</span>(<span class="string">&quot;app&quot;</span>);</span><br><span class="line">trie.<span class="built_in">search</span>(<span class="string">&quot;app&quot;</span>);     <span class="comment">// 返回 True</span></span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>
<li><code>word</code>  和  <code>prefix </code>  仅由小写英文字母组成</li>
<li><code>insert</code>  、 <code>search</code>  和  <code>startsWith</code>  调用次数<strong>总计</strong>不超过  <code>3 * 104 </code>  次</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree">https://leetcode-cn.com/problems/implement-trie-prefix-tree</a><br>
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2>
<p>​		有百度百科可知（连接已上方给出），字典树是一种树形结构，每个节点只储存一个字符，且为节点不存储字符，我认为它是一种可以按照路径存储字符串的数据结构。</p>
<p>​		现在我们需要将一些单词（只有小写英文字母）存储在字典树里面，我们就在字典树里面的每个节点中创建一个大小为 26 的对象数组  <code>Trie* next[26]</code>  （  <code>该数组中的26个位置分别对应26个小写英文字母</code>  ），同时我们创建一个用来提取字符编号的基准  <code>Base</code>  （  <code>const char Base='a';</code>  ，  <code>编号 = 字符 - Base</code>  ），将计算出的编号作为访问对象数组的索引。</p>
<p>​		当我们向字典树中添加一个单词是，只需要一个字符一层的遍历字典树的节点，如果未找到包含该字符的节点，则新建一个节点并将字符放入；若找到了存放该字符的节点，则指向该节点并继续向下一层字符遍历；直到遍历完该单词的最后一个字母时，将该节点的  <code>isWord</code>  值改为  <code>true</code>  ，标示着这里是一个单词的结尾。</p>
<p>​		当我们在字典树中查找一个单词时，与添加步骤相同，也是一直向下遍历，区别是当遍历时未找到对应的字符时需要返回  <code>false</code>  来表示未找到需要查找的单词；并且在查找到最后一个字符后，返回该字符的  <code>isWord</code>  来表示是否查找成功。</p>
<p>​		当我们在字典树中进行前缀匹配操作时，步骤跟查找一个单词的步骤基本相同，区别就是在查找到最后一个字符后直接返回  <code>true</code>  即可（因为在前缀匹配的条件下，只要找到了最后一个字符，就证明肯定有以该字符串为前缀的单词，这个单词的最小值就是前缀本身）。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> Base=<span class="string">&#x27;a&#x27;</span>; <span class="comment">// 后续作为基准来提取字符的编号（编号 = 字符 - Base）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isWord; <span class="comment">// 作为表示是否为单词结尾的tag</span></span><br><span class="line">    Trie* next[<span class="number">26</span>]; <span class="comment">// 子节点（分别对应26个英文字母，通过Base得到索引来使用）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        isWord = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(next)); <span class="comment">// 初始化数组（内容都为0）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入单词</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c - Base] == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果没有对应的子节点的话，就new一个来用</span></span><br><span class="line">                node-&gt;next[c - Base] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[c - Base]; <span class="comment">// 指向下一个子节点（指向下一个字母）</span></span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isWord = <span class="literal">true</span>; <span class="comment">// 修改tag表示此处是一个单词的结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找单词</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历匹配字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">            <span class="comment">// 向下匹配</span></span><br><span class="line">            node = node-&gt;next[c - Base];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 未匹配到最后一个字符，返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配到了最后一个字符，返回该字符的isWord</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前缀匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 跟查找操作类似，只是不需要判断最后一个字符结点的isWord，因为既然能匹配到最后一个字符，那后面一定有单词是以它为前缀的。（至少是以该字符串为单词）</span></span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : prefix) &#123;</span><br><span class="line">            node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * 您的Trie对象将被实例化并按如下方式调用：</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/774864f87352f82c.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/2b72d6e4e876f9c6.png" alt></p>
<h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2>
<p>​		在本题中，我们需要实现字典树，字典树是一种特殊的树形结构，由于储存的字符只有小写英文字母，所以可以用对象数组  <code>Trie* next[26]</code>  来存储。同时因为一个节点只能存放一个字符，使得我肯可以一个字符一层的去查找，而  <code>isWord</code>  给予了判断该字符是否为一个单词结尾的依据；插入，查找，前缀匹配三个操作都是依托上面所实现的东西来进行的。三种操作的相同点就是都要进行多次按照字符的遍历，不同点在于对于未找到对应字符的处理以及相同情况下的返回值不同。</p>
]]></content>
      <tags>
        <tag>算法作业</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-218-天际线问题</title>
    <url>/passages/Leetcode-218-%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>321</p>
<h1 id="leetcode-218-天际线问题"><a class="markdownIt-Anchor" href="#leetcode-218-天际线问题">#</a> Leetcode 218. 天际线问题</h1>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2>
<p>城市的 <strong>天际线</strong> 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 <em>由这些建筑物形成的</em> <strong>天际线</strong> 。</p>
<p>每个建筑物的几何信息由数组  <code>buildings</code>  表示，其中三元组  <code>buildings[i] = [lefti, righti, heighti]</code>  表示：</p>
<ul>
<li><code>lefti</code>  是第  <code>i</code>  座建筑物左边缘的  <code>x</code>  坐标。</li>
<li><code>righti</code>  是第  <code>i</code>  座建筑物右边缘的  <code>x</code>  坐标。</li>
<li><code>heighti</code>  是第  <code>i</code>  座建筑物的高度。</li>
</ul>
<p>你可以假设所有的建筑都是完美的长方形，在高度为  <code>0</code>  的绝对平坦的表面上。</p>
<p><strong>天际线</strong> 应该表示为由 “关键点” 组成的列表，格式  <code>[[x1,y1],[x2,y2],...]</code>  ，并按 <strong>x 坐标</strong> 进行 <strong>排序</strong> 。<strong>关键点是水平线段的左端点</strong>。列表中最后一个点是最右侧建筑物的终点， <code>y</code>  坐标始终为  <code>0</code>  ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p><strong>注意</strong>：输出天际线中不得有连续的相同高度的水平线。例如  <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code>  是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个： <code>[...[2 3], [4 5], [12 7], ...]</code></p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：buildings = [[<span class="number">2</span>,<span class="number">9</span>,<span class="number">10</span>],[<span class="number">3</span>,<span class="number">7</span>,<span class="number">15</span>],[<span class="number">5</span>,<span class="number">12</span>,<span class="number">12</span>],[<span class="number">15</span>,<span class="number">20</span>,<span class="number">10</span>],[<span class="number">19</span>,<span class="number">24</span>,<span class="number">8</span>]]</span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">10</span>],[<span class="number">3</span>,<span class="number">15</span>],[<span class="number">7</span>,<span class="number">12</span>],[<span class="number">12</span>,<span class="number">0</span>],[<span class="number">15</span>,<span class="number">10</span>],[<span class="number">20</span>,<span class="number">8</span>],[<span class="number">24</span>,<span class="number">0</span>]]</span><br><span class="line">解释：</span><br><span class="line">图 A 显示输入的所有建筑物的位置和高度，</span><br><span class="line">图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：buildings = [[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= buildings.length &lt;= 104</code></li>
<li><code>0 &lt;= lefti &lt; righti &lt;= 231 - 1</code></li>
<li><code>1 &lt;= heighti &lt;= 231 - 1</code></li>
<li><code>buildings</code>  按  <code>lefti</code>  非递减排序</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/the-skyline-problem">https://leetcode-cn.com/problems/the-skyline-problem</a><br>
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2>
<p>解答本题使用的是扫描线算法，对于这个题我本来是没什么思路的，后来看了一些教程才有的思路。</p>
<p>扫描线算法，顾名思义就是对线条进行扫描，这里我们扫描的是建筑物的边缘线。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/608b58569bd2a360.png" alt></p>
<p>我在这里先简述一下扫描线算法的原理：构造一个大顶堆（优先队列也行），从左到右扫描建筑物，扫描到左边线时，将该建筑物的高度加入大顶堆；扫描到右边线，将当前建筑物的高度弹出大顶堆。在扫描搭配左（右）边线并将当前建筑物的高度加入（弹出）大顶堆之后，我们需要观察大顶堆的最大值有没有发生变化，如果发生变化，则证明产生了关键点，并记录产生的关键点，关键点坐标为 (当前的 x 坐标，大顶堆弹出当前建筑物高度后的最大值)。经过这样的一边扫描之后，我们就可以顺利的得到我们想要的关键点了。</p>
<p>那么，如何区分左边线和右边线呢？这里使用的方法是在读入数据的时候将左边线的纵坐标读入成负值，这样就可以通过纵坐标的正负来判断扫描到的线是左边线还是右边线了。</p>
<p>在读入数据结束后，我们需要使用 sort 函数对数据进行升序排序，以确保：</p>
<ol>
<li>我们是从左到右来扫描边线</li>
<li>我们扫描边线碰到某条左边线和某条右边线重合的情况时，先对左边线进行扫描，再扫描右边线（因为录入信息的时候将左边线的纵坐标录入为负值，在 sort 排序时横坐标相同的情况下左边线靠前，从而可以先进行扫描）</li>
<li>两条左边先重合时让高度高的线进入大根堆</li>
<li>两条右边线重合时高度小的先弹出大根堆</li>
</ol>
<p>这样，在扫描结束后我们就可以得到想要的关键点集合了</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2>
<p>C++ multiset</p>
<p><a href="https://blog.csdn.net/sodacoco/article/details/84798621">(133 条消息) multiset 用法总结__CSDN</a></p>
<p><a href="https://www.educba.com/c-plus-plus-multiset/">C++ Multiset | Tutorials on Top 27 Multiset Functions with Examples (educba.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="comment">// auto&amp; 会修改 buildings 里面的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; b: buildings) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(&#123; b[<span class="number">0</span>], -b[<span class="number">2</span>] &#125;);</span><br><span class="line">            vec.<span class="built_in">push_back</span>(&#123; b[<span class="number">1</span>], b[<span class="number">2</span>] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// multiset当大顶堆的用</span></span><br><span class="line">        multiset&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="comment">// 初始化 先放一个0</span></span><br><span class="line">        pq.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> preMax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键点存放</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : vec) &#123;</span><br><span class="line">            <span class="comment">// 遇到左边线</span></span><br><span class="line">            <span class="keyword">if</span> (p.second &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">insert</span>(-p.second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到右边线</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pq.<span class="built_in">erase</span>(pq.<span class="built_in">find</span>(p.second));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取当前最大值</span></span><br><span class="line">            <span class="keyword">int</span> curMax = *pq.<span class="built_in">rbegin</span>();</span><br><span class="line">            <span class="comment">// 判断是否为关键点</span></span><br><span class="line">            <span class="keyword">if</span> (curMax != preMax) &#123;</span><br><span class="line">                <span class="comment">// 放入关键点集合并更新最大值</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123; p.first,curMax &#125;);</span><br><span class="line">                preMax = curMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2>
<p>第一次接触扫描线算法，感觉非常有意思，但我感觉扫描线算法的用处不止这样，相信以后还能碰到。</p>
<p>在本次解题过程中，我感觉左边线的负值处理和读入数据后的 sort 排序比较有意思。</p>
<p>菜鸡先爬了～～～</p>
]]></content>
      <tags>
        <tag>算法作业</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-632-最小区间</title>
    <url>/passages/Leetcode-632-%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="leetcode-632-最小区间"><a class="markdownIt-Anchor" href="#leetcode-632-最小区间">#</a> Leetcode 632. 最小区间</h1>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2>
<p>你有  <code>k</code>  个 <strong>非递减排列</strong> 的整数列表。找到一个 <strong>最小</strong> 区间，使得  <code>k</code>  个列表中的每个列表至少有一个数包含在其中。</p>
<p>我们定义如果  <code>b-a &lt; d-c</code>  或者在  <code>b-a == d-c</code>  时  <code>a &lt; c</code> ，则区间  <code>[a,b]</code>  比  <code>[c,d]</code>  小。</p>
<p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [[<span class="number">4</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">24</span>,<span class="number">26</span>], [<span class="number">0</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">20</span>], [<span class="number">5</span>,<span class="number">18</span>,<span class="number">22</span>,<span class="number">30</span>]]</span><br><span class="line">输出：[<span class="number">20</span>,<span class="number">24</span>]</span><br><span class="line">解释： </span><br><span class="line">列表 <span class="number">1</span>：[<span class="number">4</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">24</span>, <span class="number">26</span>]，<span class="number">24</span> 在区间 [<span class="number">20</span>,<span class="number">24</span>] 中。</span><br><span class="line">列表 <span class="number">2</span>：[<span class="number">0</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">20</span>]，<span class="number">20</span> 在区间 [<span class="number">20</span>,<span class="number">24</span>] 中。</span><br><span class="line">列表 <span class="number">3</span>：[<span class="number">5</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">30</span>]，<span class="number">22</span> 在区间 [<span class="number">20</span>,<span class="number">24</span>] 中。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>nums.length == k</code></li>
<li><code>1 &lt;= k &lt;= 3500</code></li>
<li><code>1 &lt;= nums[i].length &lt;= 50</code></li>
<li><code>-105 &lt;= nums[i][j] &lt;= 105</code></li>
<li><code>nums[i]</code>  按非递减顺序排列</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists">https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists</a><br>
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2>
<p>在解题过程中我们可以将题目给的若干列表表示出来，这里以三个列表为例。</p>
<p>我们用线段表示这三个列表的区间，用红圈表示列表中的元素。表示如下：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/2fe077483aeb92a1.png" alt></p>
<p>题目要求我们寻找一个区间，要求囊括每个有序列表中的至少一个元素。我们可以在上面画出的区间中画出非常多符合条件的区间，这里我们少画几个。画出的区间如下：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/d3d1fa9b9c608659.png" alt></p>
<p>这里的 “<strong>至少一个元素</strong>” 可以理解成 “<strong>一个元素</strong>”，上图的区间一和区间二便是如此。因此，我们要寻找的最小区间只需要包含每个有序列表内的一个元素即可，于是我们得到了区间二和区间三。</p>
<p>那么，对于区间二和区间三，我们如何判断它们当中谁是我们要找的最小区间呢？那一定是这个区间内所包含的 3 个 (  <code>k</code>  个) 元素中，最小值和最大值的差值最小的那一个，这也就代表了这个区间最小。显然，区间二中最大值与最小值的差值小于区间三中最大值与最小值的差值，所以区间二比区间三要小。如果两个区间中最大值与最小值的差值相等，则数值小的区间小（参照题目中的条件：我们定义如果  <code>b-a &lt; d-c</code>  或者在  <code>b-a == d-c</code>  时  <code>a &lt; c</code> ，则区间  <code>[a,b]</code>  比  <code>[c,d]</code>  小）。</p>
<p>现在我们以  <code>nums = [[2,4,7],[1,4,5],[3,5,6,8]]</code>  作为示例来思考如何寻找最小区间。</p>
<p>我们先将这三个列表画出来，如下图所示：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/3472a07507d62809.png" alt></p>
<p>我们可以为每个列表定义一个指针，如图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/cded557384c82251.png" alt></p>
<p>此时，这三个指针所指的三个元素可以构成一个最小区间，且最小值与最大值的差值为 2，我们先记录下来。</p>
<p>接下来我们寻找最小区间，如何寻找呢？我们可以将此时的左边界右移来缩小区间，计算右移后的区间长度，发现和上一个区间的长度相同，并且上一个区间的数值更小，所以此次移动后不记录区间长度；右移之后如图所示：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/731f91a9504823f6.png" alt></p>
<p>再次将左边界右移来缩小区间，计算右移后的区间长度并记录；右移之后如图所示：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/b88b829a7be1d5b9.png" alt></p>
<p>再次将左边界右移来缩小区间，计算右移后的区间长度，发现和上一个区间的长度相同，并且上一个区间的数值更小，所以此次移动后不记录区间长度；右移之后如图所示：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/1521bfc41376ebb4.png" alt></p>
<p>再次将左边界右移来缩小区间，计算右移后的区间长度，发现大于之前的区间长度，不记录；右移之后如图所示：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/dfa2f6b9afeed477.png" alt></p>
<p>再次将左边界右移来缩小区间，计算右移后的区间长度，发现大于之前的区间长度，不记录；右移之后如图所示：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/74a8998a446f0db6.png" alt></p>
<p>此时，第二个列表已经走到最后，左边界将无法移动，此时所记录的最小区间即为我们要寻找的最小区间，即最小区间为  <code>[3,4]</code>  。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2>
<p>前面列举了两种暴力解答的方法（未实现），后面为上方解题思路的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、暴力解答：遍历每个数组，计算每个数组中出现的每个数字在所有数组中出现过的数组个数</span></span><br><span class="line">	<span class="comment">// 全部出现的元素组成的最短区间即为想要的结果</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 二、穷举：每个元素作为头和尾，然后判断是否符合条件之后判断是否最短</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次向右移动最小值，记录最短区间长度和位置</span></span><br><span class="line">	<span class="comment">// 长度短 或 长度相同时数值小 的区间小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line"><span class="comment">//        定义一个模拟区间，最开始范围是 -1e-5 到 1e-5</span></span><br><span class="line">        <span class="keyword">int</span> leftRange = (<span class="keyword">int</span>)-<span class="number">1e-5</span>;</span><br><span class="line">        <span class="keyword">int</span> rightRange = (<span class="keyword">int</span>)<span class="number">1e5</span>;</span><br><span class="line">        <span class="keyword">int</span> minRange = rightRange - leftRange;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        当前区间内的最大值(选取1e-5结果不对)</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引0，代表第一个链表；ptrs[0] = 指针在链表中的位置</span></span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span>[] ptrs = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line"><span class="comment">//        定义一个优先队列，用来取最小值（也可以用for循环代替）</span></span><br><span class="line"><span class="comment">//        优先队列可以通过 ptrs[index*] 把所有指针所指位置最小的指针放到前面去，从而取到最小值</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer index1, Integer index2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums.get(index1).get(ptrs[index1]) - nums.get(index2).get(ptrs[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      开始时，将索引都赛道队列中，并取下 [max,nums.get(i).get(0)] 区间的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ptrs.length; i++) &#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">            max = max(max, nums.get(i).get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      循环更新，直到某一区间走完</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//          取出最小值（左边界）（也可以用for循环代替）</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = queue.poll();</span><br><span class="line"><span class="comment">//          计算当前范围</span></span><br><span class="line">            <span class="keyword">int</span> curRange = max - nums.get(minIndex).get(ptrs[minIndex]);</span><br><span class="line"><span class="comment">//          如果当前范围小，则更新左右边界</span></span><br><span class="line">            <span class="keyword">if</span> (curRange &lt; minRange) &#123;</span><br><span class="line"><span class="comment">//              更新右边界</span></span><br><span class="line">                minRange = curRange;</span><br><span class="line"><span class="comment">//              左边界是当前值最小的索引（在优先队列的最前面）</span></span><br><span class="line">                leftRange = nums.get(minIndex).get(ptrs[minIndex]);</span><br><span class="line">                rightRange = max;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//          指针右移</span></span><br><span class="line">            ptrs[minIndex]++;</span><br><span class="line"><span class="comment">//          指针超出，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (ptrs[minIndex] == nums.get(minIndex).size())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//          将最小值放入</span></span><br><span class="line">            queue.offer(minIndex);</span><br><span class="line"><span class="comment">//          取得当前区间的最大值</span></span><br><span class="line">            max = max(max, nums.get(minIndex).get(ptrs[minIndex]));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      构造结果并返回</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        result[<span class="number">0</span>] = leftRange;</span><br><span class="line">        result[<span class="number">1</span>] = rightRange;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2>
<p>本题中寻找最小区间使用的方法是不断右移左边界，使得区间变小，在区间变小是进行比较和统计，最终得到最小区间。</p>
<p>在本体的解答个过程中，我感觉作图是解题非常好的帮周，可以帮助我们条理的梳理我们的题目，有利于我们的解答。</p>
]]></content>
      <tags>
        <tag>算法作业</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus</title>
    <url>/passages/MyBatis-Plus/</url>
    <content><![CDATA[<h1 id="一-mybatis-plus"><a class="markdownIt-Anchor" href="#一-mybatis-plus">#</a> 一、MyBatis-Plus</h1>
<h2 id="1简介"><a class="markdownIt-Anchor" href="#1简介">#</a> 1. 简介</h2>
<p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus (opens new window)</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis (opens new window)</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<blockquote>
<p>我们的愿景是成为 MyBatis 最好的搭档，就像 <a href="https://baomidou.com/img/contra.jpg">魂斗罗</a> 中的 1P、2P，基友搭配，效率翻倍。</p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/relationship-with-mybatis.png" alt="img"></p>
<h2 id="2特性"><a class="markdownIt-Anchor" href="#2特性">#</a> 2. 特性</h2>
<ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul>
<h2 id="3支持数据库"><a class="markdownIt-Anchor" href="#3支持数据库">#</a> 3. 支持数据库</h2>
<blockquote>
<p>任何能使用  <code>MyBatis</code>  进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p>
</blockquote>
<ul>
<li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</li>
<li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用 (华库) 数据库，南大通用数据库，神通数据库，瀚高数据库</li>
</ul>
<h2 id="4框架结构"><a class="markdownIt-Anchor" href="#4框架结构">#</a> 4. 框架结构</h2>
<img src="https://baomidou.com/img/mybatis-plus-framework.jpg" alt="framework" style="zoom:50%;">
<h2 id="5官方地址"><a class="markdownIt-Anchor" href="#5官方地址">#</a> 5. 官方地址</h2>
<blockquote>
<p>** 官方网站：**<a href="https://baomidou.com/">https://baomidou.com/</a></p>
<p>** 官方文档：**<a href="https://baomidou.com/pages/24112f/">https://baomidou.com/pages/24112f/</a></p>
</blockquote>
<h1 id="二-入门案例"><a class="markdownIt-Anchor" href="#二-入门案例">#</a> 二、入门案例</h1>
<h2 id="1开发环境"><a class="markdownIt-Anchor" href="#1开发环境">#</a> 1. 开发环境</h2>
<ul>
<li><strong>IDE：IDEA 2019.3.5</strong></li>
<li><strong>JDK：JDK8+</strong></li>
<li><strong>构建工具：Maven 3.5.4</strong></li>
<li><strong>MySQL：MySQL 8.0.24</strong></li>
<li><strong>Navicat：Navicat Premium 15</strong></li>
<li><strong>Spring Boot：2.6.7</strong></li>
<li><strong>MyBatis-Plus：3.5.1</strong></li>
</ul>
<h2 id="2建库建表"><a class="markdownIt-Anchor" href="#2建库建表">#</a> 2. 建库建表</h2>
<ul>
<li>
<p><strong>打开 Navicat 运行以下 SQL 脚本进行建库建表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis_plus` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>; </span><br><span class="line">use `mybatis_plus`; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` ( </span><br><span class="line">    `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>, </span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>, </span><br><span class="line">    `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>, </span><br><span class="line">    `email` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`) </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>插入几条测试数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3创建工程"><a class="markdownIt-Anchor" href="#3创建工程">#</a> 3. 创建工程</h2>
<ul>
<li>
<p><strong>使用 <code>Spring Initializer</code>  快速初始化一个 Spring Boot 工程</strong></p>
<img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519140839640.png" alt="image-20220519140839640" style="zoom:80%;">
<img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141335981.png" alt="image-20220519141335981" style="zoom:80%;">
<img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141737405.png" alt="image-20220519141737405" style="zoom:80%;">
<img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141849937.png" alt="image-20220519141849937" style="zoom:80%;">
</li>
<li>
<p><strong>引入 <code>MyBatis-Plus</code>  的依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>安装 <code>Lombok</code>  插件</strong></p>
<img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519143257305.png" alt="image-20220519143257305" style="zoom:80%;">
</li>
</ul>
<h2 id="4配置编码"><a class="markdownIt-Anchor" href="#4配置编码">#</a> 4. 配置编码</h2>
<ul>
<li>
<p><strong>配置 <code>application.yml</code>  文件</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置数据源</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#配置数据源类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="comment">#配置连接数据库的信息</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> &#123;<span class="string">username</span>&#125;</span><br><span class="line">    <span class="attr">password:</span> &#123;<span class="string">password</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>在 Spring Boot 启动类中添加  <code>@MapperScan</code>  注解，扫描 Mapper 文件夹</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;指定Mapper接口所在的包&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusDemoApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(MybatisPlusDemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>编写实体类  <code>User.java</code> （此处使用了 Lombok 简化代码）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>编写 Mapper 包下的  <code>UserMapper</code>  接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5测试查询"><a class="markdownIt-Anchor" href="#5测试查询">#</a> 5. 测试查询</h2>
<ul>
<li>
<p><strong>编写一个测试类 <code>MyBatisPlusTest.java</code> </strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试查询所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSelectList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过条件构造器查询一个list集合，若没有条件，则可以设置null为参数</span></span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>控制台打印查询结果</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519150454211.png" alt="image-20220519150454211"></p>
</li>
</ul>
<h1 id="三-增删改查"><a class="markdownIt-Anchor" href="#三-增删改查">#</a> 三、增删改查</h1>
<h2 id="1basemappert"><a class="markdownIt-Anchor" href="#1basemappert">#</a> 1.BaseMapper&lt;T&gt;</h2>
<blockquote>
<p>说明:</p>
<ul>
<li>通用 CRUD 封装 BaseMapper 接口，为  <code>Mybatis-Plus</code>  启动时自动解析实体表关系映射转换为  <code>Mybatis</code>  内部对象注入容器</li>
<li>泛型  <code>T</code>  为任意实体对象</li>
<li>参数  <code>Serializable</code>  为任意类型主键  <code>Mybatis-Plus</code>  不推荐使用复合主键约定每一张表都有自己的唯一  <code>id</code>  主键</li>
<li>对象  <code>Wrapper</code>  为条件构造器</li>
</ul>
</blockquote>
<p>MyBatis-Plus 中的基本 CRUD 在内置的 BaseMapper 中都已得到了实现，因此我们继承该接口以后可以直接使用。</p>
<p>本次演示的 CRUD 操作不包含参数带有条件构造器的方法，关于条件构造器将单独在一个章节进行演示。</p>
<hr>
<blockquote>
<p><strong>BaseMapper 中提供的 CRUD 方法：</strong></p>
</blockquote>
<ul>
<li>
<p><strong>增加：Insert</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(T entity)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>删除：Delete</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span></span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>修改：Update</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T updateEntity, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 ID 修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>查询：Selete</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line"><span class="function">T <span class="title">selectById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line"><span class="function">T <span class="title">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; selectMaps(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line"><span class="function">List&lt;Object&gt; <span class="title">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="function">IPage&lt;T&gt; <span class="title">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="function">Integer <span class="title">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2调用mapper层实现crud"><a class="markdownIt-Anchor" href="#2调用mapper层实现crud">#</a> 2. 调用 Mapper 层实现 CRUD</h2>
<h3 id="21插入"><a class="markdownIt-Anchor" href="#21插入">#</a> 2.1	插入</h3>
<hr>
<blockquote>
<p><strong>最终执行的结果，所获取的 id 为 1527206783590903810</strong></p>
<p><strong>这是因为 MyBatis-Plus 在实现插入数据时，会默认基于雪花算法的策略生成 id</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试插入一条数据</span></span><br><span class="line"><span class="comment">  * MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;Vz&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">21</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;vz@oz6.cn&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> result = userMapper.insert(user);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;添加成功！&quot;</span> : <span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">    <span class="comment">//1527206783590903810（当前 id 为雪花算法自动生成的id）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;id自动获取&quot;</span> + user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22删除"><a class="markdownIt-Anchor" href="#22删除">#</a> 2.2	删除</h3>
<hr>
<h4 id="a-根据id删除数据"><a class="markdownIt-Anchor" href="#a-根据id删除数据">#</a> a、根据 ID 删除数据</h4>
<blockquote>
<p><strong>调用方法：int deleteById (Serializable id);</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id删除一条数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = userMapper.deleteById(<span class="number">1527206783590903810L</span>);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="b-根据id批量删除数据"><a class="markdownIt-Anchor" href="#b-根据id批量删除数据">#</a> b、根据 ID 批量删除数据</h4>
<blockquote>
<p><strong>调用方法：int deleteBatchIds (@Param (Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试通过id批量删除数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteBatchIds</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(<span class="number">6L</span>,<span class="number">7L</span>,<span class="number">8L</span>);</span><br><span class="line">    <span class="keyword">int</span> result = userMapper.deleteBatchIds(ids);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="c-根据map条件删除数据"><a class="markdownIt-Anchor" href="#c-根据map条件删除数据">#</a> c、根据 Map 条件删除数据</h4>
<blockquote>
<p><strong>调用方法：int deleteByMap (@Param (Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试根据Map集合中所设置的条件删除数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteByMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当前演示为根据name和age删除数据</span></span><br><span class="line">    <span class="comment">//执行SQL为：DELETE FROM user WHERE name = ? AND age = ?</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Vz&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    <span class="keyword">int</span> result = userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23修改"><a class="markdownIt-Anchor" href="#23修改">#</a> 2.3	修改</h3>
<blockquote>
<p><strong>调用方法：int updateById (@Param (Constants.ENTITY) T entity);</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id修改用户信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行SQL为： UPDATE user SET name=?, age=?, email=? WHERE id=?</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">6L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;VzUpdate&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;Vz@sina.com&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> result = userMapper.updateById(user);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24查询"><a class="markdownIt-Anchor" href="#24查询">#</a> 2.4	查询</h3>
<hr>
<h4 id="a-根据id查询用户信息"><a class="markdownIt-Anchor" href="#a-根据id查询用户信息">#</a> a、根据 ID 查询用户信息</h4>
<blockquote>
<p><strong>调用方法：T selectById (Serializable id);</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id查询用户数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="b-根据多个id查询多个用户信息"><a class="markdownIt-Anchor" href="#b-根据多个id查询多个用户信息">#</a> b、根据多个 ID 查询多个用户信息</h4>
<blockquote>
<p><strong>调用方法：List<T> selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</T></strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据多个id查询用户数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectBatchIds</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行SQL为：SELECT id,name,age,email FROM user WHERE id IN ( ? , ? , ? )</span></span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">3L</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(ids);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="c-根据map条件查询用户信息"><a class="markdownIt-Anchor" href="#c-根据map条件查询用户信息">#</a> c、根据 Map 条件查询用户信息</h4>
<blockquote>
<p><strong>调用方法：List<T> selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</T></strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据Map所设置的条件查询用户</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectByMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行SQL为：SELECT id,name,age,email FROM user WHERE age = ?</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="d-查询所有用户信息"><a class="markdownIt-Anchor" href="#d-查询所有用户信息">#</a> d、查询所有用户信息</h4>
<blockquote>
<p><strong>调用方法：List<T> selectList(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);</T></T></strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试查询所有数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSelectList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3通用service"><a class="markdownIt-Anchor" href="#3通用service">#</a> 3. 通用 Service</h2>
<blockquote>
<p>说明:</p>
<ul>
<li>通用 Service CRUD 封装 <code>IService</code>  接口，进一步封装 CRUD 采用  <code>get 查询单行</code>   <code>remove 删除</code>   <code>list 查询集合</code>   <code>page 分页</code>  前缀命名方式区分  <code>Mapper</code>  层避免混淆，</li>
<li>泛型  <code>T</code>  为任意实体对象</li>
<li>建议如果存在自定义通用 Service 方法的可能，请创建自己的  <code>IBaseService</code>  继承  <code>Mybatis-Plus</code>  提供的基类</li>
<li>对象  <code>Wrapper</code>  为 条件构造器</li>
</ul>
</blockquote>
<p>MyBatis-Plus 中有一个接口 ** <code>IService</code> ** 和其实现类 <strong> <code>ServiceImpl</code> </strong>，封装了常见的业务层逻辑，详情查看源码 IService 和 ServiceImpl</p>
<p>因此我们在使用的时候仅需在自己定义的 ** <code>Service</code> <strong> 接口中继承</strong> <code>IService</code> <strong> 接口，在自己的实现类中实现自己的 Service 并继承</strong> <code>ServiceImpl</code> ** 即可</p>
<hr>
<blockquote>
<p><strong>IService 中的 CRUD 方法</strong></p>
</blockquote>
<ul>
<li>
<p><strong>增加：Save、SaveOrUpdate</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">save</span><span class="params">(T entity)</span></span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span></span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdate</span><span class="params">(T entity)</span></span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span></span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>删除：Remove</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span></span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>修改：Update</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateById</span><span class="params">(T entity)</span></span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span></span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>查询：Get、List、Count</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line"><span class="function">T <span class="title">getById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line"><span class="function">T <span class="title">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="function">T <span class="title">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="keyword">boolean</span> throwEx)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; <span class="function">V <span class="title">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="keyword">super</span> Object, V&gt; mapper)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="function">Collection&lt;T&gt; <span class="title">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="function">Collection&lt;T&gt; <span class="title">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span></span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; listMaps();</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line"><span class="function">List&lt;Object&gt; <span class="title">listObjs</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; <span class="function">List&lt;V&gt; <span class="title">listObjs</span><span class="params">(Function&lt;? <span class="keyword">super</span> Object, V&gt; mapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="function">List&lt;Object&gt; <span class="title">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; <span class="function">List&lt;V&gt; <span class="title">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="keyword">super</span> Object, V&gt; mapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>分页：Page</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line"><span class="function">T <span class="title">getById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line"><span class="function">T <span class="title">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="function">T <span class="title">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="keyword">boolean</span> throwEx)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; <span class="function">V <span class="title">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="keyword">super</span> Object, V&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4调用service层操作数据"><a class="markdownIt-Anchor" href="#4调用service层操作数据">#</a> 4. 调用 Service 层操作数据</h2>
<blockquote>
<p>我们在自己的 Service 接口中通过继承 MyBatis-Plus 提供的 IService 接口，不仅可以获得其提供的 CRUD 方法，而且还可以使用自身定义的方法。</p>
</blockquote>
<ul>
<li>
<p><strong>创建 <code>UserService</code>  并继承 <code>IService</code> </strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * UserService继承IService模板提供的基础功能 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">User</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>创建 <code>UserService</code>  的实现类并继承 <code>ServiceImpl</code> </strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * ServiceImpl实现了IService，提供了IService中基础功能的实现 </span></span><br><span class="line"><span class="comment">  * 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">UserMapper</span>,<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>测试查询记录数</strong></p>
<blockquote>
<p><strong>调用方法：int count ();</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询总记录数</span></span><br><span class="line">    <span class="comment">//执行的SQL为：SELECT COUNT( * ) FROM user</span></span><br><span class="line">    <span class="keyword">long</span> count = userService.count();</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数：&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>测试批量插入数据</strong></p>
<blockquote>
<p><strong>调用方法：boolean saveBatch (Collection<T> entityList);</T></strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;Vz&quot;</span>+i);</span><br><span class="line">        user.setAge(<span class="number">20</span>+i);</span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> b = userService.saveBatch(list);</span><br><span class="line">    System.out.println(b ? <span class="string">&quot;添加成功！&quot;</span> : <span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="四-常用注解"><a class="markdownIt-Anchor" href="#四-常用注解">#</a> 四、常用注解</h1>
<blockquote>
<p>MyBatis-Plus 提供的注解可以帮我们解决一些数据库与实体之间相互映射的问题。</p>
</blockquote>
<h2 id="1tablename"><a class="markdownIt-Anchor" href="#1tablename">#</a> 1.@TableName</h2>
<blockquote>
<p>经过以上的测试，在使用 MyBatis-Plus 实现基本的 CRUD 时，我们并没有指定要操作的表，只是在 Mapper 接口继承 BaseMapper 时，设置了泛型 User，而操作的表为 user 表，由此得出结论，MyBatis-Plus 在确定操作的表时，由 BaseMapper 的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致。</p>
</blockquote>
<h3 id="11引出问题"><a class="markdownIt-Anchor" href="#11引出问题">#</a> 1.1	引出问题</h3>
<hr>
<blockquote>
<p><strong>若实体类类型的类名和要操作的表的表名不一致，会出现什么问题？</strong></p>
</blockquote>
<ul>
<li>
<p>我们将表 <code>user</code>  更名为 <code>t_user</code> ，测试查询功能</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520093844842.png" alt="image-20220520093844842"></p>
</li>
<li>
<p>程序抛出异常，<strong>Table ‘mybatis_plus.user’ doesn’t exist</strong>，因为现在的表名为 <code>t_user</code> ，而默认操作的表名和实体类型的类名一致，即 <code>user</code>  表</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520094126411.png" alt="image-20220520094126411"></p>
</li>
</ul>
<h3 id="12解决问题"><a class="markdownIt-Anchor" href="#12解决问题">#</a> 1.2	解决问题</h3>
<hr>
<h4 id="a-使用注解解决问题"><a class="markdownIt-Anchor" href="#a-使用注解解决问题">#</a> a、使用注解解决问题</h4>
<blockquote>
<p><strong>在实体类类型上添加 <code>@TableName(&quot;t_user&quot;)</code> ，标识实体类对应的表，即可成功执行 SQL 语句</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="b-使用全局配置解决问题"><a class="markdownIt-Anchor" href="#b-使用全局配置解决问题">#</a> b、使用全局配置解决问题</h4>
<blockquote>
<p><strong>在开发的过程中，我们经常遇到以上的问题，即实体类所对应的表都有固定的前缀，例如  <code>t_</code>  或  <code>tbl_</code>  此时，可以使用 MyBatis-Plus 提供的全局配置，为实体类所对应的表名设置默认的前缀，那么就不需要在每个实体类上通过 @TableName 标识实体类对应的表</strong></p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure>
<h2 id="2tableid"><a class="markdownIt-Anchor" href="#2tableid">#</a> 2.@TableId</h2>
<blockquote>
<p><strong>经过以上的测试，MyBatis-Plus 在实现 CRUD 时，会默认将 id 作为主键列，并在插入数据时，默认基于雪花算法的策略生成 id</strong></p>
</blockquote>
<h3 id="21引出问题"><a class="markdownIt-Anchor" href="#21引出问题">#</a> 2.1	引出问题</h3>
<hr>
<blockquote>
<p><strong>若实体类和表中表示主键的不是 id，而是其他字段，例如 uid，MyBatis-Plus 会自动识别 uid 为主键列吗？</strong></p>
</blockquote>
<ul>
<li>
<p>我们实体类中的属性 <code>id</code>  改为 <code>uid</code> ，将表中的字段 <code>id</code>  也改为 <code>uid</code> ，测试添加功能</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520100939157.png" alt="image-20220520100939157"></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520100715109.png" alt="image-20220520100715109"></p>
</li>
<li>
<p>程序抛出异常，<strong>Field ‘uid’ doesn’t have a default value</strong>，说明 MyBatis-Plus 没有将 <code>uid</code>  作为主键赋值</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520101317761.png" alt="image-20220520101317761"></p>
</li>
</ul>
<h3 id="22解决问题"><a class="markdownIt-Anchor" href="#22解决问题">#</a> 2.2	解决问题</h3>
<hr>
<blockquote>
<p><strong>在实体类中 uid 属性上通过 <code>@TableId</code>  将其标识为主键，即可成功执行 SQL 语句</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Date</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23tableid的value属性"><a class="markdownIt-Anchor" href="#23tableid的value属性">#</a> 2.3	@TableId 的 value 属性</h3>
<hr>
<blockquote>
<p>若实体类中主键对应的属性为 id，而表中表示主键的字段为 uid，此时若只在属性 id 上添加注解 @TableId，则抛出异常<strong> Unknown column ‘id’ in ‘field list’</strong>，即 MyBatis-Plus 仍然会将 id 作为表的主键操作，而表中表示主键的是字段 uid 此时需要通过 @TableId 注解的 value 属性，指定表中的主键字段， <code>@TableId(&quot;uid&quot;)</code>  或 <code>@TableId(value=&quot;uid&quot;)</code></p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520103030977.png" alt="image-20220520103030977"></p>
<h3 id="24tableid的type属性"><a class="markdownIt-Anchor" href="#24tableid的type属性">#</a> 2.4	@TableId 的 type 属性</h3>
<hr>
<blockquote>
<p><strong>type 属性用来定义主键策略：默认雪花算法</strong></p>
</blockquote>
<p><strong>常用的主键策略：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IdType.ASSIGN_ID（默认）</td>
<td style="text-align:center">基于雪花算法的策略生成数据 id，与数据库 id 是否设置自增无关</td>
</tr>
<tr>
<td style="text-align:center">IdType.AUTO</td>
<td style="text-align:center">使用数据库的自增策略，注意，该类型请确保数据库设置了 id 自增，</td>
</tr>
</tbody>
</table>
<p><strong>配置全局主键策略：</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#配置mp的主键策略为自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure>
<h2 id="3tbalefield"><a class="markdownIt-Anchor" href="#3tbalefield">#</a> 3.@TbaleField</h2>
<blockquote>
<p>经过以上的测试，我们可以发现，MyBatis-Plus 在执行 SQL 语句时，要保证实体类中的属性名和表中的字段名一致</p>
<p>如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢？</p>
</blockquote>
<h3 id="31情况一"><a class="markdownIt-Anchor" href="#31情况一">#</a> 3.1	情况一</h3>
<hr>
<p>若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格</p>
<p>例如实体类属性 <code>userName</code> ，表中字段 <code>user_name</code></p>
<p>此时 MyBatis-Plus 会自动将下划线命名风格转化为驼峰命名风格</p>
<p>相当于在 MyBatis 中配置</p>
<h3 id="32情况二"><a class="markdownIt-Anchor" href="#32情况二">#</a> 3.2	情况二</h3>
<hr>
<blockquote>
<p>若实体类中的属性和表中的字段不满足情况 1</p>
<p>例如实体类属性 <code>name</code> ，表中字段 <code>username</code></p>
<p>此时需要在实体类属性上使用 <code>@TableField(&quot;username&quot;)</code>  设置属性所对应的字段名</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId(&quot;uid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4tablelogic"><a class="markdownIt-Anchor" href="#4tablelogic">#</a> 4.@TableLogic</h2>
<h3 id="41逻辑删除"><a class="markdownIt-Anchor" href="#41逻辑删除">#</a> 4.1	逻辑删除</h3>
<hr>
<blockquote>
<p>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</p>
<p>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为 “被删除状态”，之后在数据库中仍旧能看到此条数据记录</p>
<p>使用场景：可以进行数据恢复</p>
</blockquote>
<h3 id="42实现逻辑删除"><a class="markdownIt-Anchor" href="#42实现逻辑删除">#</a> 4.2	实现逻辑删除</h3>
<hr>
<ul>
<li>
<p><strong>数据库中创建逻辑删除状态列，设置默认值为 0</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520134529809.png" alt="image-20220520134529809"></p>
</li>
<li>
<p><strong>实体类中添加逻辑删除属性</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520134636112.png" alt="image-20220520134636112"></p>
</li>
<li>
<p><strong>测试删除功能，真正执行的是修改</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = userMapper.deleteById(<span class="number">1527472864163348482L</span>);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520135637388.png" alt="image-20220520135637388"></p>
</li>
<li>
<p><strong>此时执行查询方法，查询的结果为自动添加条件 <code>is_deleted=0</code> </strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520140036445.png" alt="image-20220520140036445"></p>
</li>
</ul>
<h1 id="五-条件构造器"><a class="markdownIt-Anchor" href="#五-条件构造器">#</a> 五、条件构造器</h1>
<h2 id="1wrapper介绍"><a class="markdownIt-Anchor" href="#1wrapper介绍">#</a> 1.Wrapper 介绍</h2>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521092812125.png" alt="image-20220521092812125"></p>
<ul>
<li>
<p><code>Wrapper</code>  ： 条件构造抽象类，最顶端父类</p>
<ul>
<li>
<p><code>AbstractWrapper </code> ： 用于查询条件封装，生成 sql 的 where 条件</p>
<ul>
<li>
<p><code>QueryWrapper </code> ： 查询条件封装</p>
</li>
<li>
<p><code>UpdateWrapper </code> ： Update 条件封装</p>
</li>
<li>
<p><code>AbstractLambdaWrapper </code> ： 使用 Lambda 语法</p>
<ul>
<li>
<p><code>LambdaQueryWrapper </code> ：用于 Lambda 语法使用的查询 Wrapper</p>
</li>
<li>
<p><code>LambdaUpdateWrapper </code> ： Lambda 更新封装 Wrapper</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2querywrapper"><a class="markdownIt-Anchor" href="#2querywrapper">#</a> 2.QueryWrapper</h2>
<ul>
<li>
<p><strong>组装查询条件</strong></p>
<blockquote>
<p>** 执行 SQL：**SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询用户名包含a，年龄在20到30之间，邮箱信息不为null的用户信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).between(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>,<span class="number">30</span>).isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>组装排序条件</strong></p>
<blockquote>
<p>** 执行 SQL：**SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询用户信息，按照年龄的降序排序，若年龄相同，则按照id升序排序</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.orderByDesc(<span class="string">&quot;age&quot;</span>).orderByAsc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>组装删除条件</strong></p>
<blockquote>
<p>** 执行 SQL：**UPDATE t_user SET is_deleted=1 WHERE is_deleted=0 AND (email IS NULL)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除邮箱地址为null的用户信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> result = userMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>条件的优先级</strong></p>
<blockquote>
<p>** 执行 SQL：**UPDATE t_user SET user_name=?, email=? WHERE is_deleted=0 AND (age&gt; ? AND user_name LIKE ? OR email IS NULL)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> UpdateWrapper&lt;&gt;();</span><br><span class="line">    updateWrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>).like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).or().isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;Oz&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;test@oz6.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = userMapper.update(user, updateWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>** 执行 SQL：**UPDATE t_user SET username=?, email=? WHERE is_deleted=0 AND (username LIKE ? AND (age&gt; ? OR email IS NULL))</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> UpdateWrapper&lt;&gt;();</span><br><span class="line">    updateWrapper.like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).and(i-&gt;i.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;Vz7797&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;test@ss8o.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = userMapper.update(user, updateWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>组装 select 子句</strong></p>
<blockquote>
<p>** 执行 SQL：**SELECT username,age,email FROM t_user WHERE is_deleted=0</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询用户的用户名、年龄、邮箱信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>实现子查询</strong></p>
<blockquote>
<p>** 执行 SQL：**SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (uid IN (select uid from t_user where uid &lt;= 100))</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询id小于等于100的用户信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.inSql(<span class="string">&quot;uid&quot;</span>, <span class="string">&quot;select uid from t_user where uid &lt;= 100&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3updatewrapper"><a class="markdownIt-Anchor" href="#3updatewrapper">#</a> 3.UpdateWrapper</h2>
<blockquote>
<p>UpdateWrapper 不仅拥有 QueryWrapper 的组装条件功能，还提供了 set 方法进行修改对应条件的数据库信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> UpdateWrapper&lt;&gt;();</span><br><span class="line">    updateWrapper.like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).and( i -&gt; i.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>)).set(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;svip@qq.com&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> result = userMapper.update(<span class="keyword">null</span>, updateWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4condition"><a class="markdownIt-Anchor" href="#4condition">#</a> 4.condition</h2>
<blockquote>
<p>在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响 SQL 执行的结果</p>
</blockquote>
<ul>
<li>
<p><strong>思路一</strong></p>
<blockquote>
<p>** 执行 SQL：**SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (user_name LIKE ? AND age &lt;= ?)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test09</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String username = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    Integer ageBegin = <span class="keyword">null</span>;</span><br><span class="line">    Integer ageEnd = <span class="number">30</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(username))&#123;</span><br><span class="line">        <span class="comment">//isNotBlank判断某个字符创是否不为空字符串、不为null、不为空白符</span></span><br><span class="line">        queryWrapper.like(<span class="string">&quot;user_name&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ageBegin != <span class="keyword">null</span>)&#123;</span><br><span class="line">        queryWrapper.ge(<span class="string">&quot;age&quot;</span>, ageBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ageEnd != <span class="keyword">null</span>)&#123;</span><br><span class="line">        queryWrapper.le(<span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>思路二</strong></p>
<blockquote>
<p>上面的实现方案没有问题，但是代码比较复杂，我们可以使用带 condition 参数的重载方法构建查询条件，简化代码的编写</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String username = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    Integer ageBegin = <span class="keyword">null</span>;</span><br><span class="line">    Integer ageEnd = <span class="number">30</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.like(StringUtils.isNotBlank(username), <span class="string">&quot;user_name&quot;</span>, username)</span><br><span class="line">        .ge(ageBegin != <span class="keyword">null</span>, <span class="string">&quot;age&quot;</span>, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="keyword">null</span>, <span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5lambdaquerywrapper"><a class="markdownIt-Anchor" href="#5lambdaquerywrapper">#</a> 5.LambdaQueryWrapper</h2>
<blockquote>
<p>功能等同于 QueryWrapper，提供了 Lambda 表达式的语法可以避免填错列名。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String username = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    Integer ageBegin = <span class="keyword">null</span>;</span><br><span class="line">    Integer ageEnd = <span class="number">30</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.like(StringUtils.isNotBlank(username), User::getName, username)</span><br><span class="line">        .ge(ageBegin != <span class="keyword">null</span>, User::getAge, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="keyword">null</span>, User::getAge, ageEnd);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6lambdaupdatewrapper"><a class="markdownIt-Anchor" href="#6lambdaupdatewrapper">#</a> 6.LambdaUpdateWrapper</h2>
<blockquote>
<p>功能等同于 UpdateWrapper，提供了 Lambda 表达式的语法可以避免填错列名。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    LambdaUpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> LambdaUpdateWrapper&lt;&gt;();</span><br><span class="line">    updateWrapper.like(User::getName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .and(i -&gt; i.gt(User::getAge, <span class="number">20</span>).or().isNull(User::getEmail));</span><br><span class="line">    updateWrapper.set(User::getName, <span class="string">&quot;小黑&quot;</span>).set(User::getEmail,<span class="string">&quot;abc@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> result = userMapper.update(<span class="keyword">null</span>, updateWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;result：&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="六-常用插件"><a class="markdownIt-Anchor" href="#六-常用插件">#</a> 六、常用插件</h1>
<h2 id="1分页插件"><a class="markdownIt-Anchor" href="#1分页插件">#</a> 1. 分页插件</h2>
<blockquote>
<p>MyBatis Plus 自带分页插件，只要简单的配置即可实现分页功能</p>
</blockquote>
<ul>
<li>
<p><strong>添加配置类 <code>MyBatisPlusConfig</code> </strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title">mybatisPlusInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = <span class="keyword">new</span> MybatisPlusInterceptor();</span><br><span class="line">        <span class="comment">//添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>编写测试方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//new Page()中的两个参数分别是当前页码，每页显示数量</span></span><br><span class="line">    Page&lt;User&gt; page = userMapper.selectPage(<span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>), <span class="keyword">null</span>);</span><br><span class="line">    List&lt;User&gt; users = page.getRecords();</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2自定义分页"><a class="markdownIt-Anchor" href="#2自定义分页">#</a> 2. 自定义分页</h2>
<blockquote>
<p>上面调用的是 MyBatis-Plus 提供的带有分页的方法，那么我们自己定义的方法如何实现分页呢？</p>
</blockquote>
<ul>
<li>
<p><strong>在 <code>UserMapper</code>  接口中定义一个方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据年龄查询用户列表，分页显示 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> age 年龄 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">selectPageVo</span><span class="params">(<span class="meta">@Param(&quot;page&quot;)</span> Page&lt;User&gt; page,<span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>在 <code>UserMapper.xml</code>  中编写 SQL 实现该方法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPageVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select id,username as name,age,email from t_user where age &gt; #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>编写测试方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPageVo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Page&lt;User&gt; page = userMapper.selectPageVo(<span class="keyword">new</span> Page&lt;User&gt;(<span class="number">1</span>,<span class="number">2</span>), <span class="number">20</span>);</span><br><span class="line">    List&lt;User&gt; users = page.getRecords();</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3乐观锁"><a class="markdownIt-Anchor" href="#3乐观锁">#</a> 3. 乐观锁</h2>
<blockquote>
<p><strong>作用：当要更新一条记录的时候，希望这条记录没有被别人更新</strong></p>
</blockquote>
<p>乐观锁的实现方式：</p>
<ul>
<li>取出记录时，获取当前 version</li>
<li>更新时，带上这个 version</li>
<li>执行更新时， set version = newVersion where version = oldVersion</li>
<li>如果 version 不对，就更新失败</li>
</ul>
<h3 id="31场景"><a class="markdownIt-Anchor" href="#31场景">#</a> 3.1	场景</h3>
<hr>
<ul>
<li>一件商品，成本价是 80 元，售价是 100 元。老板先是通知小李，说你去把商品价格增加 50 元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到 150 元，价格太高，可能会影响销量。又通知小王，你把商品价格降低 30 元。</li>
<li>此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格 100 元；小王也在操作，取出的商品价格也是 100 元。小李将价格加了 50 元，并将 100+50=150 元存入了数据库；小王将商品减了 30 元，并将 100-30=70 元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。</li>
<li>现在商品价格是 70 元，比成本价低 10 元。几分钟后，这个商品很快出售了 1 千多件商品，老板亏 1 万多。</li>
</ul>
<h3 id="32乐观锁与悲观锁"><a class="markdownIt-Anchor" href="#32乐观锁与悲观锁">#</a> 3.2	乐观锁与悲观锁</h3>
<hr>
<ul>
<li>上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150 元，这样他会将 120 元存入数据库。</li>
<li>如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证最终的价格是 120 元。</li>
</ul>
<h3 id="33模拟修改冲突"><a class="markdownIt-Anchor" href="#33模拟修改冲突">#</a> 3.3	模拟修改冲突</h3>
<hr>
<ul>
<li>
<p><strong>数据库中增加商品表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_product ( </span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>, </span><br><span class="line">    NAME <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>, </span><br><span class="line">    price <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;价格&#x27;</span>, </span><br><span class="line">    VERSION <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>添加一条数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_product (id, NAME, price) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;外星人笔记本&#x27;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>添加一个实体类 <code>Product</code> </strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>添加一个 Mapper 接口 <code>ProductMapper</code> </strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Product</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>测试方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProduct01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.小李获取商品价格</span></span><br><span class="line">    Product productLi = productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productLi.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.小王获取商品价格</span></span><br><span class="line">    Product productWang = productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productWang.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.小李修改商品价格+50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.小王修改商品价格-30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">    productMapper.updateById(productWang);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.老板查询商品价格</span></span><br><span class="line">    Product productBoss = productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;老板获取的商品价格为：&quot;</span> + productBoss.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>执行结果</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521225803162.png" alt="image-20220521225803162"></p>
</li>
</ul>
<h3 id="34乐观锁解决问题"><a class="markdownIt-Anchor" href="#34乐观锁解决问题">#</a> 3.4	乐观锁解决问题</h3>
<hr>
<ul>
<li>
<p><strong>实体类 <code>version</code>  字段添加注解 <code>@Version</code> </strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>添加乐观锁插件配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title">mybatisPlusInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MybatisPlusInterceptor interceptor = <span class="keyword">new</span> MybatisPlusInterceptor();</span><br><span class="line">    <span class="comment">//添加分页插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">    <span class="comment">//添加乐观锁插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> OptimisticLockerInnerInterceptor());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>再次执行测试方法</strong></p>
<blockquote>
<p>小李查询商品信息：</p>
<p>​	SELECT id,name,price,version FROM t_product WHERE id=?</p>
<p>小王查询商品信息：</p>
<p>​	SELECT id,name,price,version FROM t_product WHERE id=?</p>
<p>小李修改商品价格，自动将 version+1</p>
<p>​	UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</p>
<p>​	Parameters: 外星人笔记本 (String), 150 (Integer), 1 (Integer), 1 (Long), 0 (Integer)</p>
<p>小王修改商品价格，此时 version 已更新，条件不成立，修改失败</p>
<p>​	UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</p>
<p>​	Parameters: 外星人笔记本 (String), 70 (Integer), 1 (Integer), 1 (Long), 0 (Integer)</p>
<p>最终，小王修改失败，查询价格：150</p>
<p>​	SELECT id,name,price,version FROM t_product WHERE id=?</p>
</blockquote>
</li>
<li>
<p><strong>优化执行流程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProduct01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.小李获取商品价格</span></span><br><span class="line">    Product productLi = productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productLi.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.小王获取商品价格</span></span><br><span class="line">    Product productWang = productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productWang.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.小李修改商品价格+50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.小王修改商品价格-30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">int</span> result = productMapper.updateById(productWang);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//操作失败，重试</span></span><br><span class="line">        Product productNew = productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">        productNew.setPrice(productNew.getPrice()-<span class="number">30</span>);</span><br><span class="line">        productMapper.updateById(productNew);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.老板查询商品价格</span></span><br><span class="line">    Product productBoss = productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;老板获取的商品价格为：&quot;</span> + productBoss.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521230448577.png" alt="image-20220521230448577"></p>
</li>
</ul>
<h1 id="七-通用枚举"><a class="markdownIt-Anchor" href="#七-通用枚举">#</a> 七、通用枚举</h1>
<blockquote>
<p>表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用 MyBatis-Plus 的通用枚举来实现</p>
</blockquote>
<ul>
<li>
<p><strong>数据库表添加字段 <code>sex</code> </strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521231317777.png" alt="image-20220521231317777"></p>
</li>
<li>
<p><strong>创建通用枚举类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SexEnum</span> </span>&#123;</span><br><span class="line">    MALE(<span class="number">1</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">    FEMALE(<span class="number">2</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span> <span class="comment">//将注解所标识的属性的值存储到数据库中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sex;</span><br><span class="line">    <span class="keyword">private</span> String sexName;</span><br><span class="line"></span><br><span class="line">    SexEnum(Integer sex, String sexName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.sexName = sexName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>User 实体类中添加属性 sex</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> isDeleted;  <span class="comment">//逻辑删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SexEnum sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>配置扫描通用枚举</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="comment">#指定mapper文件所在的地址</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">banner:</span> <span class="string">off</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#配置mp的主键策略为自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br><span class="line">  <span class="comment">#配置类型别名所对应的包</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.atguigu.mybatisplus.pojo</span></span><br><span class="line">  <span class="comment"># 扫描通用枚举的包</span></span><br><span class="line">  <span class="attr">type-enums-package:</span> <span class="string">com.atguigu.mybatisplus.enums</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>执行测试方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">33</span>);</span><br><span class="line">    user.setSex(SexEnum.MALE);</span><br><span class="line">    <span class="keyword">int</span> result = userMapper.insert(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="八-多数据源"><a class="markdownIt-Anchor" href="#八-多数据源">#</a> 八、多数据源</h1>
<blockquote>
<p>适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等</p>
</blockquote>
<p>场景说明：</p>
<p>我们创建两个库，分别为： <code>mybatis_plus</code> （以前的库不动）与 <code>mybatis_plus_1</code> （新建），将 mybatis_plus 库的 <code>product</code>  表移动到 mybatis_plus_1 库，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功</p>
<h2 id="1创建数据库及表"><a class="markdownIt-Anchor" href="#1创建数据库及表">#</a> 1. 创建数据库及表</h2>
<ul>
<li>
<p><strong>创建数据库 <code>mybatis_plus_1</code>  和表 `product</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis_plus_1` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>;</span><br><span class="line">use `mybatis_plus_1`; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product ( </span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>, </span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>, </span><br><span class="line">    price <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;价格&#x27;</span>, </span><br><span class="line">    version <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>添加测试数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product (id, NAME, price) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;外星人笔记本&#x27;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>删除 <code>mybatis_plus</code>  库中的 <code>product</code>  表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mybatis_plus; </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> product;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2新建工程引入依赖"><a class="markdownIt-Anchor" href="#2新建工程引入依赖">#</a> 2. 新建工程引入依赖</h2>
<blockquote>
<p><strong>自行新建一个 Spring Boot 工程并选择 MySQL 驱动及 Lombok 依赖</strong></p>
</blockquote>
<p><strong>引入 MyBaits-Plus 的依赖及多数据源的依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3编写配置文件"><a class="markdownIt-Anchor" href="#3编写配置文件">#</a> 3. 编写配置文件</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 配置数据源信息</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="comment"># 设置默认的数据源或者数据源组,默认值即为master</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源</span></span><br><span class="line">      <span class="attr">strict:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">master:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">132537</span></span><br><span class="line">        <span class="attr">slave_1:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">132537</span></span><br></pre></td></tr></table></figure>
<h2 id="4创建实体类"><a class="markdownIt-Anchor" href="#4创建实体类">#</a> 4. 创建实体类</h2>
<ul>
<li>
<p>新建一个 <code>User</code>  实体类（如果数据库表名有 t_前缀记得配置）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>新建一个实体类 <code>Product</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5创建mapper及service"><a class="markdownIt-Anchor" href="#5创建mapper及service">#</a> 5. 创建 Mapper 及 Service</h2>
<ul>
<li>
<p>新建接口 <code>UserMapper</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>新建接口 <code>ProductMapper</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Product</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>新建 Service 接口 <code>UserService</code>  指定操作的数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;master&quot;)</span> <span class="comment">//指定操作的数据源，master为user表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">User</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>新建 Service 接口 <code>ProductService</code>  指定操作的数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;slave_1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">Product</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自行建立 Service 的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6编写测试方法"><a class="markdownIt-Anchor" href="#6编写测试方法">#</a> 6. 编写测试方法</h2>
<blockquote>
<p><strong>记得在启动类中添加注解 <code>@MapperScan()</code> </strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDatasourceApplicationTests</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	ProductService productService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		User user = userService.getById(<span class="number">1L</span>);</span><br><span class="line">		Product product = productService.getById(<span class="number">1L</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;User = &quot;</span> + user);</span><br><span class="line">		System.out.println(<span class="string">&quot;Product = &quot;</span> + product);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522113049945.png" alt="image-20220522113049945"></p>
<h1 id="九-mybatisx插件"><a class="markdownIt-Anchor" href="#九-mybatisx插件">#</a> 九、MyBatisX 插件</h1>
<blockquote>
<p>MyBatis-Plus 为我们提供了强大的 mapper 和 service 模板，能够大大的提高开发效率。</p>
<p>但是在真正开发过程中，MyBatis-Plus 并不能为我们解决所有问题，例如一些复杂的 SQL，多表联查，我们就需要自己去编写代码和 SQL 语句，我们该如何快速的解决这个问题呢，这个时候可以使用 MyBatisX 插件。</p>
<p>MyBatisX 一款基于 IDEA 的快速开发插件，为效率而生。</p>
</blockquote>
<h2 id="1安装mybatisx插件"><a class="markdownIt-Anchor" href="#1安装mybatisx插件">#</a> 1. 安装 MyBatisX 插件</h2>
<blockquote>
<p><strong>打开 IDEA，File-&gt; Setteings-&gt;Plugins-&gt;MyBatisX，搜索栏搜索 MyBatisX 然后安装。</strong></p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522115718361.png" alt="image-20220522115718361"></p>
<h2 id="2快速生成代码"><a class="markdownIt-Anchor" href="#2快速生成代码">#</a> 2. 快速生成代码</h2>
<ul>
<li>
<p>新建一个 Spring Boot 项目引入依赖（创建工程时记得勾选 lombok 及 mysql 驱动）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置数据源信息</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">132537</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 IDEA 中与数据库建立链接</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522120758740.png" alt="image-20220522120758740"></p>
</li>
<li>
<p>填写数据库信息并保存</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121434468.png" alt="image-20220522121434468"></p>
</li>
<li>
<p>找到我们需要生成的表点击右键</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121613909.png" alt="image-20220522121613909"></p>
</li>
<li>
<p>填写完信息以后下一步</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122127649.png" alt="image-20220522122127649"></p>
</li>
<li>
<p>继续填写信息</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122525598.png" alt="image-20220522122525598"></p>
</li>
<li>
<p><strong>大功告成（真特么好用 yyds）</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122612334.png" alt="image-20220522122612334"></p>
</li>
</ul>
<h2 id="3快速生成crud"><a class="markdownIt-Anchor" href="#3快速生成crud">#</a> 3. 快速生成 CRUD</h2>
<blockquote>
<p>MyBaitsX 可以根据我们在 Mapper 接口中输入的方法名快速帮我们生成对应的 sql 语句</p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123143852.png" alt="image-20220522123143852"></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123202310.png" alt="image-20220522123202310"></p>
<h1 id="十-致谢"><a class="markdownIt-Anchor" href="#十-致谢">#</a> 十、致谢</h1>
<p>感谢尚硅谷杨博超老师：<a href="https://www.bilibili.com/video/BV12R4y157Be?p=1">https://www.bilibili.com/video/BV12R4y157Be?p=1</a></p>
<p>感谢 MyBatis-Plus 作者苞米豆：<a href="https://baomidou.com/">https://baomidou.com/</a></p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis笔记</title>
    <url>/passages/MyBatis/</url>
    <content><![CDATA[<h1 id="mybatis简介"><a class="markdownIt-Anchor" href="#mybatis简介">#</a> Mybatis 简介</h1>
<h2 id="mybatis历史"><a class="markdownIt-Anchor" href="#mybatis历史">#</a> MyBatis 历史</h2>
<ul>
<li>MyBatis 最初是 Apache 的一个开源项目 iBatis, 2010 年 6 月这个项目由 Apache Software Foundation 迁移到了 Google Code。随着开发团队转投 Google Code 旗下，iBatis3.x 正式更名为 MyBatis。代码于 2013 年 11 月迁移到 Github</li>
<li>iBatis 一词来源于 “internet” 和 “abatis” 的组合，是一个基于 Java 的持久层框架。iBatis 提供的持久层框架包括 SQL Maps 和 Data Access Objects（DAO）</li>
</ul>
<h2 id="mybatis特性"><a class="markdownIt-Anchor" href="#mybatis特性">#</a> MyBatis 特性</h2>
<ol>
<li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li>
<li>MyBatis 可以使用简单的 XML 或注解用于配置和原始映射，将接口和 Java 的 POJO（Plain Old Java Objects，普通的 Java 对象）映射成数据库中的记录</li>
<li>MyBatis 是一个 半自动的 ORM（Object Relation Mapping）框架</li>
</ol>
<h2 id="mybatis下载"><a class="markdownIt-Anchor" href="#mybatis下载">#</a> MyBatis 下载</h2>
<ul>
<li><a href="https://github.com/mybatis/mybatis-3">MyBatis 下载地址</a></li>
<li><img src="/passages/MyBatis/MyBatis%E4%B8%8B%E8%BD%BD.png" alt></li>
</ul>
<h2 id="和其它持久化层技术对比"><a class="markdownIt-Anchor" href="#和其它持久化层技术对比">#</a> 和其它持久化层技术对比</h2>
<ul>
<li>JDBC</li>
<li>SQL 夹杂在 Java 代码中耦合度高，导致硬编码内伤
<ul>
<li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</li>
<li>代码冗长，开发效率低</li>
</ul>
</li>
<li>Hibernate 和 JPA</li>
<li>操作简便，开发效率高
<ul>
<li>程序中的长难复杂 SQL 需要绕过框架</li>
<li>内部自动生产的 SQL，不容易做特殊优化</li>
<li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。</li>
<li>反射操作太多，导致数据库性能下降</li>
</ul>
</li>
<li>MyBatis</li>
<li>轻量级，性能出色
<ul>
<li>SQL 和 Java 编码分开，功能边界清晰。Java 代码专注业务、SQL 语句专注数据</li>
<li>开发效率稍逊于 HIbernate，但是完全能够接受</li>
</ul>
</li>
</ul>
<h1 id="搭建mybatis"><a class="markdownIt-Anchor" href="#搭建mybatis">#</a> 搭建 MyBatis</h1>
<h2 id="开发环境"><a class="markdownIt-Anchor" href="#开发环境">#</a> 开发环境</h2>
<ul>
<li>IDE：idea 2019.2</li>
<li>构建工具：maven 3.5.4</li>
<li>MySQL 版本：MySQL 5.7</li>
<li>MyBatis 版本：MyBatis 3.5.7</li>
</ul>
<h2 id="创建maven工程"><a class="markdownIt-Anchor" href="#创建maven工程">#</a> 创建 maven 工程</h2>
<ul>
<li>
<p>打包方式：jar</p>
</li>
<li>
<p>引入依赖</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="创建mybatis的核心配置文件"><a class="markdownIt-Anchor" href="#创建mybatis的核心配置文件">#</a> 创建 MyBatis 的核心配置文件</h2>
<blockquote>
<p>习惯上命名为 <code>mybatis-config.xml</code> ，这个文件名仅仅只是建议，并非强制要求。将来整合 Spring 之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。<br>
核心配置文件主要用于配置连接数据库的环境以及 MyBatis 的全局配置信息<br>
核心配置文件存放的位置是 src/main/resources 目录下</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">	<span class="comment">&lt;!--设置连接数据库的环境--&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>  </span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>  </span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/MyBatis&quot;</span>/&gt;</span>  </span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span>  </span><br><span class="line">	<span class="comment">&lt;!--引入映射文件--&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="创建mapper接口"><a class="markdownIt-Anchor" href="#创建mapper接口">#</a> 创建 mapper 接口</h2>
<blockquote>
<p>MyBatis 中的 mapper 接口相当于以前的 dao。但是区别在于，mapper 仅仅是接口，我们不需要提供实现类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatis.mapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;  </span><br><span class="line">	<span class="comment">/**  </span></span><br><span class="line"><span class="comment">	* 添加用户信息  </span></span><br><span class="line"><span class="comment">	*/</span>  </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">insertUser</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建mybatis的映射文件"><a class="markdownIt-Anchor" href="#创建mybatis的映射文件">#</a> 创建 MyBatis 的映射文件</h2>
<ul>
<li>相关概念：ORM（Object Relationship Mapping）对象关系映射。</li>
<li>对象：Java 的实体类对象
<ul>
<li>关系：关系型数据库</li>
<li>映射：二者之间的对应关系</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Java 概念</th>
<th>数据库概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td>表</td>
</tr>
<tr>
<td>属性</td>
<td>字段 / 列</td>
</tr>
<tr>
<td>对象</td>
<td>记录 / 行</td>
</tr>
</tbody>
</table>
<ul>
<li>映射文件的命名规则</li>
<li>表所对应的实体类的类名 + Mapper.xml
<ul>
<li>例如：表 t_user，映射的实体类为 User，所对应的映射文件为 UserMapper.xml</li>
<li>因此一个映射文件对应一个实体类，对应一张表的操作</li>
<li>MyBatis 映射文件用于编写 SQL，访问以及操作表中的数据</li>
<li>MyBatis 映射文件存放的位置是 src/main/resources/mappers 目录下</li>
</ul>
</li>
<li>MyBatis 中可以面向接口操作数据，要保证两个一致</li>
<li>mapper 接口的全类名和映射文件的命名空间（namespace）保持一致
<ul>
<li>mapper 接口中方法的方法名和映射文件中编写 SQL 的标签的 id 属性保持一致</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.UserMapper&quot;</span>&gt;</span>  </span><br><span class="line">	<span class="comment">&lt;!--int insertUser();--&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span>  </span><br><span class="line">		insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;)  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="通过junit测试功能"><a class="markdownIt-Anchor" href="#通过junit测试功能">#</a> 通过 junit 测试功能</h2>
<ul>
<li>SqlSession：代表 Java 程序和数据库之间的会话。（HttpSession 是 Java 程序和浏览器之间的会话）</li>
<li>SqlSessionFactory：是 “生产” SqlSession 的 “工厂”</li>
<li>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个 “工厂类” 中，以后都使用这个工厂类来 “生产” 我们需要的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//读取MyBatis的核心配置文件</span></span><br><span class="line">        InputStream is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取SqlSessionFactoryBuilder对象</span></span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        <span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        <span class="comment">//获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span></span><br><span class="line">        <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession();</span></span><br><span class="line">	    <span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  </span></span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象</span></span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span></span><br><span class="line">        <span class="keyword">int</span> result = userMapper.insertUser();</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        <span class="comment">//sqlSession.commit();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时需要手动提交事务，如果要自动提交事务，则在获取 sqlSession 对象时，使用 <code>SqlSession sqlSession = sqlSessionFactory.openSession(true);</code> ，传入一个 Boolean 类型的参数，值为 true，这样就可以自动提交</li>
</ul>
<h2 id="加入log4j日志功能"><a class="markdownIt-Anchor" href="#加入log4j日志功能">#</a> 加入 log4j 日志功能</h2>
<ol>
<li>
<p>加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>加入 log4j 的配置文件</p>
<ul>
<li>log4j 的配置文件名为 log4j.xml，存放的位置是 src/main/resources 目录下</li>
<li>日志的级别：FATAL (致命)&gt;ERROR (错误)&gt;WARN (警告)&gt;INFO (信息)&gt;DEBUG (调试) 从左到右打印的内容越来越详细</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">log4j</span>:configuration <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="核心配置文件详解"><a class="markdownIt-Anchor" href="#核心配置文件详解">#</a> 核心配置文件详解</h1>
<blockquote>
<p>核心配置文件中的标签必须按照固定的顺序 (有的标签可以不写，但顺序一定不能乱)：<br>
properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        typeAlias：设置某个具体的类型的别名</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        type：需要设置别名的类型的全类名</span></span><br><span class="line"><span class="comment">        alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.bean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：设置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">	    default：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        environment：设置具体的连接数据库的环境信息</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">	        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            transactionManager：设置事务管理方式</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">	            type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">	            type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span></span><br><span class="line"><span class="comment">	            type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            dataSource：设置数据源</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">	            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">	            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment">	            type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span></span><br><span class="line"><span class="comment">	            type=&quot;JNDI&quot;：调用上下文中的数据源</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">        注意：</span></span><br><span class="line"><span class="comment">			1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span></span><br><span class="line"><span class="comment">			2. mapper接口要和mapper映射文件的名字一致</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><img src="/passages/MyBatis/mapper%E6%8E%A5%E5%8F%A3%E5%92%8Cmapper%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%9C%A8%E5%90%8C%E4%B8%80%E5%8C%85%E4%B8%8B.png" alt></li>
</ul>
<h1 id="默认的类型别名"><a class="markdownIt-Anchor" href="#默认的类型别名">#</a> 默认的类型别名</h1>
<p><img src="/passages/MyBatis/%E9%BB%98%E8%AE%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D1.png" alt><br>
<img src="/passages/MyBatis/%E9%BB%98%E8%AE%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D2.png" alt></p>
<h1 id="mybatis的增删改查"><a class="markdownIt-Anchor" href="#mybatis的增删改查">#</a> MyBatis 的增删改查</h1>
<ol>
<li>
<p>添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">	insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteUser();--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">     delete from t_user where id = 6</span><br><span class="line"> <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int updateUser();--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">     update t_user set username = &#x27;张三&#x27; where id = 5</span><br><span class="line"> <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询一个实体类对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span>  </span><br><span class="line">	select * from t_user where id = 2  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询集合</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<p>注意：</p>
<ol>
<li>查询的标签 select 必须设置属性 resultType 或 resultMap，用于设置实体类和数据库表的映射关系
<ul>
<li>resultType：自动映射，用于属性名和表中字段名一致的情况</li>
<li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li>
</ul>
</li>
<li>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常 TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</li>
</ol>
</li>
</ul>
<h1 id="mybatis获取参数值的两种方式重点"><a class="markdownIt-Anchor" href="#mybatis获取参数值的两种方式重点">#</a> MyBatis 获取参数值的两种方式（重点）</h1>
<ul>
<li>MyBatis 获取参数值的两种方式：${} 和 #{}</li>
<li>${} 的本质就是字符串拼接，#{} 的本质就是占位符赋值</li>
<li>${} 使用字符串拼接的方式拼接 sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是 #{} 使用占位符赋值的方式拼接 sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</li>
</ul>
<h2 id="单个字面量类型的参数"><a class="markdownIt-Anchor" href="#单个字面量类型的参数">#</a> 单个字面量类型的参数</h2>
<ul>
<li>若 mapper 接口中的方法参数为单个的字面量类型，此时可以使用 ${} 和 #{} 以任意的名称（最好见名识意）获取参数的值，注意 ${} 需要手动加单引号</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">	select * from t_user where username = &#x27;$&#123;username&#125;&#x27;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="多个字面量类型的参数"><a class="markdownIt-Anchor" href="#多个字面量类型的参数">#</a> 多个字面量类型的参数</h2>
<ul>
<li>
<p>若 mapper 接口中的方法参数为多个时，此时 MyBatis 会自动将这些参数放在一个 map 集合中</p>
<ol>
<li>以 arg0,arg1… 为键，以参数为值；</li>
<li>以 param1,param2… 为键，以参数为值；</li>
</ol>
</li>
<li>
<p>因此只需要通过 ${} 和 #{} 访问 map 集合的键就可以获取相对应的值，注意 ${} 需要手动加单引号。</p>
</li>
<li>
<p>使用 arg 或者 param 都行，要注意的是，arg 是从 arg0 开始的，param 是从 param1 开始的</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">	select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="map集合类型的参数"><a class="markdownIt-Anchor" href="#map集合类型的参数">#</a> map 集合类型的参数</h2>
<ul>
<li>若 mapper 接口中的方法需要的参数为多个时，此时可以手动创建 map 集合，将这些数据放在 map 中只需要通过 ${} 和 #{} 访问 map 集合的键就可以获取相对应的值，注意 ${} 需要手动加单引号</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLoginByMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">	Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	map.put(<span class="string">&quot;usermane&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">	map.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">	User user = mapper.checkLoginByMap(map);</span><br><span class="line">	System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实体类类型的参数"><a class="markdownIt-Anchor" href="#实体类类型的参数">#</a> 实体类类型的参数</h2>
<ul>
<li>若 mapper 接口中的方法参数为实体类对象时此时可以使用 ${} 和 #{}，通过访问实体类对象中的属性名获取属性值，注意 ${} 需要手动加单引号</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">	insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">	User user = <span class="keyword">new</span> User(<span class="keyword">null</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">12</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">	mapper.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用param标识参数"><a class="markdownIt-Anchor" href="#使用param标识参数">#</a> 使用 @Param 标识参数</h2>
<ul>
<li>
<p>可以通过 @Param 注解标识 mapper 接口中的方法参数，此时，会将这些参数放在 map 集合中</p>
<ol>
<li>以 @Param 注解的 value 属性值为键，以参数为值；</li>
<li>以 param1,param2… 为键，以参数为值；</li>
</ol>
</li>
<li>
<p>只需要通过 ${} 和 #{} 访问 map 集合的键就可以获取相对应的值，注意 ${} 需要手动加单引号</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;CheckLoginByParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLoginByParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">	mapper.CheckLoginByParam(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h2>
<ul>
<li>
<p>建议分成两种情况进行处理</p>
<ol>
<li>实体类类型的参数</li>
<li>使用 @Param 标识参数</li>
</ol>
</li>
</ul>
<h1 id="mybatis的各种查询功能"><a class="markdownIt-Anchor" href="#mybatis的各种查询功能">#</a> MyBatis 的各种查询功能</h1>
<ol>
<li>如果查询出的数据只有一条，可以通过
<ol>
<li>实体类对象接收</li>
<li>List 集合接收</li>
<li>Map 集合接收，结果 <code>&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;</code></li>
</ol>
</li>
<li>如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常 TooManyResultsException，可以通过
<ol>
<li>实体类类型的 LIst 集合接收</li>
<li>Map 类型的 LIst 集合接收</li>
<li>在 mapper 接口的方法上添加 @MapKey 注解</li>
</ol>
</li>
</ol>
<h2 id="查询一个实体类对象"><a class="markdownIt-Anchor" href="#查询一个实体类对象">#</a> 查询一个实体类对象</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="查询一个list集合"><a class="markdownIt-Anchor" href="#查询一个list集合">#</a> 查询一个 List 集合</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="查询单个数据"><a class="markdownIt-Anchor" href="#查询单个数据">#</a> 查询单个数据</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 查询用户的总记录数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> * 在MyBatis中，对于Java中常用的类型都设置了类型别名  </span></span><br><span class="line"><span class="comment"> * 例如：java.lang.Integer--&gt;int|integer  </span></span><br><span class="line"><span class="comment"> * 例如：int--&gt;_int|_integer  </span></span><br><span class="line"><span class="comment"> * 例如：Map--&gt;map,List--&gt;list  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int getCount();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;_integer&quot;</span>&gt;</span></span><br><span class="line">	select count(id) from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="查询一条数据为map集合"><a class="markdownIt-Anchor" href="#查询一条数据为map集合">#</a> 查询一条数据为 map 集合</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">getUserToMap</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="查询多条数据为map集合"><a class="markdownIt-Anchor" href="#查询多条数据为map集合">#</a> 查询多条数据为 map 集合</h2>
<h3 id="方法一"><a class="markdownIt-Anchor" href="#方法一">#</a> 方法一</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span>  </span><br><span class="line">	select * from t_user  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	结果：</span></span><br><span class="line"><span class="comment">	[&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">	&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">	&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;]</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="方法二"><a class="markdownIt-Anchor" href="#方法二">#</a> 方法二</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过<span class="doctag">@MapKey</span>注解设置map集合的键，值是每条数据所对应的map集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">getAllUserToMap</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	结果：</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">	2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">	3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="特殊sql的执行"><a class="markdownIt-Anchor" href="#特殊sql的执行">#</a> 特殊 SQL 的执行</h1>
<h2 id="模糊查询"><a class="markdownIt-Anchor" href="#模糊查询">#</a> 模糊查询</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户名进行模糊查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 21:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByLike</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span>  </span><br><span class="line">	<span class="comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span>  </span><br><span class="line">	select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中 <code>select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</code>  是最常用的</li>
</ul>
<h2 id="批量删除"><a class="markdownIt-Anchor" href="#批量删除">#</a> 批量删除</h2>
<ul>
<li>只能使用 ${}，如果使用 #{}，则解析后的 sql 语句为 <code>delete from t_user where id in ('1,2,3')</code> ，这样是将 <code>1,2,3</code>  看做是一个整体，只有 id 为 <code>1,2,3</code>  的数据会被删除。正确的语句应该是 <code>delete from t_user where id in (1,2,3)</code> ，或者 <code>delete from t_user where id in ('1','2','3')</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id批量删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteMore</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> String ids)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">	delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);</span><br><span class="line">	<span class="keyword">int</span> result = mapper.deleteMore(<span class="string">&quot;1,2,3,8&quot;</span>);</span><br><span class="line">	System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态设置表名"><a class="markdownIt-Anchor" href="#动态设置表名">#</a> 动态设置表名</h2>
<ul>
<li>只能使用 ${}，因为表名不能加单引号</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询指定表中的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tableName </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 14:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByTable</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByTable&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from $&#123;tableName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="添加功能获取自增的主键"><a class="markdownIt-Anchor" href="#添加功能获取自增的主键">#</a> 添加功能获取自增的主键</h2>
<ul>
<li>
<p>使用场景</p>
</li>
<li>
<p>t_clazz(clazz_id,clazz_name)</p>
<ul>
<li>t_student(student_id,student_name,clazz_id)</li>
</ul>
<ol>
<li>添加班级信息</li>
<li>获取新添加的班级的 id</li>
<li>为班级分配学生，即将某学的班级 id 修改为新添加的班级的 id</li>
</ol>
</li>
<li>
<p>在 mapper.xml 中设置两个属性</p>
</li>
<li>
<p>useGeneratedKeys：设置使用自增的主键</p>
<ul>
<li>keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数 user 对象的某个属性中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 15:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--void insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">	insert into t_user values (null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);</span><br><span class="line">	User user = <span class="keyword">new</span> User(<span class="keyword">null</span>, <span class="string">&quot;ton&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">	mapper.insertUser(user);</span><br><span class="line">	System.out.println(user);</span><br><span class="line">	<span class="comment">//输出：user&#123;id=10, username=&#x27;ton&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@321.com&#x27;&#125;，自增主键存放到了user的id属性中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义映射resultmap"><a class="markdownIt-Anchor" href="#自定义映射resultmap">#</a> 自定义映射 resultMap</h1>
<h2 id="resultmap处理字段和属性的映射关系"><a class="markdownIt-Anchor" href="#resultmap处理字段和属性的映射关系">#</a> resultMap 处理字段和属性的映射关系</h2>
<ul>
<li>resultMap：设置自定义映射</li>
<li>属性：
<ul>
<li>id：表示自定义映射的唯一标识，不能重复</li>
<li>type：查询的数据要映射的实体类的类型</li>
<li>子标签：</li>
<li>id：设置主键的映射关系
<ul>
<li>result：设置普通字段的映射关系</li>
<li>子标签属性：</li>
<li>property：设置映射关系中实体类中的属性名
<ul>
<li>column：设置映射关系中表中的字段名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>若字段名和实体类中的属性名不一致，则可以通过 resultMap 设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合 Java 的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系</p>
<ol>
<li>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select eid,emp_name empName,age,sex,email from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>可以在 MyBatis 的核心配置文件中的 <code>setting</code>  标签中，设置一个全局配置信息 mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名 user_name，设置了 mapUnderscoreToCamelCase，此时字段名就会转换为 userName。<a href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">核心配置文件详解</a> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="多对一映射处理"><a class="markdownIt-Anchor" href="#多对一映射处理">#</a> 多对一映射处理</h2>
<blockquote>
<p>查询员工信息以及员工所对应的部门信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">private</span> Integer eid;  </span><br><span class="line">	<span class="keyword">private</span> String empName;  </span><br><span class="line">	<span class="keyword">private</span> Integer age;  </span><br><span class="line">	<span class="keyword">private</span> String sex;  </span><br><span class="line">	<span class="keyword">private</span> String email;  </span><br><span class="line">	<span class="keyword">private</span> Dept dept;</span><br><span class="line">	<span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="级联方式处理映射关系"><a class="markdownIt-Anchor" href="#级联方式处理映射关系">#</a> 级联方式处理映射关系</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用association处理映射关系"><a class="markdownIt-Anchor" href="#使用association处理映射关系">#</a> 使用 association 处理映射关系</h3>
<ul>
<li>association：处理多对一的映射关系</li>
<li>property：需要处理多对的映射关系的属性名</li>
<li>javaType：该属性的类型</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="分步查询"><a class="markdownIt-Anchor" href="#分步查询">#</a> 分步查询</h3>
<h4 id="1-查询员工信息"><a class="markdownIt-Anchor" href="#1-查询员工信息">#</a> 1. 查询员工信息</h4>
<ul>
<li>select：设置分布查询的 sql 的唯一标识（namespace.SQLId 或 mapper 接口的全类名。方法名）</li>
<li>column：设置分步查询的条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmpMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Emp <span class="title">getEmpAndDeptByStepOne</span><span class="params">(<span class="meta">@Param(&quot;eid&quot;)</span> Integer eid)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-查询部门信息"><a class="markdownIt-Anchor" href="#2-查询部门信息">#</a> 2. 查询部门信息</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DeptMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：通过did查询员工对应的部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Dept <span class="title">getEmpAndDeptByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepTwo&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="一对多映射处理"><a class="markdownIt-Anchor" href="#一对多映射处理">#</a> 一对多映射处理</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer did;</span><br><span class="line">    <span class="keyword">private</span> String deptName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line">	<span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="collection"><a class="markdownIt-Anchor" href="#collection">#</a> collection</h3>
<ul>
<li>collection：用来处理一对多的映射关系</li>
<li>ofType：表示该属性对饮的集合中存储的数据的类型</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="分步查询-2"><a class="markdownIt-Anchor" href="#分步查询-2">#</a> 分步查询</h3>
<h4 id="1-查询部门信息"><a class="markdownIt-Anchor" href="#1-查询部门信息">#</a> 1. 查询部门信息</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Dept</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Dept <span class="title">getDeptAndEmpByStepOne</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-根据部门id查询部门中的所有员工"><a class="markdownIt-Anchor" href="#2-根据部门id查询部门中的所有员工">#</a> 2. 根据部门 id 查询部门中的所有员工</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：根据部门id查询部门中的所有员工</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;Emp&gt; <span class="title">getDeptAndEmpByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="延迟加载"><a class="markdownIt-Anchor" href="#延迟加载">#</a> 延迟加载</h2>
<ul>
<li>分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：</li>
<li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载
<ul>
<li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载</li>
</ul>
</li>
<li>此时就可以实现按需加载，获取的数据是什么，就只会执行相应的 sql。此时可通过 association 和 collection 中的 fetchType 属性设置当前的分步查询是否使用延迟加载，fetchType=“lazy (延迟加载)|eager (立即加载)”</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmpAndDeptByStepOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	Emp emp = mapper.getEmpAndDeptByStepOne(<span class="number">1</span>);</span><br><span class="line">	System.out.println(emp.getEmpName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭延迟加载，两条 SQL 语句都运行了<img src="/passages/MyBatis/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%951.png" alt></li>
<li>开启延迟加载，只运行获取 emp 的 SQL 语句<br>
<img src="/passages/MyBatis/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%952.png" alt></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmpAndDeptByStepOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	Emp emp = mapper.getEmpAndDeptByStepOne(<span class="number">1</span>);</span><br><span class="line">	System.out.println(emp.getEmpName());</span><br><span class="line">	System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">	System.out.println(emp.getDept());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>开启后，需要用到查询 dept 的时候才会调用相应的 SQL 语句<img src="/passages/MyBatis/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%953.png" alt></p>
</li>
<li>
<p>fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType=“lazy (延迟加载)|eager (立即加载)”</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">column</span>=<span class="string">&quot;did&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="动态sql"><a class="markdownIt-Anchor" href="#动态sql">#</a> 动态 SQL</h1>
<ul>
<li>Mybatis 框架的动态 SQL 技术是一种根据特定条件动态拼装 SQL 语句的功能，它存在的意义是为了解决拼接 SQL 语句字符串时的痛点问题</li>
</ul>
<h2 id="if"><a class="markdownIt-Anchor" href="#if">#</a> if</h2>
<ul>
<li>if 标签可通过 test 属性（即传递过来的数据）的表达式进行判断，若表达式的结果为 true，则标签中的内容会执行；反之标签中的内容不会执行</li>
<li>在 where 后面添加一个恒成立条件 <code>1=1</code></li>
<li>这个恒成立条件并不会影响查询的结果
<ul>
<li>这个 <code>1=1</code>  可以用来拼接 <code>and</code>  语句，例如：当 empName 为 null 时</li>
<li>如果不加上恒成立条件，则 SQL 语句为 <code>select * from t_emp where and age = ? and sex = ? and email = ?</code> ，此时 <code>where</code>  会与 <code>and</code>  连用，SQL 语句会报错
<ul>
<li>如果加上一个恒成立条件，则 SQL 语句为 <code>select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?</code> ，此时不报错</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp where 1=1</span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">		and emp_name = #&#123;empName&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">		and age = #&#123;age&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">		and sex = #&#123;sex&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">		and email = #&#123;email&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="where"><a class="markdownIt-Anchor" href="#where">#</a> where</h2>
<ul>
<li>where 和 if 一般结合使用：</li>
<li>若 where 标签中的 if 条件都不满足，则 where 标签没有任何功能，即不会添加 where 关键字
<ul>
<li>若 where 标签中的 if 条件满足，则 where 标签会自动添加 where 关键字，并将条件最前方多余的 and/or 去掉</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp</span><br><span class="line">	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			emp_name = #&#123;empName&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			and age = #&#123;age&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			and sex = #&#123;sex&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			and email = #&#123;email&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>注意：where 标签不能去掉条件后多余的 and/or</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">	age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="trim"><a class="markdownIt-Anchor" href="#trim">#</a> trim</h2>
<ul>
<li>trim 用于去掉或添加标签中的内容</li>
<li>常用属性</li>
<li>prefix：在 trim 标签中的内容的前面添加某些内容
<ul>
<li>suffix：在 trim 标签中的内容的后面添加某些内容</li>
<li>prefixOverrides：在 trim 标签中的内容的前面去掉某些内容</li>
<li>suffixOverrides：在 trim 标签中的内容的后面去掉某些内容</li>
</ul>
</li>
<li>若 trim 中的标签都不满足条件，则 trim 标签没有任何效果，也就是只剩下 <code>select * from t_emp</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp</span><br><span class="line">	<span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			emp_name = #&#123;empName&#125; and</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			age = #&#123;age&#125; and</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			sex = #&#123;sex&#125; or</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			email = #&#123;email&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmpByCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">	List&lt;Emp&gt; emps= mapper.getEmpByCondition(<span class="keyword">new</span> Emp(<span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">	System.out.println(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/passages/MyBatis/trim%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt></p>
<h2 id="choose-when-otherwise"><a class="markdownIt-Anchor" href="#choose-when-otherwise">#</a> choose、when、otherwise</h2>
<ul>
<li><code>choose、when、otherwise</code>  相当于 <code>if...else if..else</code></li>
<li>when 至少要有一个，otherwise 至多只有一个</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp</span><br><span class="line">	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">				emp_name = #&#123;empName&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">				age = #&#123;age&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">				sex = #&#123;sex&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">				email = #&#123;email&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">				did = 1</span><br><span class="line">			<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmpByChoose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">	List&lt;Emp&gt; emps = mapper.getEmpByChoose(<span class="keyword">new</span> Emp(<span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>, <span class="keyword">null</span>));</span><br><span class="line">	System.out.println(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/passages/MyBatis/choose%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt></p>
<ul>
<li>相当于 <code>if a else if b else if c else d</code> ，只会执行其中一个</li>
</ul>
<h2 id="foreach"><a class="markdownIt-Anchor" href="#foreach">#</a> foreach</h2>
<ul>
<li>
<p>属性：</p>
</li>
<li>
<p>collection：设置要循环的数组或集合</p>
<ul>
<li>item：表示集合或数组中的每一个数据</li>
<li>separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如 <code>,</code></li>
<li>open：设置 foreach 标签中的内容的开始符</li>
<li>close：设置 foreach 标签中的内容的结束符</li>
</ul>
</li>
<li>
<p>批量删除</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(Integer[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">	delete from t_emp where eid in</span><br><span class="line">	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">		#&#123;eid&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMoreByArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">	<span class="keyword">int</span> result = mapper.deleteMoreByArray(<span class="keyword">new</span> Integer[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line">	System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/passages/MyBatis/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png" alt></p>
<ul>
<li>
<p>批量添加</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreByList&quot;</span>&gt;</span></span><br><span class="line">	insert into t_emp values</span><br><span class="line">	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">		(null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertMoreByList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">	Emp emp1 = <span class="keyword">new</span> Emp(<span class="keyword">null</span>,<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">	Emp emp2 = <span class="keyword">new</span> Emp(<span class="keyword">null</span>,<span class="string">&quot;b&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">	Emp emp3 = <span class="keyword">new</span> Emp(<span class="keyword">null</span>,<span class="string">&quot;c&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">	List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);</span><br><span class="line">	<span class="keyword">int</span> result = mapper.insertMoreByList(emps);</span><br><span class="line">	System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/passages/MyBatis/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png" alt></p>
</li>
</ul>
<h2 id="sql片段"><a class="markdownIt-Anchor" href="#sql片段">#</a> SQL 片段</h2>
<ul>
<li>sql 片段，可以记录一段公共 sql 片段，在使用的地方通过 include 标签进行引入</li>
<li>声明 sql 片段： <code>&lt;sql&gt;</code>  标签</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span>eid,emp_name,age,sex,email<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>引用 sql 片段： <code>&lt;include&gt;</code>  标签</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="mybatis的缓存"><a class="markdownIt-Anchor" href="#mybatis的缓存">#</a> MyBatis 的缓存</h1>
<h2 id="mybatis的一级缓存"><a class="markdownIt-Anchor" href="#mybatis的一级缓存">#</a> MyBatis 的一级缓存</h2>
<ul>
<li>
<p>一级缓存是 SqlSession 级别的，通过同一个 SqlSession 查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问</p>
</li>
<li>
<p>使一级缓存失效的四种情况：</p>
<ol>
<li>不同的 SqlSession 对应不同的一级缓存</li>
<li>同一个 SqlSession 但是查询条件不同</li>
<li>同一个 SqlSession 两次查询期间执行了任何一次增删改操作</li>
<li>同一个 SqlSession 两次查询期间手动清空了缓存</li>
</ol>
</li>
</ul>
<h2 id="mybatis的二级缓存"><a class="markdownIt-Anchor" href="#mybatis的二级缓存">#</a> MyBatis 的二级缓存</h2>
<ul>
<li>
<p>二级缓存是 SqlSessionFactory 级别，通过同一个 SqlSessionFactory 创建的 SqlSession 查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p>
</li>
<li>
<p>二级缓存开启的条件</p>
<ol>
<li>在核心配置文件中，设置全局配置属性 cacheEnabled=“true”，默认为 true，不需要设置</li>
<li>在映射文件中设置标签<cache></cache></li>
<li>二级缓存必须在 SqlSession 关闭或提交之后有效</li>
<li>查询的数据所转换的实体类类型必须实现序列化的接口</li>
</ol>
</li>
<li>
<p>使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p>
</li>
</ul>
<h2 id="二级缓存的相关配置"><a class="markdownIt-Anchor" href="#二级缓存的相关配置">#</a> 二级缓存的相关配置</h2>
<ul>
<li>在 mapper 配置文件中添加的 cache 标签可以设置一些属性</li>
<li>eviction 属性：缓存回收策略</li>
<li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。
<ul>
<li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</li>
<li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
<li>默认的是 LRU</li>
</ul>
</li>
<li>flushInterval 属性：刷新间隔，单位毫秒</li>
<li>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新</li>
<li>size 属性：引用数目，正整数</li>
<li>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li>
<li>readOnly 属性：只读，true/false</li>
<li>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。
<ul>
<li>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false</li>
</ul>
</li>
</ul>
<h2 id="mybatis缓存查询的顺序"><a class="markdownIt-Anchor" href="#mybatis缓存查询的顺序">#</a> MyBatis 缓存查询的顺序</h2>
<ul>
<li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用</li>
<li>如果二级缓存没有命中，再查询一级缓存</li>
<li>如果一级缓存也没有命中，则查询数据库</li>
<li>SqlSession 关闭之后，一级缓存中的数据会写入二级缓存</li>
</ul>
<h2 id="整合第三方缓存ehcache了解"><a class="markdownIt-Anchor" href="#整合第三方缓存ehcache了解">#</a> 整合第三方缓存 EHCache（了解）</h2>
<h3 id="添加依赖"><a class="markdownIt-Anchor" href="#添加依赖">#</a> 添加依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mybatis EHCache整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="各个jar包的功能"><a class="markdownIt-Anchor" href="#各个jar包的功能">#</a> 各个 jar 包的功能</h3>
<table>
<thead>
<tr>
<th>jar 包名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>mybatis-ehcache</td>
<td>Mybatis 和 EHCache 的整合包</td>
</tr>
<tr>
<td>ehcache</td>
<td>EHCache 核心包</td>
</tr>
<tr>
<td>slf4j-api</td>
<td>SLF4J 日志门面包</td>
</tr>
<tr>
<td>logback-classic</td>
<td>支持 SLF4J 门面接口的一个具体实现</td>
</tr>
</tbody>
</table>
<h3 id="创建ehcache的配置文件ehcachexml"><a class="markdownIt-Anchor" href="#创建ehcache的配置文件ehcachexml">#</a> 创建 EHCache 的配置文件 ehcache.xml</h3>
<ul>
<li>名字必须叫 <code>ehcache.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\atguigu\ehcache&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="设置二级缓存的类型"><a class="markdownIt-Anchor" href="#设置二级缓存的类型">#</a> 设置二级缓存的类型</h3>
<ul>
<li>在 xxxMapper.xml 文件中设置二级缓存类型</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="加入logback日志"><a class="markdownIt-Anchor" href="#加入logback日志">#</a> 加入 logback 日志</h3>
<ul>
<li>存在 SLF4J 时，作为简易日志的 log4j 将失效，此时我们需要借助 SLF4J 的具体实现 logback 来打印日志。创建 logback 的配置文件 <code>logback.xml</code> ，名字固定，不可改变</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定日志输出的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.crowd.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="ehcache配置文件说明"><a class="markdownIt-Anchor" href="#ehcache配置文件说明">#</a> EHCache 配置文件说明</h3>
<table>
<thead>
<tr>
<th>属性名</th>
<th>是否必须</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>maxElementsInMemory</td>
<td>是</td>
<td>在内存中缓存的 element 的最大数目</td>
</tr>
<tr>
<td>maxElementsOnDisk</td>
<td>是</td>
<td>在磁盘上缓存的 element 的最大数目，若是 0 表示无穷大</td>
</tr>
<tr>
<td>eternal</td>
<td>是</td>
<td>设定缓存的 elements 是否永远不过期。 如果为 true，则缓存的数据始终有效， 如果为 false 那么还要根据 timeToIdleSeconds、timeToLiveSeconds 判断</td>
</tr>
<tr>
<td>overflowToDisk</td>
<td>是</td>
<td>设定当内存缓存溢出的时候是否将过期的 element 缓存到磁盘上</td>
</tr>
<tr>
<td>timeToIdleSeconds</td>
<td>否</td>
<td>当缓存在 EhCache 中的数据前后两次访问的时间超过 timeToIdleSeconds 的属性取值时， 这些数据便会删除，默认值是 0, 也就是可闲置时间无穷大</td>
</tr>
<tr>
<td>timeToLiveSeconds</td>
<td>否</td>
<td>缓存 element 的有效生命期，默认是 0., 也就是 element 存活时间无穷大</td>
</tr>
<tr>
<td>diskSpoolBufferSizeMB</td>
<td>否</td>
<td>DiskStore (磁盘缓存) 的缓存区大小。默认是 30MB。每个 Cache 都应该有自己的一个缓冲区</td>
</tr>
<tr>
<td>diskPersistent</td>
<td>否</td>
<td>在 VM 重启的时候是否启用磁盘保存 EhCache 中的数据，默认是 false</td>
</tr>
<tr>
<td>diskExpiryThreadIntervalSeconds</td>
<td>否</td>
<td>磁盘缓存的清理线程运行间隔，默认是 120 秒。每个 120s， 相应的线程会进行一次 EhCache 中数据的清理工作</td>
</tr>
<tr>
<td>memoryStoreEvictionPolicy</td>
<td>否</td>
<td>当内存缓存达到最大，有新的 element 加入的时候， 移除缓存中 element 的策略。 默认是 LRU（最近最少使用），可选的有 LFU（最不常使用）和 FIFO（先进先出</td>
</tr>
</tbody>
</table>
<h1 id="mybatis的逆向工程"><a class="markdownIt-Anchor" href="#mybatis的逆向工程">#</a> MyBatis 的逆向工程</h1>
<ul>
<li>正向工程：先创建 Java 实体类，由框架负责根据实体类生成数据库表。Hibernate 是支持正向工程的</li>
<li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：</li>
<li>Java 实体类
<ul>
<li>Mapper 接口</li>
<li>Mapper 映射文件</li>
</ul>
</li>
</ul>
<h2 id="创建逆向工程的步骤"><a class="markdownIt-Anchor" href="#创建逆向工程的步骤">#</a> 创建逆向工程的步骤</h2>
<h3 id="添加依赖和插件"><a class="markdownIt-Anchor" href="#添加依赖和插件">#</a> 添加依赖和插件</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- MyBatis核心依赖包 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建mybatis的核心配置文件-2"><a class="markdownIt-Anchor" href="#创建mybatis的核心配置文件-2">#</a> 创建 MyBatis 的核心配置文件</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建逆向工程的配置文件"><a class="markdownIt-Anchor" href="#创建逆向工程的配置文件">#</a> 创建逆向工程的配置文件</h3>
<ul>
<li>文件名必须是： <code>generatorConfig.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">    MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">    MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库的连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- javaBean的生成策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.pojo&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_emp&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Emp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Dept&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="执行mbg插件的generate目标"><a class="markdownIt-Anchor" href="#执行mbg插件的generate目标">#</a> 执行 MBG 插件的 generate 目标</h3>
<ul>
<li><img src="/passages/MyBatis/%E6%89%A7%E8%A1%8CMBG%E6%8F%92%E4%BB%B6%E7%9A%84generate%E7%9B%AE%E6%A0%87.png" alt></li>
<li>如果出现报错： <code>Exception getting JDBC Driver</code> ，可能是 pom.xml 中，数据库驱动配置错误</li>
<li>dependency 中的驱动<img src="/passages/MyBatis/dependency%E4%B8%AD%E7%9A%84%E9%A9%B1%E5%8A%A8.png" alt>
<ul>
<li>mybatis-generator-maven-plugin 插件中的驱动<img src="/passages/MyBatis/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%A9%B1%E5%8A%A8.png" alt></li>
<li>两者的驱动版本应该相同</li>
</ul>
</li>
<li>执行结果<img src="/passages/MyBatis/%E9%80%86%E5%90%91%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt></li>
</ul>
<h2 id="qbc"><a class="markdownIt-Anchor" href="#qbc">#</a> QBC</h2>
<h3 id="查询"><a class="markdownIt-Anchor" href="#查询">#</a> 查询</h3>
<ul>
<li><code>selectByExample</code> ：按条件查询，需要传入一个 example 对象或者 null；如果传入一个 null，则表示没有条件，也就是查询所有数据</li>
<li><code>example.createCriteria().xxx</code> ：创建条件对象，通过 andXXX 方法为 SQL 添加查询添加，每个条件之间是 and 关系</li>
<li><code>example.or().xxx</code> ：将之前添加的条件通过 or 拼接其他条件<br>
<img src="/passages/MyBatis/example%E7%9A%84%E6%96%B9%E6%B3%95.png" alt></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMBG</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	InputStream is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	EmpExample example = <span class="keyword">new</span> EmpExample();</span><br><span class="line">	<span class="comment">//名字为张三，且年龄大于等于20</span></span><br><span class="line">	example.createCriteria().andEmpNameEqualTo(<span class="string">&quot;张三&quot;</span>).andAgeGreaterThanOrEqualTo(<span class="number">20</span>);</span><br><span class="line">	<span class="comment">//或者did不为空</span></span><br><span class="line">	example.or().andDidIsNotNull();</span><br><span class="line">	List&lt;Emp&gt; emps = mapper.selectByExample(example);</span><br><span class="line">	emps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/passages/MyBatis/example%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt></p>
<h3 id="增改"><a class="markdownIt-Anchor" href="#增改">#</a> 增改</h3>
<ul>
<li><code>updateByPrimaryKey</code> ：通过主键进行数据修改，如果某一个值为 null，也会将对应的字段改为 null</li>
<li><code>mapper.updateByPrimaryKey(new Emp(1,&quot;admin&quot;,22,null,&quot;456@qq.com&quot;,3));</code>
<ul>
<li><img src="/passages/MyBatis/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png" alt></li>
</ul>
</li>
<li><code>updateByPrimaryKeySelective()</code> ：通过主键进行选择性数据修改，如果某个值为 null，则不修改这个字段</li>
<li><code>mapper.updateByPrimaryKeySelective(new Emp(2,&quot;admin2&quot;,22,null,&quot;456@qq.com&quot;,3));</code>
<ul>
<li><img src="/passages/MyBatis/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png" alt></li>
</ul>
</li>
</ul>
<h1 id="分页插件"><a class="markdownIt-Anchor" href="#分页插件">#</a> 分页插件</h1>
<h2 id="分页插件使用步骤"><a class="markdownIt-Anchor" href="#分页插件使用步骤">#</a> 分页插件使用步骤</h2>
<h3 id="添加依赖-2"><a class="markdownIt-Anchor" href="#添加依赖-2">#</a> 添加依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置分页插件"><a class="markdownIt-Anchor" href="#配置分页插件">#</a> 配置分页插件</h3>
<ul>
<li>在 MyBatis 的核心配置文件（mybatis-config.xml）中配置插件</li>
<li><img src="/passages/MyBatis/%E9%85%8D%E7%BD%AE%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6.png" alt></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--设置分页插件--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="分页插件的使用"><a class="markdownIt-Anchor" href="#分页插件的使用">#</a> 分页插件的使用</h2>
<h3 id="开启分页功能"><a class="markdownIt-Anchor" href="#开启分页功能">#</a> 开启分页功能</h3>
<ul>
<li>在查询功能之前使用 <code>PageHelper.startPage(int pageNum, int pageSize)</code>  开启分页功能</li>
<li>pageNum：当前页的页码
<ul>
<li>pageSize：每页显示的条数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	InputStream is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	<span class="comment">//访问第一页，每页四条数据</span></span><br><span class="line">	PageHelper.startPage(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">	List&lt;Emp&gt; emps = mapper.selectByExample(<span class="keyword">null</span>);</span><br><span class="line">	emps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/passages/MyBatis/%E5%88%86%E9%A1%B5%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt></p>
<h3 id="分页相关数据"><a class="markdownIt-Anchor" href="#分页相关数据">#</a> 分页相关数据</h3>
<h4 id="方法一直接输出"><a class="markdownIt-Anchor" href="#方法一直接输出">#</a> 方法一：直接输出</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	InputStream is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	<span class="comment">//访问第一页，每页四条数据</span></span><br><span class="line">	Page&lt;Object&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">	List&lt;Emp&gt; emps = mapper.selectByExample(<span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">//在查询到List集合后，打印分页数据</span></span><br><span class="line">	System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>分页相关数据：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="方法二使用pageinfo"><a class="markdownIt-Anchor" href="#方法二使用pageinfo">#</a> 方法二使用 PageInfo</h4>
<ul>
<li>在查询获取 list 集合之后，使用 <code>PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, intnavigatePages)</code>  获取分页相关数据</li>
<li>list：分页之后的数据
<ul>
<li>navigatePages：导航分页的页码数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	InputStream is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">	List&lt;Emp&gt; emps = mapper.selectByExample(<span class="keyword">null</span>);</span><br><span class="line">	PageInfo&lt;Emp&gt; page = <span class="keyword">new</span> PageInfo&lt;&gt;(emps,<span class="number">5</span>);</span><br><span class="line">	System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>分页相关数据：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PageInfo&#123;</span><br><span class="line">pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, </span><br><span class="line">list=Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;], </span><br><span class="line">prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其中 list 中的数据等同于方法一中直接输出的 page 数据</p>
</li>
</ul>
<h4 id="常用数据"><a class="markdownIt-Anchor" href="#常用数据">#</a> 常用数据：</h4>
<ul>
<li>pageNum：当前页的页码</li>
<li>pageSize：每页显示的条数</li>
<li>size：当前页显示的真实条数</li>
<li>total：总记录数</li>
<li>pages：总页数</li>
<li>prePage：上一页的页码</li>
<li>nextPage：下一页的页码</li>
<li>isFirstPage/isLastPage：是否为第一页 / 最后一页</li>
<li>hasPreviousPage/hasNextPage：是否存在上一页 / 下一页</li>
<li>navigatePages：导航分页的页码数</li>
<li>navigatepageNums：导航分页的页码，[1,2,3,4,5]</li>
</ul>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql基础篇</title>
    <url>/passages/MySql%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="一-sql"><a class="markdownIt-Anchor" href="#一-sql">#</a> 一、SQL</h1>
<blockquote>
<p>全称  <code>Structured Query Language</code> ，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一<strong>标准</strong> 。</p>
</blockquote>
<h2 id="1sql通用语法"><a class="markdownIt-Anchor" href="#1sql通用语法">#</a> 1.SQL 通用语法</h2>
<blockquote>
<p>在学习具体的 SQL 语句之前，先来了解一下 SQL 语言的同于语法。</p>
</blockquote>
<ol>
<li>SQL 语句可以单行或多行书写，以分号结尾。</li>
<li>SQL 语句可以使用空格 / 缩进来增强语句的可读性。</li>
<li>MySQL 数据库的 SQL 语句<strong>不区分大小写</strong>，关键字建议使用大写。</li>
<li>注释：
<ul>
<li>单行注释： <code>--</code>  注释内容 或  <code># </code> 注释内容</li>
<li>多行注释： <code>/* 注释内容 */</code></li>
</ul>
</li>
</ol>
<h2 id="2sql分类"><a class="markdownIt-Anchor" href="#2sql分类">#</a> 2.SQL 分类</h2>
<blockquote>
<p><strong>SQL 语句，根据其功能，主要分为四类： <code>DDL</code> 、 <code>DML</code> 、 <code>DQL</code> 、 <code>DCL</code> 。</strong></p>
<p><strong>但是作为 <code>Java开发</code> 的程序员我们仅需掌握 <code>DML</code>  及 <code>DQL</code>  即可。</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">全称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>DDL</strong></td>
<td style="text-align:left">Data Definition Language</td>
<td style="text-align:left">数据定义语言，用来定义数据库对象（<strong>数据库、表、字段</strong>）</td>
</tr>
<tr>
<td style="text-align:left"><strong>DML</strong></td>
<td style="text-align:left">Data Manipulation Language</td>
<td style="text-align:left">数据操作语言，用来对数据库表中的数据进行<strong>增删改</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>DQL</strong></td>
<td style="text-align:left">Data Query Language</td>
<td style="text-align:left">数据查询语言，用来<strong>查询数据库中表的记录</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>DCL</strong></td>
<td style="text-align:left">Data Control Language</td>
<td style="text-align:left">数据控制语言，用来<strong>创建数据库用户</strong>、控制数据库的控制权限</td>
</tr>
</tbody>
</table>
<h2 id="3ddl"><a class="markdownIt-Anchor" href="#3ddl">#</a> 3.DDL</h2>
<blockquote>
<p><strong> <code>Data Definition Language</code> ，数据定义语言，用来定义数据库对象 (数据库，表，字段) 。</strong></p>
</blockquote>
<h3 id="31-操作数据库的命令"><a class="markdownIt-Anchor" href="#31-操作数据库的命令">#</a> 3.1 操作数据库的命令</h3>
<blockquote>
<p>下面演示的命令中出现的中括号表示为可选命令（加粗字体为常用命令）</p>
</blockquote>
<ol>
<li>
<p>查询所有数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询当前数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>创建数据库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</span><br><span class="line">CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</span><br><span class="line">SQL</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>删除数据库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE [ IF EXISTS ] 数据库名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="32-操作表的命令"><a class="markdownIt-Anchor" href="#32-操作表的命令">#</a> 3.2 操作表的命令</h3>
<blockquote>
<p>下面演示的命令中出现的中括号表示为可选命令（加粗字体为常用命令）</p>
</blockquote>
<ol>
<li>
<p>查询当前数据库所有表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>查询表结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC 表名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>查询指定表的建表语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>创建表（注意：最后一个字段后面没有逗号）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名 (</span><br><span class="line">字段名1 类型(宽度) 约束条件 [COMMENT 字段1注释],</span><br><span class="line">字段名2 类型(宽度) 约束条件 [COMMENT 字段2注释],</span><br><span class="line">字段名3 类型(宽度) 约束条件 [COMMENT 字段3注释]</span><br><span class="line">) [ COMMENT 表注释 ];</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改字段名和字段类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改表名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>删除表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#将整张表彻底删掉</span><br><span class="line">DROP TABLE [IF EXISTS] 表名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#以该方式删除的表相当于仅删除表中的数据，但是表结构保留</span><br><span class="line">TRUNCATE TABLE 表名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>Ps：实际开发中表的结构在创建时就已经确定了，后期基本上不会出现更改或者添加字段的情况，因此关于操作字段的命令可以不用死记。</strong></p>
<h3 id="33-字段的数据类型"><a class="markdownIt-Anchor" href="#33-字段的数据类型">#</a> 3.3 字段的数据类型</h3>
<h4 id="a-整型"><a class="markdownIt-Anchor" href="#a-整型">#</a> a） 整型</h4>
<table>
<thead>
<tr>
<th style="text-align:left">MySQL 数据类型</th>
<th style="text-align:left">含义（有符号）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">tinyint</td>
<td style="text-align:left">1 字节，范围（-128~127）</td>
</tr>
<tr>
<td style="text-align:left">smallint</td>
<td style="text-align:left">2 字节，范围（-32768~32767）</td>
</tr>
<tr>
<td style="text-align:left">mediumint</td>
<td style="text-align:left">3 字节，范围（-8388608~8388607）</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">4 字节，范围（-2147483648~2147483647）</td>
</tr>
<tr>
<td style="text-align:left">bigint</td>
<td style="text-align:left">8 字节，范围（±9.22*10 的 18 次方）</td>
</tr>
</tbody>
</table>
<p>整型默认使用的都是有符号的，当然了，我们也可以加上 <code>unsigned</code>  关键字，定义成无符号的类型，那么对应的取值范围就会发生改变。</p>
<p>比如： <code>tinyint unsigned</code>  的取值范围为 <code>0~255</code> ，</p>
<h4 id="b-浮点型"><a class="markdownIt-Anchor" href="#b-浮点型">#</a> b） 浮点型</h4>
<table>
<thead>
<tr>
<th style="text-align:left">MySQL 数据类型</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">float(m, d)</td>
<td style="text-align:left">4 字节，单精度浮点型，m 总长度，d 小数位</td>
</tr>
<tr>
<td style="text-align:left">double(m, d)</td>
<td style="text-align:left">8 字节，双精度浮点型，m 总长度，d 小数位</td>
</tr>
<tr>
<td style="text-align:left">decimal(m, d)</td>
<td style="text-align:left">decimal 是存储为字符串的浮点数，对应我们 java 的 Bigdecimal</td>
</tr>
</tbody>
</table>
<p>我们使用一个例子来判断小括号内参数的含义，针对数据类型为 <code>float(5, 3)</code>  的列，做了以下试验：</p>
<ul>
<li>插入 <code>123.45678</code> ，最后查询得到的结果为 <code>99.999</code> ；</li>
<li>插入 <code>12.34567</code> ，最后查询结果为 <code>12.346</code> ；</li>
</ul>
<p>所以，在使用浮点型的时候，还是要注意陷阱的，要以插入数据库中的实际结果为准。</p>
<h4 id="c-字符串"><a class="markdownIt-Anchor" href="#c-字符串">#</a> c） 字符串</h4>
<table>
<thead>
<tr>
<th style="text-align:left">MySQL 数据类型</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char(n)</td>
<td style="text-align:left">固定长度，最多 255 个字符</td>
</tr>
<tr>
<td style="text-align:left">varchar(n)</td>
<td style="text-align:left">可变长度，最大容量 65535 个字节</td>
</tr>
<tr>
<td style="text-align:left">tinytext</td>
<td style="text-align:left">可变长度，最大容量 255 个字节</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td style="text-align:left">可变长度，最大容量 65535 个字节</td>
</tr>
<tr>
<td style="text-align:left">mediumtext</td>
<td style="text-align:left">可变长度，最大容量 2 的 24 次方 - 1 个字节 16MB</td>
</tr>
<tr>
<td style="text-align:left">longtext</td>
<td style="text-align:left">可变长度，最大容量 2 的 32 次方 - 1 个字节 4GB</td>
</tr>
</tbody>
</table>
<h4 id="d-日期和时间"><a class="markdownIt-Anchor" href="#d-日期和时间">#</a> d） 日期和时间</h4>
<table>
<thead>
<tr>
<th style="text-align:left">MySQL 数据类型</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>date</strong></td>
<td style="text-align:left">3 字节，日期，格式：2022-09-18</td>
</tr>
<tr>
<td style="text-align:left"><strong>time</strong></td>
<td style="text-align:left">3 字节，时间，格式：08:42:30</td>
</tr>
<tr>
<td style="text-align:left"><strong>datetime</strong></td>
<td style="text-align:left">8 字节，日期时间，格式：2022-09-18 08:42:30</td>
</tr>
<tr>
<td style="text-align:left">timestamp</td>
<td style="text-align:left">4 字节，自动存储记录修改的时间</td>
</tr>
<tr>
<td style="text-align:left">year</td>
<td style="text-align:left">1 字节，年份，格式：2020</td>
</tr>
</tbody>
</table>
<h2 id="4dml常用"><a class="markdownIt-Anchor" href="#4dml常用">#</a> 4.DML（常用）</h2>
<blockquote>
<p><strong>DML 英文全称是 Data Manipulation Language (数据操作语言)，用来对数据库中表的数据记录进行 <code>增、删、改</code> 操作。</strong></p>
</blockquote>
<ul>
<li>添加数据（ <code>INSERT</code> ）</li>
<li>修改数据（ <code>UPDATE</code> ）</li>
<li>删除数据（ <code>DELETE</code> ）</li>
</ul>
<h3 id="41-添加数据"><a class="markdownIt-Anchor" href="#41-添加数据">#</a> 4.1 添加数据</h3>
<ol>
<li>
<p>添加指定字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加全部字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>批量添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...),(值1, 值2, ...), (值1, 值2, ...);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意事项</p>
<ul>
<li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li>
<li>字符串和日期类型数据应该包含在引号中</li>
<li>插入的数据大小应该在字段的规定范围内</li>
</ul>
<h3 id="42-修改和删除数据"><a class="markdownIt-Anchor" href="#42-修改和删除数据">#</a> 4.2 修改和删除数据</h3>
<ol>
<li>
<p>修改符合条件的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除复合条件的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM 表名 [ WHERE 条件 ];</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意：如果不加 <code>WHERE</code>  条件则默认操作整张表的数据</strong></p>
<h2 id="5dql常用"><a class="markdownIt-Anchor" href="#5dql常用">#</a> 5.DQL（常用）</h2>
<blockquote>
<p><strong> <code>DQL</code>  英文全称是 <code>Data Query Language</code>  (数据查询语言)，数据查询语言，用来查询数据库中表的记录。</strong></p>
</blockquote>
<p>小提示：</p>
<ul>
<li>查询关键字:  <code>SELECT</code></li>
<li><code>DQL</code>  是我们每天接触编写最多也是最难的 SQL，该语言用来查询记录，不会修改数据库和表结构。</li>
<li>实际开发中<strong>查询操作</strong>的频次是要远高于<strong>增删改</strong>的。</li>
<li>查询可以当作一个很大的章节，其中包含<strong>单表查询、多表查询、分组查询</strong>等等。</li>
</ul>
<h3 id="51-课前准备"><a class="markdownIt-Anchor" href="#51-课前准备">#</a> 5.1 课前准备</h3>
<blockquote>
<p><strong>在学习查询语句前我们需要用到一个图形化工具来操作数据库，这会使我们的学习效率及开发效率大大的提高。</strong></p>
</blockquote>
<ul>
<li>
<p>图形化界面工具（根据个人喜好选择）：<a href="https://lanzoux.com/iHtYJ05vitze">Navicat15</a></p>
</li>
<li>
<p>在开始学习之前我们需要执行以下 SQL 语句作为我们的学习素材：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS itcast DEFAULT CHARSET utf8mb4;</span><br><span class="line">DROP TABLE IF EXISTS employee;</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">	id int COMMENT &#x27;编号&#x27;,</span><br><span class="line">	workno varchar(10) COMMENT &#x27;工号&#x27;,</span><br><span class="line">	name varchar(10) COMMENT &#x27;姓名&#x27;,</span><br><span class="line">	gender char(1) COMMENT &#x27;性别&#x27;,</span><br><span class="line">	age tinyint UNSIGNED COMMENT &#x27;年龄&#x27;,</span><br><span class="line">	idcard char(18) COMMENT &#x27;身份证号&#x27;,</span><br><span class="line">	workaddress varchar(50) COMMENT &#x27;工作地址&#x27;,</span><br><span class="line">	entrydate date COMMENT &#x27;入职时间&#x27;</span><br><span class="line">) COMMENT &#x27;员工表&#x27;;</span><br><span class="line"></span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (1, &#x27;00001&#x27;, &#x27;柳岩666&#x27;, &#x27;女&#x27;, 20, &#x27;123456789012345678&#x27;, &#x27;北京&#x27;, &#x27;2000-01-01&#x27;);</span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (2, &#x27;00002&#x27;, &#x27;张无忌&#x27;, &#x27;男&#x27;, 18, &#x27;123456789012345670&#x27;, &#x27;北京&#x27;, &#x27;2005-09-01&#x27;);</span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (3, &#x27;00003&#x27;, &#x27;韦一笑&#x27;, &#x27;男&#x27;, 38, &#x27;123456789712345670&#x27;, &#x27;上海&#x27;, &#x27;2005-08-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (4, &#x27;00004&#x27;, &#x27;赵敏&#x27;, &#x27;女&#x27;, 18, &#x27;123456757123845670&#x27;, &#x27;北京&#x27;, &#x27;2009-12-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (5, &#x27;00005&#x27;, &#x27;小昭&#x27;, &#x27;女&#x27;, 16, &#x27;123456769012345678&#x27;, &#x27;上海&#x27;, &#x27;2007-07-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (6, &#x27;00006&#x27;, &#x27;杨逍&#x27;, &#x27;男&#x27;, 28, &#x27;12345678931234567X&#x27;, &#x27;北京&#x27;, &#x27;2006-01-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (7, &#x27;00007&#x27;, &#x27;范瑶&#x27;, &#x27;男&#x27;, 40, &#x27;123456789212345670&#x27;, &#x27;北京&#x27;, &#x27;2005-05-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (8, &#x27;00008&#x27;, &#x27;黛绮丝&#x27;, &#x27;女&#x27;, 38, &#x27;123456157123645670&#x27;, &#x27;天津&#x27;, &#x27;2015-05-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (9, &#x27;00009&#x27;, &#x27;范凉凉&#x27;, &#x27;女&#x27;, 45, &#x27;123156789012345678&#x27;, &#x27;北京&#x27;, &#x27;2010-04-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (10, &#x27;00010&#x27;, &#x27;陈友谅&#x27;, &#x27;男&#x27;, 53, &#x27;123456789012345670&#x27;, &#x27;上海&#x27;, &#x27;2011-01-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (11, &#x27;00011&#x27;, &#x27;张士诚&#x27;, &#x27;男&#x27;, 55, &#x27;123567897123465670&#x27;, &#x27;江苏&#x27;, &#x27;2015-05-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (12, &#x27;00012&#x27;, &#x27;常遇春&#x27;, &#x27;男&#x27;, 32, &#x27;123446757152345670&#x27;, &#x27;北京&#x27;, &#x27;2004-02-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (13, &#x27;00013&#x27;, &#x27;张三丰&#x27;, &#x27;男&#x27;, 88, &#x27;123656789012345678&#x27;, &#x27;江苏&#x27;, &#x27;2020-11-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (14, &#x27;00014&#x27;, &#x27;灭绝&#x27;, &#x27;女&#x27;, 65, &#x27;123456719012345670&#x27;, &#x27;西安&#x27;, &#x27;2019-05-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (15, &#x27;00015&#x27;, &#x27;胡青牛&#x27;, &#x27;男&#x27;, 70, &#x27;12345674971234567X&#x27;, &#x27;西安&#x27;, &#x27;2018-04-01&#x27;); </span><br><span class="line">INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (16, &#x27;00016&#x27;, &#x27;周芷若&#x27;, &#x27;女&#x27;, 18, null, &#x27;北京&#x27;, &#x27;2012-06-01&#x27;);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="52-基本语法"><a class="markdownIt-Anchor" href="#52-基本语法">#</a> 5.2 基本语法</h3>
<ul>
<li>
<p>DQL 查询语句，语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    字段列表</span><br><span class="line">FROM</span><br><span class="line">    表名字段</span><br><span class="line">WHERE</span><br><span class="line">    条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">    分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">    分组后的条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">    排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">    分页参数</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>我们在学习的时候，会将上面的完整语法进行拆分，分为以下几个部分：</p>
<ul>
<li>基础查询（不带任何条件）</li>
<li>条件查询（ <code>WHERE</code> ）</li>
<li>聚合函数（ <code>count</code> 、 <code>max</code> 、 <code>min</code> 、 <code>avg</code> 、 <code>sum</code> ）</li>
<li>分组查询（ <code>group by</code> ）</li>
<li>排序查询（ <code>order by</code> ）</li>
<li>分页查询（ <code>limit</code> ）</li>
</ul>
</li>
</ul>
<h3 id="53-基础查询"><a class="markdownIt-Anchor" href="#53-基础查询">#</a> 5.3 基础查询</h3>
<h4 id="a语法格式"><a class="markdownIt-Anchor" href="#a语法格式">#</a> a）语法格式</h4>
<ul>
<li>
<p>查询多个字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<p><strong>注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。</strong></p>
</li>
<li>
<p>字段设置别名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>去除重复记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="b案例练习"><a class="markdownIt-Anchor" href="#b案例练习">#</a> b）案例练习</h4>
<ul>
<li>
<p>查询指定字段  <code>name</code> ,  <code>workno</code> ,  <code>age</code>  并返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,workno,age from emp;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询返回所有字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id, workno, name, gender, age, idcard, workaddress, entrydate from emp;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp; #不推荐</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询所有员工的工作地址，起别名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select workaddress AS &#x27;工作地址&#x27; from emp;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select workaddress &#x27;工作地址&#x27; from emp; #省略AS的写法</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询公司员工的上班地址有哪些（不要重复）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select DISTINCT workaddress from emp;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="54-条件查询"><a class="markdownIt-Anchor" href="#54-条件查询">#</a> 5.4 条件查询</h3>
<h4 id="a语法格式-2"><a class="markdownIt-Anchor" href="#a语法格式-2">#</a> a）语法格式</h4>
<ul>
<li>
<p>查询语句中使用 <code>WHERE</code>  条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表 ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="b条件运算符"><a class="markdownIt-Anchor" href="#b条件运算符">#</a> b）条件运算符</h4>
<ul>
<li>
<p>常用的比较运算符</p>
<table>
<thead>
<tr>
<th style="text-align:left">比较运算符</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt; 或！=</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">BETWEEN … AND …</td>
<td style="text-align:left">在某个范围内（含最小、最大值）</td>
</tr>
<tr>
<td style="text-align:left">IN(…)</td>
<td style="text-align:left">在 in 之后的列表中的值，多选一</td>
</tr>
<tr>
<td style="text-align:left">LIKE 占位符</td>
<td style="text-align:left">模糊匹配（ <code>_</code> 匹配单个字符， <code>%</code>  匹配任意个字符）</td>
</tr>
<tr>
<td style="text-align:left">IS NULL</td>
<td style="text-align:left">是 NULL</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>常用的逻辑运算符</p>
<table>
<thead>
<tr>
<th style="text-align:left">逻辑运算符</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AND 或 &amp;&amp;</td>
<td style="text-align:left">并且（多个条件同时成立）</td>
</tr>
<tr>
<td style="text-align:left">OR 或 ||</td>
<td style="text-align:left">或者（多个条件任意一个成立）</td>
</tr>
<tr>
<td style="text-align:left">NOT 或！</td>
<td style="text-align:left">非，不是</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="c案例练习"><a class="markdownIt-Anchor" href="#c案例练习">#</a> c）案例练习</h4>
<ul>
<li>
<p>查询年龄等于 88 的员工</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where age = 88;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询年龄小于 20 的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where age &lt; 20;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询年龄小于等于 20 的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where age &lt;= 20;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询没有身份证号的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where idcard is null;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询有身份证号的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where idcard is not null;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询年龄不等于 88 的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where age != 88;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where age &lt;&gt; 88;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询年龄在 15 岁（包含）到 20 岁（包含）之间的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where age &gt;= 15 &amp;&amp; age &lt;= 20;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where age &gt;= 15 and age &lt;= 20;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where age BETWEEN 15 AND 20;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询性别为 女 且年龄小于 25 岁的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where gender = &#x27;女&#x27; and age &lt; 25;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询年龄等于 18 或 20 或 40 的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where age = 18 or age = 20 or age = 40;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where age in(18,20,40);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询姓名为两个字的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where name like &#x27;__&#x27;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询身份证号最后一位是 X 的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where idcard like &#x27;%X&#x27;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="55-聚合函数"><a class="markdownIt-Anchor" href="#55-聚合函数">#</a> 5.5 聚合函数</h3>
<blockquote>
<p><strong>将一列数据作为一个整体，进行纵向计算。</strong></p>
</blockquote>
<h4 id="a常见的聚合函数"><a class="markdownIt-Anchor" href="#a常见的聚合函数">#</a> a）常见的聚合函数</h4>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">count</td>
<td style="text-align:left">统计数量</td>
</tr>
<tr>
<td style="text-align:left">max</td>
<td style="text-align:left">最大值</td>
</tr>
<tr>
<td style="text-align:left">min</td>
<td style="text-align:left">最小值</td>
</tr>
<tr>
<td style="text-align:left">avg</td>
<td style="text-align:left">平均值</td>
</tr>
<tr>
<td style="text-align:left">sum</td>
<td style="text-align:left">求和</td>
</tr>
</tbody>
</table>
<h4 id="b语法格式"><a class="markdownIt-Anchor" href="#b语法格式">#</a> b）语法格式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 聚合函数(字段列表) FROM 表名 ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<p><strong>注意 : NULL 值是不参与所有聚合函数运算的。</strong></p>
<h4 id="c案例练习-2"><a class="markdownIt-Anchor" href="#c案例练习-2">#</a> c）案例练习</h4>
<ul>
<li>
<p>统计该企业员工数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from emp; #返回结果是16，统计的是总记录数</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(idcard) from emp; #返回结果是15，统计的是idcard字段不为null的记录数</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(1) from emp; #会统计表中的所有的记录数，包含字段为null 的记录</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<p>对于 <code>count(*) </code> 、 <code>count(字段)</code> 、  <code>count(1) </code> 的具体原理，我们在进阶篇中 SQL 优化部分会详细讲解，此处大家只需要知道如何使用即可。</p>
</li>
<li>
<p>统计该企业员工的平均年龄</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select avg(age) from emp;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>统计该企业员工的最大年龄</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select max(age) from emp;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>统计该企业员工的最小年龄</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select min(age) from emp;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>统计西安地区员工的年龄之和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sum(age) from emp where workaddress = &#x27;西安&#x27;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="56-分组查询"><a class="markdownIt-Anchor" href="#56-分组查询">#</a> 5.6 分组查询</h3>
<h4 id="a-语法格式"><a class="markdownIt-Anchor" href="#a-语法格式">#</a> a） 语法格式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组 后过滤条件 ];</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<h4 id="bwhere与having区别"><a class="markdownIt-Anchor" href="#bwhere与having区别">#</a> b）where 与 having 区别</h4>
<ul>
<li>执行时机不同： <code>where</code>  是分组之前进行过滤，不满足 <code>where</code>  条件，不参与分组；而 <code>having</code>  是分组之后对结果进行过滤。</li>
<li>判断条件不同： <code>where</code>  不能对聚合函数进行判断，而 <code>having</code>  可以。</li>
</ul>
<h4 id="c案例练习-3"><a class="markdownIt-Anchor" href="#c案例练习-3">#</a> c）案例练习</h4>
<ul>
<li>
<p>根据性别分组，统计男性员工 和 女性员工的数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender, count(*) from emp group by gender ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据性别分组，统计男性员工 和 女性员工的平均年龄</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender, avg(age) from emp group by gender ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询年龄小于 45 的员工，并根据工作地址分组，获取员工数量大于等于 3 的工作地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT workaddress,count(*) address_count</span><br><span class="line">FROM emp</span><br><span class="line">WHERE age &lt; 45</span><br><span class="line">GROUP BY  workaddress</span><br><span class="line">HAVING address_count &gt;= 3;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>统计各个工作地址上班的男性及女性员工的数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select workaddress, gender, count(*) &#x27;数量&#x27; from emp group by gender , workaddress ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="57-排序查询"><a class="markdownIt-Anchor" href="#57-排序查询">#</a> 5.7 排序查询</h3>
<blockquote>
<p>排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。</p>
</blockquote>
<h4 id="a语法格式-3"><a class="markdownIt-Anchor" href="#a语法格式-3">#</a> a）语法格式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<h4 id="b排序方式"><a class="markdownIt-Anchor" href="#b排序方式">#</a> b）排序方式</h4>
<ul>
<li><code>ASC</code> : 升序（默认）</li>
<li><code>DESC</code> : 降序</li>
</ul>
<p><strong>注意：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</strong></p>
<h4 id="c案例练习-4"><a class="markdownIt-Anchor" href="#c案例练习-4">#</a> c）案例练习</h4>
<ul>
<li>
<p>根据年龄对公司的员工进行升序排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp order by age asc;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp order by age;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据入职时间，对员工进行降序排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp order by entrydate desc;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据年龄对公司的员工进行升序排序，年龄相同，再按照入职时间进行降序排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp order by age asc , entrydate desc;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="58-分页查询"><a class="markdownIt-Anchor" href="#58-分页查询">#</a> 5.8 分页查询</h3>
<blockquote>
<p>分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台都需要借助于数据库的分页操作。</p>
</blockquote>
<h4 id="a语法格式-4"><a class="markdownIt-Anchor" href="#a语法格式-4">#</a> a）语法格式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<h4 id="b注意事项"><a class="markdownIt-Anchor" href="#b注意事项">#</a> b）注意事项</h4>
<ul>
<li>起始索引从 <code>0</code>  开始，<mark>起始索引 = （查询页码 - 1）* 每页显示记录数</mark>。</li>
<li>分页查询是数据库的方言，<strong>不同的数据库有不同的实现</strong>， <code>MySQL</code>  中是 <code>LIMIT</code> 。</li>
<li>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</li>
</ul>
<h4 id="c案例练习-5"><a class="markdownIt-Anchor" href="#c案例练习-5">#</a> c）案例练习</h4>
<ul>
<li>
<p>查询第 1 页员工数据，每页展示 10 条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp limit 10;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp limit 0,10;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询第 2 页员工数据，每页展示 10 条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp limit 10,10;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="59-执行顺序"><a class="markdownIt-Anchor" href="#59-执行顺序">#</a> 5.9 执行顺序</h3>
<blockquote>
<p>在讲解 DQL 语句的具体语法之前，我们已经讲解了 DQL 语句的完整语法，及编写顺序，接下来，我们要来说明的是 DQL 语句在执行时的执行顺序，也就是先执行那一部分，后执行那一部分。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM` ➤ `WHERE `➤ `GROUP BY` ➤ `SELECT `➤ `ORDER BY` ➤ `LIMIT</span><br></pre></td></tr></table></figure>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220604130048234.png" alt="image-20220604130048234"></p>
<h2 id="6dcl不重要"><a class="markdownIt-Anchor" href="#6dcl不重要">#</a> 6.DCL（不重要）</h2>
<blockquote>
<p><code>DCL</code>  英文全称是 ** <code>Data Control Language</code> **(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。</p>
<p>作为 Java 开发程序员的话，我们是无需关心 DCL 这一部分的，因为在实际工作中这不是我们所负责的内容！</p>
</blockquote>
<h3 id="61-用户管理"><a class="markdownIt-Anchor" href="#61-用户管理">#</a> 6.1 用户管理</h3>
<ul>
<li>
<p>查询用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER mysql;</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改用户密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：主机名可以使用 % 通配</p>
<h3 id="62-权限控制"><a class="markdownIt-Anchor" href="#62-权限控制">#</a> 6.2 权限控制</h3>
<ul>
<li>
<p>常用权限</p>
<table>
<thead>
<tr>
<th style="text-align:left">权限</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ALL, ALL PRIVILEGES</td>
<td style="text-align:left">所有权限</td>
</tr>
<tr>
<td style="text-align:left">SELECT</td>
<td style="text-align:left">查询数据</td>
</tr>
<tr>
<td style="text-align:left">INSERT</td>
<td style="text-align:left">插入数据</td>
</tr>
<tr>
<td style="text-align:left">UPDATE</td>
<td style="text-align:left">修改数据</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">删除数据</td>
</tr>
<tr>
<td style="text-align:left">ALTER</td>
<td style="text-align:left">修改表</td>
</tr>
<tr>
<td style="text-align:left">DROP</td>
<td style="text-align:left">删除数据库 / 表 / 视图</td>
</tr>
<tr>
<td style="text-align:left">CREATE</td>
<td style="text-align:left">创建数据库 / 表</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>查询权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>授予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>撤销权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意事项</p>
<ul>
<li>多个权限用逗号分隔</li>
<li>授权时，数据库名和表名可以用  <code>*</code>  进行通配，代表所有</li>
</ul>
</li>
</ul>
<h1 id="二-函数"><a class="markdownIt-Anchor" href="#二-函数">#</a> 二、函数</h1>
<blockquote>
<p><mark>函数</mark>是指一段可以<strong>直接被另一段程序调用</strong>的程序或代码。 也就意味着，这一段程序或代码在 <code>MySQL</code>  中已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可。</p>
</blockquote>
<p>Ps：其实很少用到函数的，可以说基本用不到，所以我这就不记那么详细了。</p>
<h2 id="1字符串函数"><a class="markdownIt-Anchor" href="#1字符串函数">#</a> 1. 字符串函数</h2>
<ul>
<li>
<p>常用函数</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CONCAT(s1, s2, …, sn)</td>
<td style="text-align:left">字符串拼接，将 s1, s2, …, sn 拼接成一个字符串</td>
</tr>
<tr>
<td style="text-align:left">LOWER(str)</td>
<td style="text-align:left">将字符串全部转为小写</td>
</tr>
<tr>
<td style="text-align:left">UPPER(str)</td>
<td style="text-align:left">将字符串全部转为大写</td>
</tr>
<tr>
<td style="text-align:left">LPAD(str, n, pad)</td>
<td style="text-align:left">左填充，用字符串 pad 对 str 的左边进行填充，达到 n 个字符串长度</td>
</tr>
<tr>
<td style="text-align:left">RPAD(str, n, pad)</td>
<td style="text-align:left">右填充，用字符串 pad 对 str 的右边进行填充，达到 n 个字符串长度</td>
</tr>
<tr>
<td style="text-align:left">TRIM(str)</td>
<td style="text-align:left">去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td style="text-align:left">SUBSTRING(str, start, len)</td>
<td style="text-align:left">返回从字符串 str 从 start 位置起的 len 个长度的字符串</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>使用示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 拼接</span><br><span class="line">SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);</span><br><span class="line">-- 小写</span><br><span class="line">SELECT LOWER(&#x27;Hello&#x27;);</span><br><span class="line">-- 大写</span><br><span class="line">SELECT UPPER(&#x27;Hello&#x27;);</span><br><span class="line">-- 左填充</span><br><span class="line">SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 右填充</span><br><span class="line">SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 去除空格</span><br><span class="line">SELECT TRIM(&#x27; Hello World &#x27;);</span><br><span class="line">-- 切片（起始索引为1）</span><br><span class="line">SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2数值函数"><a class="markdownIt-Anchor" href="#2数值函数">#</a> 2. 数值函数</h2>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CEIL(x)</td>
<td style="text-align:left">向上取整</td>
</tr>
<tr>
<td style="text-align:left">FLOOR(x)</td>
<td style="text-align:left">向下取整</td>
</tr>
<tr>
<td style="text-align:left">MOD(x, y)</td>
<td style="text-align:left">返回 x/y 的模</td>
</tr>
<tr>
<td style="text-align:left">RAND()</td>
<td style="text-align:left">返回 0~1 内的随机数</td>
</tr>
<tr>
<td style="text-align:left">ROUND(x, y)</td>
<td style="text-align:left">求参数 x 的四舍五入值，保留 y 位小数</td>
</tr>
</tbody>
</table>
<h2 id="3日期函数"><a class="markdownIt-Anchor" href="#3日期函数">#</a> 3. 日期函数</h2>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CURDATE()</td>
<td style="text-align:left">返回当前日期</td>
</tr>
<tr>
<td style="text-align:left">CURTIME()</td>
<td style="text-align:left">返回当前时间</td>
</tr>
<tr>
<td style="text-align:left">NOW()</td>
<td style="text-align:left">返回当前日期和时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR(date)</td>
<td style="text-align:left">获取指定 date 的年份</td>
</tr>
<tr>
<td style="text-align:left">MONTH(date)</td>
<td style="text-align:left">获取指定 date 的月份</td>
</tr>
<tr>
<td style="text-align:left">DAY(date)</td>
<td style="text-align:left">获取指定 date 的日期</td>
</tr>
<tr>
<td style="text-align:left">DATE_ADD(date, INTERVAL expr type)</td>
<td style="text-align:left">返回一个日期 / 时间值加上一个时间间隔 expr 后的时间值</td>
</tr>
<tr>
<td style="text-align:left">DATEDIFF(date1, date2)</td>
<td style="text-align:left">返回起始时间 date1 和结束时间 date2 之间的天数</td>
</tr>
</tbody>
</table>
<h2 id="4流程函数"><a class="markdownIt-Anchor" href="#4流程函数">#</a> 4. 流程函数</h2>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IF(value, t, f)</td>
<td style="text-align:left">如果 value 为 true，则返回 t，否则返回 f</td>
</tr>
<tr>
<td style="text-align:left">IFNULL(value1, value2)</td>
<td style="text-align:left">如果 value1 不为空，返回 value1，否则返回 value2</td>
</tr>
<tr>
<td style="text-align:left">CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td style="text-align:left">如果 val1 为 true，返回 res1，… 否则返回 default 默认值</td>
</tr>
<tr>
<td style="text-align:left">CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td style="text-align:left">如果 expr 的值等于 val1，返回 res1，… 否则返回 default 默认值</td>
</tr>
</tbody>
</table>
<h1 id="三-约束"><a class="markdownIt-Anchor" href="#三-约束">#</a> 三、约束</h1>
<blockquote>
<p>约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p>
</blockquote>
<p>Ps：我们仅需了解约束的含义即可，实际开发中这都是在建表时就已经确定了的。</p>
<h2 id="1常用约束"><a class="markdownIt-Anchor" href="#1常用约束">#</a> 1. 常用约束</h2>
<table>
<thead>
<tr>
<th style="text-align:left">约束</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">非空约束</td>
<td style="text-align:left">限制该字段的数据不能为 null</td>
<td style="text-align:left">NOT NULL</td>
</tr>
<tr>
<td style="text-align:left">唯一约束</td>
<td style="text-align:left">保证该字段的所有数据都是唯一、不重复的</td>
<td style="text-align:left">UNIQUE</td>
</tr>
<tr>
<td style="text-align:left">主键约束</td>
<td style="text-align:left">主键是一行数据的唯一标识，要求非空且唯一</td>
<td style="text-align:left">PRIMARY KEY</td>
</tr>
<tr>
<td style="text-align:left">默认约束</td>
<td style="text-align:left">保存数据时，如果未指定该字段的值，则采用默认值</td>
<td style="text-align:left">DEFAULT</td>
</tr>
<tr>
<td style="text-align:left">检查约束（8.0.1 版本后）</td>
<td style="text-align:left">保证字段值满足某一个条件</td>
<td style="text-align:left">CHECK</td>
</tr>
<tr>
<td style="text-align:left">外键约束</td>
<td style="text-align:left">用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td>
<td style="text-align:left">FOREIGN KEY</td>
</tr>
</tbody>
</table>
<p>约束是作用于表中字段上的，可以在创建表 / 修改表的时候添加约束。</p>
<h2 id="2外键约束"><a class="markdownIt-Anchor" href="#2外键约束">#</a> 2. 外键约束</h2>
<blockquote>
<p>用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性</p>
</blockquote>
<ul>
<li>
<p>建表时添加外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    字段名 字段类型,</span><br><span class="line">    ...</span><br><span class="line">    [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>建表后添加外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>删除 / 更新行为</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">行为</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NO ACTION</td>
<td style="text-align:left">当在父表中删除 / 更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除 / 更新（与 RESTRICT 一致）</td>
</tr>
<tr>
<td style="text-align:left">RESTRICT</td>
<td style="text-align:left">当在父表中删除 / 更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除 / 更新（与 NO ACTION 一致）</td>
</tr>
<tr>
<td style="text-align:left">CASCADE</td>
<td style="text-align:left">当在父表中删除 / 更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除 / 更新外键在子表中的记录</td>
</tr>
<tr>
<td style="text-align:left">SET NULL</td>
<td style="text-align:left">当在父表中删除 / 更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为 null（要求该外键允许为 null）</td>
</tr>
<tr>
<td style="text-align:left">SET DEFAULT</td>
<td style="text-align:left">父表有变更时，子表将外键设为一个默认值（Innodb 不支持）</td>
</tr>
</tbody>
</table>
<p>更改删除 / 更新行为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<h1 id="三-多表查询"><a class="markdownIt-Anchor" href="#三-多表查询">#</a> 三、多表查询</h1>
<blockquote>
<p>我们之前在讲解 SQL 语句的时候，讲解了 DQL 语句，也就是数据查询语句，但是之前讲解的查询都是单表查询，而本章节我们要学习的则是多表查询操作。</p>
</blockquote>
<p>Ps：相较于约束来讲，本章确实是个重点，多表联查会在开发中经常用到，因此需要认真学习！！！</p>
<h2 id="1多表关系"><a class="markdownIt-Anchor" href="#1多表关系">#</a> 1. 多表关系</h2>
<p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p>
<ol>
<li><strong>一对多（多对一）</strong></li>
<li><strong>多对多</strong></li>
<li><strong>一对一</strong></li>
</ol>
<h3 id="11-一对多"><a class="markdownIt-Anchor" href="#11-一对多">#</a> 1.1 一对多</h3>
<ul>
<li>案例：部门 与 员工的关系</li>
<li>关系：一个部门对应多个员工，一个员工对应一个部门</li>
<li>实现：在多的一方建立外键，指向一的一方的主键</li>
</ul>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220604201130760.png" alt="image-20220604201130760"></p>
<h3 id="12-多对多"><a class="markdownIt-Anchor" href="#12-多对多">#</a> 1.2 多对多</h3>
<ul>
<li>案例：学生 与 课程的关系</li>
<li>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</li>
<li>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li>
</ul>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220604201411978.png" alt="image-20220604201411978"></p>
<h3 id="13-一对一"><a class="markdownIt-Anchor" href="#13-一对一">#</a> 1.3 一对一</h3>
<ul>
<li>案例：用户 与 用户详情的关系</li>
<li>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率</li>
<li>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的 (UNIQUE)</li>
</ul>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220604201513196.png" alt="image-20220604201513196"></p>
<h2 id="2多表查询概述"><a class="markdownIt-Anchor" href="#2多表查询概述">#</a> 2. 多表查询概述</h2>
<h3 id="21-数据准备"><a class="markdownIt-Anchor" href="#21-数据准备">#</a> 2.1 数据准备</h3>
<ul>
<li>
<p>删除之前的 emp, dept 表</p>
</li>
<li>
<p>执行下面 SQL 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept (</span><br><span class="line">	id int PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;ID&#x27;,</span><br><span class="line">	name varchar(50) NOT NULL COMMENT &#x27;部门名称&#x27;</span><br><span class="line">) COMMENT &#x27;部门表&#x27;;</span><br><span class="line">INSERT INTO dept (id, name) VALUES (1, &#x27;研发部&#x27;), (2, &#x27;市场部&#x27;),(3, &#x27;财务部&#x27;), (4, &#x27;销售部&#x27;), (5, &#x27;总经办&#x27;), (6, &#x27;人事部&#x27;);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">	id int PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;ID&#x27;,</span><br><span class="line">	name varchar(50) NOT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">	age int COMMENT &#x27;年龄&#x27;,</span><br><span class="line">	job varchar(20) COMMENT &#x27;职位&#x27;,</span><br><span class="line">	salary int COMMENT &#x27;薪资&#x27;,</span><br><span class="line">	entrydate date COMMENT &#x27;入职时间&#x27;,</span><br><span class="line">	managerid int COMMENT &#x27;直属领导ID&#x27;,</span><br><span class="line">	dept_id int COMMENT &#x27;部门ID&#x27;</span><br><span class="line">) COMMENT &#x27;员工表&#x27;;</span><br><span class="line">alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);</span><br><span class="line"></span><br><span class="line">INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id)</span><br><span class="line">VALUES</span><br><span class="line">    (1, &#x27;金庸&#x27;, 66, &#x27;总裁&#x27;, 20000, &#x27;2000-01-01&#x27;, null, 5),</span><br><span class="line">    (2, &#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;, 12500, &#x27;2005-12-05&#x27;, 1, 1),</span><br><span class="line">    (3, &#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400, &#x27;2000-11-03&#x27;, 2, 1),</span><br><span class="line">    (4, &#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;, 11000, &#x27;2002-02-05&#x27;, 2, 1),</span><br><span class="line">    (5, &#x27;常遇春&#x27;, 43, &#x27;开发&#x27;, 10500, &#x27;2004-09-07&#x27;, 3, 1),</span><br><span class="line">    (6, &#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;, 6600, &#x27;2004-10-12&#x27;, 2, 1),</span><br><span class="line">    (7, &#x27;灭绝&#x27;, 60, &#x27;财务总监&#x27;, 8500, &#x27;2002-09-12&#x27;, 1, 3),</span><br><span class="line">    (8, &#x27;周芷若&#x27;, 19, &#x27;会计&#x27;, 48000, &#x27;2006-06-02&#x27;, 7, 3),</span><br><span class="line">    (9, &#x27;丁敏君&#x27;, 23, &#x27;出纳&#x27;, 5250, &#x27;2009-05-13&#x27;, 7, 3),</span><br><span class="line">    (10, &#x27;赵敏&#x27;, 20, &#x27;市场部总监&#x27;, 12500, &#x27;2004-10-12&#x27;, 1, 2),</span><br><span class="line">    (11, &#x27;鹿杖客&#x27;, 56, &#x27;职员&#x27;, 3750, &#x27;2006-10-03&#x27;, 10, 2),</span><br><span class="line">    (12, &#x27;鹤笔翁&#x27;, 19, &#x27;职员&#x27;, 3750, &#x27;2007-05-09&#x27;, 10, 2),</span><br><span class="line">    (13, &#x27;方东白&#x27;, 19, &#x27;职员&#x27;, 5500, &#x27;2009-02-12&#x27;, 10, 2),</span><br><span class="line">    (14, &#x27;张三丰&#x27;, 88, &#x27;销售总监&#x27;, 14000, &#x27;2004-10-12&#x27;, 1, 4),</span><br><span class="line">    (15, &#x27;俞莲舟&#x27;, 38, &#x27;销售&#x27;, 4600, &#x27;2004-10-12&#x27;, 14, 4),</span><br><span class="line">    (16, &#x27;宋远桥&#x27;, 40, &#x27;销售&#x27;, 4600, &#x27;2004-10-12&#x27;, 14, 4),</span><br><span class="line">    (17, &#x27;陈友谅&#x27;, 42, null, 2000, &#x27;2011-10-12&#x27;, 1, null);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="22-笛卡尔积"><a class="markdownIt-Anchor" href="#22-笛卡尔积">#</a> 2.2 笛卡尔积</h3>
<blockquote>
<p>笛卡尔乘积是指在数学中，两个集合 A 集合 和 B 集合 的所有组合情况。</p>
</blockquote>
<ul>
<li>
<p>这是我们查单表的 SQL 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>那么我们要执行多表查询，就只需要使用逗号分隔多张表即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp , dept;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>但是这个时候查出来的结果却是 102 条记录</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605080339628.png" alt="image-20220605080339628"></p>
<p>与 部门表 dept 所有记录 (6) 的所有组合情况，这种现象称之为笛卡尔积。</p>
</li>
</ul>
<blockquote>
<p>在 SQL 语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp , dept where emp.dept_id = dept.id;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605080630910.png" alt="image-20220605080630910"></p>
<p>而由于 id 为 17 的员工，没有 <code>dept_id</code>  字段值，所以在多表查询时，根据连接查询的条件并没有查询到。</p>
<h3 id="23-分类"><a class="markdownIt-Anchor" href="#23-分类">#</a> 2.3 分类</h3>
<blockquote>
<p>多表查询又分为以下两大类：</p>
</blockquote>
<ul>
<li>连接查询
<ul>
<li>内连接：相当于查询 A、B 交集部分数据</li>
<li>外连接：
<ul>
<li>左外连接：查询左表所有数据，以及两张表交集部分数据</li>
<li>右外连接：查询右表所有数据，以及两张表交集部分数据</li>
</ul>
</li>
<li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li>
</ul>
</li>
<li>子查询</li>
</ul>
<h2 id="3内连接"><a class="markdownIt-Anchor" href="#3内连接">#</a> 3. 内连接</h2>
<blockquote>
<p>内连接查询的是两张表交集部分的数据。(也就是绿色部分的数据)</p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605081106113.png" alt="image-20220605081106113"></p>
<p>内连接的语法分为两种：<strong>隐式内连接</strong>、<strong>显式内连接</strong>。</p>
<h3 id="31-语法格式"><a class="markdownIt-Anchor" href="#31-语法格式">#</a> 3.1 语法格式</h3>
<ul>
<li>
<p>隐式内连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>显式内连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="32-案例练习"><a class="markdownIt-Anchor" href="#32-案例练习">#</a> 3.2 案例练习</h3>
<ul>
<li>查询每一个员工的姓名，及关联的部门的名称 (隐式内连接实现)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select e.`name`, d.`name` from emp e,dept d where e.dept_id = d.id;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>查询每一个员工的姓名，及关联的部门的名称 (显式内连接实现)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select e.`name`, d.`name` from emp e join dept d on e.dept_id = d.id;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4外连接"><a class="markdownIt-Anchor" href="#4外连接">#</a> 4. 外连接</h2>
<blockquote>
<p>外连接和内连接一样查询的都是两个表交集的数据，不同的是左外连接会查询左表的全部数据以及交集数据，右外连接与之相对。</p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605081106113.png" alt="image-20220605081106113"></p>
<h3 id="41-语法格式"><a class="markdownIt-Anchor" href="#41-语法格式">#</a> 4.1 语法格式</h3>
<ul>
<li>
<p>左外连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>右外连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="42-案例练习"><a class="markdownIt-Anchor" href="#42-案例练习">#</a> 4.2 案例练习</h3>
<ul>
<li>
<p>查询 <code>emp</code>  表的所有数据，和对应的部门信息（左外）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select e.*,d.name from emp e left join dept d on e.dept_id = d.id;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询 <code>dept</code>  表的所有数据，和对应的员工信息（右外）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select e.*,d.name from emp e right join dept d on e.dept_id = d.id;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>左外连接和右外连接是可以相互替换的，只需要调整在连接查询时 SQL 中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。</p>
<h2 id="5自连接"><a class="markdownIt-Anchor" href="#5自连接">#</a> 5. 自连接</h2>
<h3 id="51-自链接查询"><a class="markdownIt-Anchor" href="#51-自链接查询">#</a> 5.1 自链接查询</h3>
<blockquote>
<p>当前表与自身的连接查询，自连接必须使用表别名</p>
</blockquote>
<ul>
<li>
<p>语法格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<p>自连接查询，可以是内连接查询，也可以是外连接查询</p>
</li>
<li>
<p>案例练习</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询员工及其所属领导的名字</span><br><span class="line">select a.name, b.name from employee a, employee b where a.manager = b.id;</span><br><span class="line">-- 没有领导的也查询出来</span><br><span class="line">select a.name, b.name from employee a left join employee b on a.manager = b.id;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="52-联合查询"><a class="markdownIt-Anchor" href="#52-联合查询">#</a> 5.2 联合查询</h3>
<blockquote>
<p>把多次查询的结果合并，形成一个新的查询集，其实就是吧两个查询语句给连起来了。</p>
</blockquote>
<ul>
<li>
<p>语法格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ...</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT 字段列表 FROM 表B ...</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意事项</p>
<ul>
<li>UNION ALL 会有重复结果，UNION 不会</li>
<li>联合查询比使用 or 效率高，不会使索引失效</li>
</ul>
</li>
</ul>
<h2 id="6子查询"><a class="markdownIt-Anchor" href="#6子查询">#</a> 6. 子查询</h2>
<h3 id="61-概述"><a class="markdownIt-Anchor" href="#61-概述">#</a> 6.1 概述</h3>
<blockquote>
<p>SQL 语句中嵌套 SELECT 语句，称为嵌套查询，又称子查询。</p>
</blockquote>
<ul>
<li>
<p>语法格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<p>子查询外部的语句可以是 <code>INSERT </code> /  <code>UPDATE </code> /  <code>DELETE </code> /  <code>SELECT </code> 的任何一个。</p>
</li>
<li>
<p>根据子查询结果不同，分为：</p>
<ul>
<li>标量子查询（子查询结果为单个值）</li>
<li>列子查询（子查询结果为一列）</li>
<li>行子查询（子查询结果为一行）</li>
<li>表子查询（子查询结果为多行多列）</li>
</ul>
</li>
<li>
<p>根据子查询位置，分为：</p>
<ul>
<li>WHERE 之后</li>
<li>FROM 之后</li>
<li>SELECT 之后</li>
</ul>
</li>
</ul>
<h3 id="62-标量子查询"><a class="markdownIt-Anchor" href="#62-标量子查询">#</a> 6.2 标量子查询</h3>
<blockquote>
<p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。</p>
</blockquote>
<p>常用操作符： <code>- &lt; &gt; &gt; &gt;= &lt; &lt;=</code></p>
<p>案例练习：</p>
<ul>
<li>
<p>查询 “销售部” 的所有员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where dept_id = (select id from dept where name = &#x27;销售部&#x27;);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询在 “方东白” 入职之后的员工信息</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where entrydate &gt; (select entrydate from emp where name = &#x27;方东白&#x27;);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<h3 id="63-列子查询"><a class="markdownIt-Anchor" href="#63-列子查询">#</a> 6.3 列子查询</h3>
<blockquote>
<p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p>
</blockquote>
<p>常用的操作符： <code>IN 、NOT IN 、 ANY 、SOME 、 ALL</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IN</td>
<td style="text-align:left">在指定的集合范围内，多选一</td>
</tr>
<tr>
<td style="text-align:left">NOT IN</td>
<td style="text-align:left">不在指定的集合范围内</td>
</tr>
<tr>
<td style="text-align:left">ANY</td>
<td style="text-align:left">子查询返回列表中，有任意一个满足即可</td>
</tr>
<tr>
<td style="text-align:left">SOME</td>
<td style="text-align:left">与 ANY 等同，使用 SOME 的地方都可以使用 ANY</td>
</tr>
<tr>
<td style="text-align:left">ALL</td>
<td style="text-align:left">子查询返回列表的所有值都必须满足</td>
</tr>
</tbody>
</table>
<p>案例练习：</p>
<ul>
<li>
<p>查询 “销售部” 和 “市场部” 的所有员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where dept_id in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询比 “财务部” 所有人工资都高的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where salary &gt; all ( select salary from emp where dept_id = (select id from dept where name = &#x27;财务部&#x27;) );</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询比研发部其中任意一人工资高的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where salary &gt; any ( select salary from emp where dept_id = (select id from dept where name = &#x27;研发部&#x27;) );</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="64-行子查询"><a class="markdownIt-Anchor" href="#64-行子查询">#</a> 6.4 行子查询</h3>
<blockquote>
<p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</p>
</blockquote>
<p>常用的操作符： <code>= 、&lt;&gt; 、IN 、NOT IN</code></p>
<p>案例练习：</p>
<ul>
<li>查询与 “张无忌” 的薪资及直属领导相同的员工信息；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where (salary,managerid) = (select salary, managerid from emp where name = &#x27;张无忌&#x27;);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<h3 id="65-表子查询"><a class="markdownIt-Anchor" href="#65-表子查询">#</a> 6.5 表子查询</h3>
<blockquote>
<p>子查询返回的结果是多行多列，这种子查询称为表子查询。</p>
</blockquote>
<p>常用操作符： <code>IN</code></p>
<p>案例练习：</p>
<ul>
<li>
<p>查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where (job,salary) in ( select job, salary from emp where name = &#x27;鹿杖客&#x27; or name = &#x27;宋远桥&#x27; );</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询入职日期是 “2006-01-01” 之后的员工信息，及其部门信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select e.*, d.* from (select * from emp where entrydate &gt; &#x27;2006-01-01&#x27;) e left join dept d on e.dept_id = d.id ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="四-事务"><a class="markdownIt-Anchor" href="#四-事务">#</a> 四、事务</h1>
<h2 id="1事务简介"><a class="markdownIt-Anchor" href="#1事务简介">#</a> 1. 事务简介</h2>
<blockquote>
<p><strong>事务</strong>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
</blockquote>
<p>举例说明：</p>
<p>张三给李四转账 1000 块钱，张三银行账户的钱<mark>减少 1000</mark>，而李四银行账户的钱要<mark>增加 1000</mark>。 这一组操作就必须在一个事务的范围内，<strong>要么都成功</strong>，<strong>要么都失败</strong>。</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605121214330.png" alt="image-20220605121214330"></p>
<p><strong>注意： 默认 MySQL 的事务是自动提交的，也就是说，当执行完一条 DML 语句时，MySQL 会立即隐式的提交事务。</strong></p>
<h2 id="2事务操作"><a class="markdownIt-Anchor" href="#2事务操作">#</a> 2. 事务操作</h2>
<h3 id="21-数据准备-2"><a class="markdownIt-Anchor" href="#21-数据准备-2">#</a> 2.1 数据准备</h3>
<blockquote>
<p>在开始学习事务之前需要先执行以下 SQL 语句来导入数据。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists account;</span><br><span class="line"></span><br><span class="line">create table account(</span><br><span class="line">    id int primary key AUTO_INCREMENT comment &#x27;ID&#x27;,</span><br><span class="line">    name varchar(10) comment &#x27;姓名&#x27;,</span><br><span class="line">    money double(10, 2) comment &#x27;余额&#x27;</span><br><span class="line">) comment &#x27;账户表&#x27;;</span><br><span class="line"></span><br><span class="line">insert into account(name, money) VALUES (&#x27;张三&#x27;, 2000),(&#x27;李四&#x27;, 2000);</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<h3 id="22-未控制事务"><a class="markdownIt-Anchor" href="#22-未控制事务">#</a> 2.2 未控制事务</h3>
<blockquote>
<p>当前情境下事务是 MySQL 默认的事务，也就是每执行一句更新操作都将由 MySQL 自动隐式提交。</p>
</blockquote>
<ul>
<li>
<p>测试转账操作的正常情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 查询张三余额 </span><br><span class="line">select * from account where name = &#x27;张三&#x27;; </span><br><span class="line">-- 2. 张三的余额减少1000 </span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;; </span><br><span class="line">-- 3. 李四的余额增加1000 </span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605122748424.png" alt="image-20220605122748424"></p>
</li>
<li>
<p>测试异常情况（执行之前先将两个人的余额都恢复到 2000）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 查询张三余额 </span><br><span class="line">select * from account where name = &#x27;张三&#x27;; </span><br><span class="line">-- 2. 张三的余额减少1000 </span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;; </span><br><span class="line">出错了...</span><br><span class="line">-- 3. 李四的余额增加1000 </span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605123015353.png" alt="image-20220605123015353"></p>
</li>
</ul>
<p>通过上面的两种情况演示，我们得知如果是异常情况的话，这种错误是非常致命的，假如真的是两个人之间的转账，一方钱减少了，另一方却没有增加的话，用户必定会勃然大怒，因此我们需要通过控制事务的方式来避免这种情况的出现！</p>
<h3 id="23-控制事务一不常用"><a class="markdownIt-Anchor" href="#23-控制事务一不常用">#</a> 2.3 控制事务一（不常用）</h3>
<ul>
<li>
<p>查看 / 设置事务提交方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@autocommit ; </span><br><span class="line">SET @@autocommit = 0 ;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提交事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>回滚事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意</strong>：上述的这种方式，我们是修改了事务的自动提交行为，把默认的自动提交修改为了手动提交，此时我们执行的 DML 语句都不会提交，需要手动的执行 <code>commit</code>  进行提交。</p>
<h3 id="24-控制事务二常用"><a class="markdownIt-Anchor" href="#24-控制事务二常用">#</a> 2.4 控制事务二（常用）</h3>
<ul>
<li>
<p>开启事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION 或 BEGIN TRANSACTION;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提交事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>回滚事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="25-转账案例"><a class="markdownIt-Anchor" href="#25-转账案例">#</a> 2.5 转账案例</h3>
<blockquote>
<p>接下来通过控制事务的方式演示一遍转账操作。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开启事务 </span><br><span class="line">start transaction </span><br><span class="line">-- 1. 查询张三余额 </span><br><span class="line">select * from account where name = &#x27;张三&#x27;; </span><br><span class="line">-- 2. 张三的余额减少1000 </span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;; </span><br><span class="line">-- 3. 李四的余额增加1000 </span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;; </span><br><span class="line">-- 如果正常执行完毕, 则提交事务 </span><br><span class="line">commit; </span><br><span class="line">-- 如果执行过程中报错, 则回滚事务 </span><br><span class="line">-- rollback;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<h2 id="3事务四大特性acid"><a class="markdownIt-Anchor" href="#3事务四大特性acid">#</a> 3. 事务四大特性（ACID）</h2>
<ul>
<li>原子性 ( <code>Atomicity</code> )：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li>
<li>一致性 ( <code>Consistency</code> )：事务完成时，必须使所有数据都保持一致状态</li>
<li>隔离性 ( <code>Isolation</code> )：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li>
<li>持久性 ( <code>Durability</code> )：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li>
</ul>
<h2 id="4并发事务问题"><a class="markdownIt-Anchor" href="#4并发事务问题">#</a> 4. 并发事务问题</h2>
<table>
<thead>
<tr>
<th style="text-align:left">问题</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">脏读</td>
<td style="text-align:left">一个事务读到另一个事务还没提交的数据</td>
</tr>
<tr>
<td style="text-align:left">不可重复读</td>
<td style="text-align:left">一个事务先后读取同一条记录，但两次读取的数据不同</td>
</tr>
<tr>
<td style="text-align:left">幻读</td>
<td style="text-align:left">一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>赃读（比如 B 读取到了 A 未提交的数据）</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605125309397.png" alt="image-20220605125309397"></p>
</li>
<li>
<p>不可重复读（事务 A 两次读取同一条记录，但是读取到的数据却是不一样的）</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605125417374.png" alt="image-20220605125417374"></p>
</li>
<li>
<p>幻读</p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MySQL/image-20220605125445124.png" alt="image-20220605125445124"></p>
</li>
</ul>
<h2 id="5事务隔离级别"><a class="markdownIt-Anchor" href="#5事务隔离级别">#</a> 5. 事务隔离级别</h2>
<table>
<thead>
<tr>
<th style="text-align:left">隔离级别</th>
<th style="text-align:left">脏读</th>
<th style="text-align:left">不可重复读</th>
<th style="text-align:left">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Read uncommitted</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">Read committed</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left"><strong>Repeatable Read (默认)</strong></td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">Serializable</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>√表示在当前隔离级别下该问题会出现</p>
</li>
<li>
<p><code>Serializable </code> 性能最低； <code>Read uncommitted</code>  性能最高，数据安全性最差</p>
</li>
<li>
<p>查看事务隔离级别： <code>SELECT @@TRANSACTION_ISOLATION;</code></p>
</li>
<li>
<p>设置事务隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</span><br><span class="line">sql</span><br></pre></td></tr></table></figure>
<p><code>SESSION </code> 是会话级别，表示只针对当前会话有效， <code>GLOBAL </code> 表示对所有会话有效</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>教程</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot讲义-原理篇</title>
    <url>/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%8E%9F%E7%90%86%E7%AF%87/</url>
    <content><![CDATA[<h1 id="springboot原理篇"><a class="markdownIt-Anchor" href="#springboot原理篇">#</a> SpringBoot 原理篇</h1>
<h3 id="前言白嫖发言"><a class="markdownIt-Anchor" href="#前言白嫖发言">#</a> 前言（白嫖发言）</h3>
<p>​		这个笔记是从黑马老师那里嫖来的，放在这里是为了方便查看，没有商用的意思，转载请标明<strong>黑马程序员</strong>以及链接。</p>
<p>​		原理篇来辣！</p>
<p>​		其实从本人的角度出发，看了这么多学习 java 的小伙伴的学习过程，个人观点，不建议小伙伴过早的去研究技术的原理。原因有二：一，<strong>先应用熟练</strong>，<strong>培养技术应用的条件反射</strong>，然后再学原理。大把的学习者天天还纠结于这里少写一个这，那里少写一个那，程序都跑不下去，要啥原理，要啥自行车。这里要说一句啊，懂不懂啥意思那不叫原理，原理是抽象到顶层设计层面的东西。知道为什么写这句话，知道错误的原因和懂原理是两码事。二， <strong>原理真不是看源码</strong>，源码只能称作原理的落地实现方式，当好的落地实现方式出现后，就会有新旧版本的迭代，底层实现方式也会伴随着更新升级。但是原理不变，只是找到了更好的实现最初目标的路径。一个好的课程，一位好的老师，不会用若干行云里雾里的源代码把学习者带到沟里，然后爬不出来，深陷泥潭。一边沮丧的看着源码，一边舔着老师奉其为大神，这就叫不干人事。原理就应该使用最通俗易懂的语言，把设计思想讲出来，至于看源码，只是因为目前的技术原创人员只想到了当前这种最笨的设计方案，还没有更好的。比如 spirng 程序，写起来很费劲，springboot 出来以后就简单轻松了很多，实现方案变了，原理不变。但凡你想通过下面的课程学习去读懂若干行代码，然后特别装逼的告诉自己，我懂原理了。我只能告诉你，你选了一条成本最高的路线，看源码仅仅是验证原理，源码仅对应程序流程，不对应原理。原理是思想级的，不是代码级的，原理是原本的道理。</p>
<p>​		springboot 技术本身就是为了加速 spring 程序的开发的，可以大胆的说，springboot 技术没有自己的原理层面的设计，仅仅是实现方案进行了改进。将 springboot 定位成工具，你就不会去想方设法的学习其原理了。就像是将木头分割成若干份，我们可以用斧子，用锯子，用刀，用火烧或者一脚踹断它，这些都是方式方法，而究其本质底层原理是植物纤维的组织方式，研究完这个，你再看前述的各种工具，都是基于这个原理在说如何变更破坏这种植物纤维的方式。所以不要一张嘴说了若干种技术，然后告诉自己，这就是 spirngboot 的原理。没有的事，springboot 作为一款工具，压根就没有原理。我们下面要学习的其实就是 spirngboot 程序的工作流程。</p>
<p>​		下面就开始学习原理篇，因为没有想出来特别好的名字，所以还是先称作原理篇吧。原理篇中包含如下内容：</p>
<ul>
<li>自动配置工作流程</li>
<li>自定义 starter 开发</li>
<li>springboot 程序启动流程</li>
</ul>
<p>​		下面开启第一部分自动配置工作流程的学习</p>
<h2 id="yl-1自动配置工作流程"><a class="markdownIt-Anchor" href="#yl-1自动配置工作流程">#</a> YL-1. 自动配置工作流程</h2>
<p>​		自动配置是 springboot 技术非常好用的核心因素，前面学习了这么多种技术的整合，每一个都离不开自动配置。不过在学习自动配置的时候，需要你对 spring 容器如何进行 bean 管理的过程非常熟悉才行，所以这里需要先复习一下有关 spring 技术中 bean 加载相关的知识。方式方法很多，逐一快速复习一下，查漏补缺。不过这里需要声明一点，这里列出的 bean 的加载方式仅仅应用于后面课程的学习，并不是所有的 spring 加载 bean 的方式。跟着我的步伐一种一种的复习，他们这些方案之间有千丝万缕的关系，顺着看完，你就懂自动配置是怎么回事了。</p>
<h3 id="yl-1-1bean的加载方式"><a class="markdownIt-Anchor" href="#yl-1-1bean的加载方式">#</a> YL-1-1.bean 的加载方式</h3>
<p>​		关于 bean 的加载方式，spring 提供了各种各样的形式。因为 spring 管理 bean 整体上来说就是由 spring 维护对象的生命周期，所以 bean 的加载可以从大的方面划分成 2 种形式。已知类并交给 spring 管理，和已知类名并交给 spring 管理。有什么区别？一个给.class，一个给类名字符串。内部其实都一样，都是通过 spring 的 BeanDefinition 对象初始化 spring 的 bean。如果前面这句话看起来有障碍，可以去复习一下 spring 的相关知识。B 站中有我尊敬的满一航老师录制的 spring 高级课程，链接地址如下，欢迎大家捧场，记得一键三连哦。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">https://<span class="title">www.bilibili.com</span>/<span class="title">video</span>/<span class="title">BV1P44y1N7QG</span></span></span><br></pre></td></tr></table></figure>
<h4 id="方式一配置文件bean标签"><a class="markdownIt-Anchor" href="#方式一配置文件bean标签">#</a> 方式一：配置文件 + <code>&lt;bean/&gt;</code>  标签</h4>
<p>​		最高端的食材往往只需要最简单的烹饪方法，搞错了，再来。最初级的 bean 的加载方式其实可以直击 spring 管控 bean 的核心思想，就是提供类名，然后 spring 就可以管理了。所以第一种方式就是给出 bean 的类名，至于内部嘛就是反射机制加载成 class，然后，就没有然后了，拿到了 class 你就可以搞定一切了。如果这句话听不太懂，请这些小盆友转战 java 基础高级部分复习一下反射相关知识。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--xml方式声明自己开发的bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--xml方式声明第三方开发的bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="方式二配置文件扫描注解定义bean"><a class="markdownIt-Anchor" href="#方式二配置文件扫描注解定义bean">#</a> 方式二：配置文件扫描 + 注解定义 bean</h4>
<p>​		由于方式一种需要将 spring 管控的 bean 全部写在 xml 文件中，对于程序员来说非常不友好，所以就有了第二种方式。哪一个类要受到 spring 管控加载成 bean，就在这个类的上面加一个注解，还可以顺带起一个 bean 的名字（id）。这里可以使用的注解有 @Component 以及三个衍生注解 @Service、@Controller、@Repository。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;tom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		当然，由于我们无法在第三方提供的技术源代码中去添加上述 4 个注解，因此当你需要加载第三方开发的 bean 的时候可以使用下列方式定义注解式的 bean。@Bean 定义在一个方法上方，当前方法的返回值就可以交给 spring 管控，记得这个方法所在的类一定要定义在 @Component 修饰的类中，有人会说不是 @Configuration 吗？建议把 spring 注解开发相关课程学习一下，就不会有这个疑问了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource ds = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		上面提供的仅仅是 bean 的声明，spring 并没有感知到这些东西，像极了上课积极回答问题的你，手举的非常高，可惜老师都没有往你的方向看上一眼。想让 spring 感知到这些积极的小伙伴，必须设置 spring 去检查这些类，看他们是否贴标签，想当积极分子。可以通过下列 xml 配置设置 spring 去检查哪些包，发现定了对应注解，就将对应的类纳入 spring 管控范围，声明成 bean。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定扫描加载bean的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.bean,com.itheima.config&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		方式二声明 bean 的方式是目前企业中较为常见的 bean 的声明方式，但是也有缺点。方式一中，通过一个配置文件，你可以查阅当前 spring 环境中定义了多少个或者说多少种 bean，但是方式二没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个 bean。</p>
<h4 id="方式三注解方式声明配置类"><a class="markdownIt-Anchor" href="#方式三注解方式声明配置类">#</a> 方式三：注解方式声明配置类</h4>
<p>​		方式二已经完美的简化了 bean 的声明，以后再也不用写茫茫多的配置信息了。仔细观察 xml 配置文件，会发现这个文件中只剩了扫描包这句话，于是就有人提出，使用 java 类替换掉这种固定格式的配置，所以下面这种格式就出现了。严格意义上讲不能算全新的方式，但是由于此种开发形式是企业级开发中的主流形式，所以单独独立出来做成一种方式。嗯……，怎么说呢？方式二和方式三其实差别还是挺大的，番外篇找个时间再聊吧。</p>
<p>​		定义一个类并使用 @ComponentScan 替代原始 xml 配置中的包扫描这个动作，其实功能基本相同。为什么说基本，还是有差别的。先卖个关子吧，番外篇再聊。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.bean&quot;,&quot;com.itheima.config&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DogFactoryBean <span class="title">dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用factroybean接口"><a class="markdownIt-Anchor" href="#使用factroybean接口">#</a> 使用 FactroyBean 接口</h5>
<p>​		补充一个小知识，spring 提供了一个接口 FactoryBean，也可以用于声明 bean，只不过实现了 FactoryBean 接口的类造出来的对象不是当前类的对象，而是 FactoryBean 接口泛型指定类型的对象。如下列，造出来的 bean 并不是 DogFactoryBean，而是 Dog。有什么用呢？可以在对象初始化前做一些事情，下例中的注释位置就是让你自己去扩展要做的其他事情的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Dog</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">//.........</span></span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Dog.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		有人说，注释中的代码写入 Dog 的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为 Dog 是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果写入 Dog，或许初始化动作 A 当前并不能满足你的需要，这个时候你就要做一个 DogB 的方案了。然后，就没有然后了，你就要做两个 Dog 类。当时使用 FactoryBean 接口就可以完美解决这个问题。</p>
<p>​		通常实现了 FactoryBean 接口的类使用 @Bean 的形式进行加载，当然你也可以使用 @Component 去声明 DogFactoryBean，只要被扫描加载到即可，但是这种格式加载总觉得怪怪的，指向性不是很明确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.bean&quot;,&quot;com.itheima.config&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DogFactoryBean <span class="title">dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注解格式导入xml格式配置的bean"><a class="markdownIt-Anchor" href="#注解格式导入xml格式配置的bean">#</a> 注解格式导入 XML 格式配置的 bean</h5>
<p>​		再补充一个小知识，由于早起开发的系统大部分都是采用 xml 的形式配置 bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发的用注解格式，之前开发的是 xml 格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring 提供了一个注解可以解决这个问题，@ImportResource，在配置类上直接写上要被融合的 xml 配置文件名即可，算的上一种兼容性解决方案，没啥实际意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;applicationContext1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig32</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="proxybeanmethods属性"><a class="markdownIt-Anchor" href="#proxybeanmethods属性">#</a> proxyBeanMethods 属性</h5>
<p>​		前面的例子中用到了 @Configuration 这个注解，当我们使用 AnnotationConfigApplicationContext 加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的 bean 的唯一性。为 @Configuration 注解设置 proxyBeanMethods 属性值为 true 即可，由于此属性默认值为 true，所以很少看见明确书写的，除非想放弃此功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig33</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		下面通过容器再调用上面的 cat 方法时，得到的就是同一个对象了。注意，必须使用 spring 容器对象调用此方法才有保持 bean 唯一性的特性。此特性在很多底层源码中有应用，前面讲 MQ 时，也应用了此特性，只不过当前没有解释而已。这里算是填个坑吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App33</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig33.class);</span><br><span class="line">        String[] names = ctx.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">        SpringConfig33 springConfig33 = ctx.getBean(<span class="string">&quot;springConfig33&quot;</span>, SpringConfig33.class);</span><br><span class="line">        System.out.println(springConfig33.cat());</span><br><span class="line">        System.out.println(springConfig33.cat());</span><br><span class="line">        System.out.println(springConfig33.cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式四使用import注解注入bean"><a class="markdownIt-Anchor" href="#方式四使用import注解注入bean">#</a> 方式四：使用 @Import 注解注入 bean</h4>
<p>​		使用扫描的方式加载 bean 是企业级开发中常见的 bean 的加载方式，但是由于扫描的时候不仅可以加载到你要的东西，还有可能加载到各种各样的乱七八糟的东西，万一没有控制好得不偿失了。</p>
<p>​		有人就会奇怪，会有什么问题呢？比如你扫描了 com.itheima.service 包，后来因为业务需要，又扫描了 com.itheima.dao 包，你发现 com.itheima 包下面只有 service 和 dao 这两个包，这就简单了，直接扫描 com.itheima 就行了。但是万万没想到，十天后你加入了一个外部依赖包，里面也有 com.itheima 包，这下就热闹了，该来的不该来的全来了。</p>
<p>​		所以我们需要一种精准制导的加载方式，使用 @Import 注解就可以解决你的问题。它可以加载所有的一切，只需要在注解的参数中写上加载的类对应的.class 即可。有人就会觉得，还要自己手写，多麻烦，不如扫描好用。对呀，但是他可以指定加载啊，好的命名规范配合 @ComponentScan 可以解决很多问题，但是 @Import 注解拥有其重要的应用场景。有没有想过假如你要加载的 bean 没有使用 @Component 修饰呢？这下就无解了，而 @Import 就无需考虑这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Dog.class,DbConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig4</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用import注解注入配置类"><a class="markdownIt-Anchor" href="#使用import注解注入配置类">#</a> 使用 @Import 注解注入配置类</h5>
<p>​		除了加载 bean，还可以使用 @Import 注解加载配置类。其实本质上是一样的，不解释太多了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(DogFactoryBean.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig4</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式五编程形式注册bean"><a class="markdownIt-Anchor" href="#方式五编程形式注册bean">#</a> 方式五：编程形式注册 bean</h4>
<p>​		前面介绍的加载 bean 的方式都是在容器启动阶段完成 bean 的加载，下面这种方式就比较特殊了，可以在容器初始化完成后手动加载 bean。通过这种方式可以实现编程式控制 bean 的加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        <span class="comment">//上下文容器对象已经初始化完毕后，手工加载bean</span></span><br><span class="line">        ctx.register(Mouse.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其实这种方式坑还是挺多的，比如容器中已经有了某种类型的 bean，再加载会不会覆盖呢？这都是要思考和关注的问题。新手慎用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        <span class="comment">//上下文容器对象已经初始化完毕后，手工加载bean</span></span><br><span class="line">        ctx.registerBean(<span class="string">&quot;tom&quot;</span>, Cat.class,<span class="number">0</span>);</span><br><span class="line">        ctx.registerBean(<span class="string">&quot;tom&quot;</span>, Cat.class,<span class="number">1</span>);</span><br><span class="line">        ctx.registerBean(<span class="string">&quot;tom&quot;</span>, Cat.class,<span class="number">2</span>);</span><br><span class="line">        System.out.println(ctx.getBean(Cat.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式六导入实现了importselector接口的类"><a class="markdownIt-Anchor" href="#方式六导入实现了importselector接口的类">#</a> 方式六：导入实现了 ImportSelector 接口的类</h4>
<p>​		在方式五种，我们感受了 bean 的加载可以进行编程化的控制，添加 if 语句就可以实现 bean 的加载控制了。但是毕竟是在容器初始化后实现 bean 的加载控制，那是否可以在容器初始化过程中进行控制呢？答案是必须的。实现 ImportSelector 接口的类可以设置加载的 bean 的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。</p>
<p>​		现在又多了一种控制 bean 加载的方式，或者说是选择 bean 的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        <span class="comment">//各种条件的判定，判定完毕后，决定是否装载指定的bean</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = metadata.hasAnnotation(<span class="string">&quot;org.springframework.context.annotation.Configuration&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;com.itheima.bean.Dog&quot;</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;com.itheima.bean.Cat&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="方式七导入实现了importbeandefinitionregistrar接口的类"><a class="markdownIt-Anchor" href="#方式七导入实现了importbeandefinitionregistrar接口的类">#</a> 方式七：导入实现了 ImportBeanDefinitionRegistrar 接口的类</h4>
<p>​		方式六中提供了给定类全路径类名控制 bean 加载的形式，如果对 spring 的 bean 的加载原理比较熟悉的小伙伴知道，其实 bean 的加载不是一个简简单单的对象，spring 中定义了一个叫做 BeanDefinition 的东西，它才是控制 bean 初始化加载的核心。BeanDefinition 接口中给出了若干种方法，可以控制 bean 的相关属性。说个最简单的，创建的对象是单例还是非单例，在 BeanDefinition 中定义了 scope 属性就可以控制这个。如果你感觉方式六没有给你开放出足够的对 bean 的控制操作，那么方式七你值得拥有。我们可以通过定义一个类，然后实现 ImportBeanDefinitionRegistrar 接口的方式定义 bean，并且还可以让你对 bean 的初始化进行更加细粒度的控制，不过对于新手并不是很友好。忽然给你开放了若干个操作，还真不知道如何下手。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = 	</span><br><span class="line">            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;bookService&quot;</span>,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式八导入实现了beandefinitionregistrypostprocessor接口的类"><a class="markdownIt-Anchor" href="#方式八导入实现了beandefinitionregistrypostprocessor接口的类">#</a> 方式八：导入实现了 BeanDefinitionRegistryPostProcessor 接口的类</h4>
<p>​		上述七种方式都是在容器初始化过程中进行 bean 的加载或者声明，但是这里有一个 bug。这么多种方式，它们之间如果有冲突怎么办？谁能有最终裁定权？这是个好问题，当某种类型的 bean 被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你还真不知道最后谁说了算。即便你理清楚了，保不齐和你一起开发的猪队友又添加了一个 bean，得嘞，这下就热闹了。</p>
<p>​		spring 挥舞它仲裁者的大刀来了一个致命一击，都别哔哔了，我说了算，BeanDefinitionRegistryPostProcessor，看名字知道，BeanDefinition 意思是 bean 定义，Registry 注册的意思，Post 后置，Processor 处理器，全称 bean 定义后处理器，干啥的？在所有 bean 注册都折腾完后，它把最后一道关，说白了，它说了算，这下消停了，它是最后一个运行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = </span><br><span class="line">            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;bookService&quot;</span>,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​		总体上来说，上面介绍了各种各样的 bean 的注册加载初始化方式，脑子里建立个概念吧，方式很多，spring 源码中大量运用各种方式。复习的内容就先说到这里。</p>
<p><strong>总结</strong></p>
<ol>
<li>bean 的定义由前期 xml 配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是 spring 管控的 bean</li>
<li>@Import 注解可以指定加载某一个类作为 spring 管控的 bean，如果被加载的类中还具有 @Bean 相关的定义，会被一同加载</li>
<li>spring 开放出了若干种可编程控制的 bean 的初始化方式，通过分支语句由固定的加载 bean 转成了可以选择 bean 是否加载或者选择加载哪一种 bean</li>
</ol>
<h3 id="yl-1-2bean的加载控制"><a class="markdownIt-Anchor" href="#yl-1-2bean的加载控制">#</a> YL-1-2.bean 的加载控制</h3>
<p>​		前面复习 bean 的加载时，提出了有关加载控制的方式，其中手工注册 bean，ImportSelector 接口，ImportBeanDefinitionRegistrar 接口，BeanDefinitionRegistryPostProcessor 接口都可以控制 bean 的加载，这一节就来说说这些加载控制。</p>
<p>​		企业级开发中不可能在 spring 容器中进行 bean 的饱和式加载的。什么是饱和式加载，就是不管用不用，全部加载。比如 jdk 中有两万个类，那就加载两万个 bean，显然是不合理的，因为你压根就不会使用其中大部分的 bean。那合理的加载方式是什么？肯定是必要性加载，就是用什么加载什么。继续思考，加载哪些 bean 通常受什么影响呢？最容易想的就是你要用什么技术，就加载对应的 bean。用什么技术意味着什么？就是加载对应技术的类。所以在 spring 容器中，通过判定是否加载了某个类来控制某些 bean 的加载是一种常见操作。下例给出了对应的代码实现，其实思想很简单，先判断一个类的全路径名是否能够成功加载，加载成功说明有这个类，那就干某项具体的工作，否则就干别的工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.itheima.bean.Mouse&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;com.itheima.bean.Cat&quot;</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		通过上述的分析，可以看到此类操作将成为企业级开发中的常见操作，于是 springboot 将把这些常用操作给我们做了一次封装。这种逻辑判定你开发者就别搞了，我 springboot 信不过你这种新手开发者，我给你封装一下，做几个注解，你填参数吧，耶，happy。</p>
<p>​		下例使用 @ConditionalOnClass 注解实现了当虚拟机中加载了 com.itheima.bean.Wolf 类时加载对应的 bean。比较一下上面的代码和下面的代码，有没有感觉很清爽。其实此类注解还有很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;com.itheima.bean.Wolf&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		@ConditionalOnMissingClass 注解控制虚拟机中没有加载指定的类才加载对应的 bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;com.itheima.bean.Dog&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		这种条件还可以做并且的逻辑关系，写 2 个就是 2 个条件都成立，写多个就是多个条件都成立。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;com.itheima.bean.Wolf&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;com.itheima.bean.Mouse&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		除了判定是否加载类，还可以对当前容器类型做判定，下例是判定当前容器环境是否是 web 环境。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		下面是判定容器环境是否是非 web 环境。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		当然还可以判定是否加载了指定名称的 bean，这种有什么用呢？太有用了。比如当前容器中已经提供了 jdbcTemplate 对应的 bean，你还需要再加载一个全新的 jdbcTemplate 的 bean 吗？没有必要了嘛。spring 说，如果你自己写的话，我就不帮你操这份心了，如果你没写，我再给你提供。自适应，自适应，明白？没有的话就提供给你，有的话就用你自己的，是不是很帅？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name=&quot;jerry&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		以下就是判定当前是否加载了 mysql 的驱动类，如果加载了，我就给你搞一个 Druid 的数据源对象出来，完美！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name=&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其中 springboot 的 bean 加载控制注解还有很多，这里就不一一列举了，最常用的判定条件就是根据类是否加载来进行控制。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 定义了若干种控制 bean 加载的条件设置注解，由 spring 固定加载 bean 变成了可以根据情况选择性的加载 bean</li>
</ol>
<h3 id="yl-1-3bean的依赖属性配置管理"><a class="markdownIt-Anchor" href="#yl-1-3bean的依赖属性配置管理">#</a> YL-1-3.bean 的依赖属性配置管理</h3>
<p>​		bean 的加载及加载控制已经搞完了，下面研究一下 bean 内部的事情。bean 在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，这个时候就可以使用前期学习的 bean 的属性配置相关的知识进行灵活的配置了。先通过 yml 配置文件，设置 bean 运行需要使用的配置信息。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cartoon:</span></span><br><span class="line">  <span class="attr">cat:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;图多盖洛&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">mouse:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;泰菲&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>​		然后定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;cartoon&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		最后在使用的位置注入对应的配置即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CartoonProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonCatAndMouse</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CartoonProperties cartoonProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		建议在业务类上使用 @EnableConfigurationProperties 声明 bean，这样在不使用这个类的时候，也不会无故加载专用的属性配置类 CartoonProperties，减少 spring 管控的资源数量。</p>
<p><strong>总结</strong></p>
<ol>
<li>bean 的运行如果需要外部设置值，建议将设置值封装成专用的属性类 * * * * Properties</li>
<li>设置属性类加载指定前缀的配置信息</li>
<li>在需要使用属性类的位置通过注解 @EnableConfigurationProperties 加载 bean，而不要直接在属性配置类上定义 bean，减少资源加载的数量，因需加载而不要饱和式加载。</li>
</ol>
<h3 id="yl-1-4自动配置原理工作流程"><a class="markdownIt-Anchor" href="#yl-1-4自动配置原理工作流程">#</a> YL-1-4. 自动配置原理（工作流程）</h3>
<p>​		经过前面的知识复习，下面终于进入到了本章核心内容的学习，自动配置原理。原理谈不上，就是自动配置的工作流程。</p>
<p>​		啥叫自动配置呢？简单说就是 springboot 根据我们开发者的行为猜测你要做什么事情，然后把你要用的 bean 都给你准备好。听上去是不是很神奇？其实非常简单，前面复习的东西都已经讲完了。springboot 咋做到的呢？就是看你导入了什么类，就知道你想干什么了。然后把你有可能要用的 bean（注意是有可能）都给你加载好，你直接使用就行了，springboot 把所需要的一切工作都做完了。</p>
<p>​		自动配置的意义就是加速开发效率，将开发者使用某种技术时需要使用的 bean 根据情况提前加载好，实现自动配置的效果。当然，开发者有可能需要提供必要的参数，比如你要用 mysql 技术，导入了 mysql 的坐标，springboot 就知道了你要做数据库操作，一系列的数据库操作相关的 bean 都给你提前声明好，但是你要告诉 springboot 你到底用哪一个数据库，像什么 IP 地址啊，端口啊，你不告诉 spirngboot，springboot 就无法帮你把自动配置相关的工作做完。</p>
<p>​		而这种思想其实就是在日常的开发过程中根据开发者的习惯慢慢抽取得到了。整体过程分为 2 个阶段：</p>
<p>​		<strong>阶段一：准备阶段</strong></p>
<ol>
<li>
<p>springboot 的开发人员先大量收集 Spring 开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成一个<strong>技术集 A</strong></p>
</li>
<li>
<p>收集常用技术 (<strong>技术集 A</strong>) 的使用参数，不管你用什么常用设置，我用什么常用设置，统统收集起来整理一下，得到开发过程中每一个技术的常用设置，形成每一个技术对应的<strong>设置集 B</strong></p>
<p><strong>阶段二：加载阶段</strong></p>
</li>
<li>
<p>springboot 初始化 Spring 容器基础环境，读取用户的配置信息，加载用户自定义的 bean 和导入的其他坐标，形成<strong>初始化环境</strong></p>
</li>
<li>
<p>springboot 将<strong>技术集 A</strong> 包含的所有技术在 SpringBoot 启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的</p>
</li>
<li>
<p>springboot 会对<strong>技术集 A</strong> 中每一个技术约定出启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些 bean 和其他坐标，也就是与<strong>初始化环境</strong>，这个时候就可以根据这个<strong>初始化环境</strong>与 springboot 的<strong>技术集 A</strong> 进行比对了，哪个匹配上加载哪个</p>
</li>
<li>
<p>因为有些技术不做配置就无法工作，所以 springboot 开始对<strong>设置集 B</strong> 下手了。它统计出各个国家各个行业的开发者使用某个技术时最常用的设置是什么，然后把这些设置作为默认值直接设置好，并告诉开发者当前设置我已经给你搞了一套，你要用可以直接用，这样可以减少开发者配置参数的工作量</p>
</li>
<li>
<p>但是默认配置不一定能解决问题，于是 springboot 开放修改<strong>设置集 B</strong> 的接口，可以由开发者根据需要决定是否覆盖默认配置</p>
</li>
</ol>
<p>​		以上这些仅仅是一个思想，落地到代码实现阶段就要好好思考一下怎么实现了。假定我们想自己实现自动配置的功能，都要做哪些工作呢？</p>
<ul>
<li>首先指定一个技术 X，我们打算让技术 X 具备自动配置的功能，这个技术 X 可以是任意功能，这个技术隶属于上面描述的<strong>技术集 A</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonCatAndMouse</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后找出技术 X 使用过程中的常用配置 Y，这个配置隶属于上面表述的<strong>设置集 B</strong></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cartoon:</span></span><br><span class="line">  <span class="attr">cat:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;图多盖洛&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">mouse:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;泰菲&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将常用配置 Y 设计出对应的 yml 配置书写格式，然后定义一个属性类封装对应的配置属性，这个过程其实就是上一节咱们做的 bean 的依赖属性管理，一模一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;cartoon&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后做一个配置类，当这个类加载的时候就可以初始化对应的功能 bean，并且可以加载到对应的配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CartoonProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonCatAndMouse</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CartoonProperties cartoonProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当然，你也可以为当前自动配置类设置上激活条件，例如使用 @CondtionOn* * * * 为其设置加载条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(name=&quot;org.springframework.data.redis.core.RedisOperations&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(CartoonProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonCatAndMouse</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CartoonProperties cartoonProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		做到这里都已经做完了，但是遇到了一个全新的问题，如何让 springboot 启动的时候去加载这个类呢？如果不加载的话，我们做的条件判定，做的属性加载这些全部都失效了。springboot 为我们开放了一个配置入口，在配置目录中创建 META-INF 目录，并创建 spring.factories 文件，在其中添加设置，说明哪些类要启动自动配置就可以了。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.itheima.bean.CartoonCatAndMouse</span><br></pre></td></tr></table></figure>
<p>​		其实这个文件就做了一件事，通过这种配置的方式加载了指定的类。转了一圈，就是个普通的 bean 的加载，和最初使用 xml 格式加载 bean 几乎没有区别，格式变了而已。那自动配置的核心究竟是什么呢？自动配置其实是一个小的生态，可以按照如下思想理解：</p>
<ol>
<li>自动配置从根本上来说就是一个 bean 的加载</li>
<li>通过 bean 加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用，这是蒙蔽我们双眼的第一层面纱</li>
<li>使用 bean 的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，感觉这个过程好屌，也是一种自适应的形式，其实还是需要使用分支语句来做判断的，这是蒙蔽我们双眼的第二层面纱</li>
<li>springboot 技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，其实就是提前帮我们把 spring.factories 文件写好了，这是蒙蔽我们双眼的第三层面纱</li>
</ol>
<p>​		你在不知道自动配置这个知识的情况下，经过上面这一二三，你当然觉得自动配置是一种特别牛的技术，但是一窥究竟后发现，也就那么回事。而且现在 springboot 程序启动时，在后台偷偷的做了这么多次检测，这么多种情况判定，不用问了，效率一定是非常低的，毕竟它要检测 100 余种技术是否在你程序中使用。</p>
<p>​		以上内容是自动配置的工作流程。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 启动时先加载 spring.factories 文件中的 org.springframework.boot.autoconfigure.EnableAutoConfiguration 配置项，将其中配置的所有的类都加载成 bean</li>
<li>在加载 bean 的时候，bean 对应的类定义上都设置有加载条件，因此有可能加载成功，也可能条件检测失败不加载 bean</li>
<li>对于可以正常加载成 bean 的类，通常会通过 @EnableConfigurationProperties 注解初始化对应的配置属性类并加载对应的配置</li>
<li>配置属性类上通常会通过 @ConfigurationProperties 加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须配置后使用了</li>
</ol>
<h3 id="yl-1-5变更自动配置"><a class="markdownIt-Anchor" href="#yl-1-5变更自动配置">#</a> YL-1-5. 变更自动配置</h3>
<p>​		知道了自动配置的执行过程，下面就可以根据这个自动配置的流程做一些高级定制了。例如系统默认会加载 100 多种自动配置的技术，如果我们先手工干预此工程，禁用自动配置是否可行呢？答案一定是可以的。方式还挺多：</p>
<p><strong>方式一：通过 yaml 配置设置排除指定的自动配置类</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">autoconfigure:</span></span><br><span class="line">    <span class="attr">exclude:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<p><strong>方式二：通过注解参数排除自动配置类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration(excludeName = &quot;&quot;,exclude = &#123;&#125;)</span></span><br></pre></td></tr></table></figure>
<p><strong>方式三：排除坐标（应用面较窄）</strong></p>
<p>如果当前自动配置中包含有更多的自动配置功能，也就是一个套娃的效果。此时可以通过检测条件的控制来管理自动配置是否启动。例如 web 程序启动时会自动启动 tomcat 服务器，可以通过排除坐标的方式，让加载 tomcat 服务器的条件失效。不过需要提醒一点，你把 tomcat 排除掉，记得再加一种可以运行的服务器。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--添加Jetty起步依赖，匹配自动配置条件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>springboot 的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能</li>
</ol>
<h2 id="yl-2自定义starter开发"><a class="markdownIt-Anchor" href="#yl-2自定义starter开发">#</a> YL-2. 自定义 starter 开发</h2>
<p>​		自动配置学习完后，我们就可以基于自动配置的特性，开发 springboot 技术中最引以为傲的功能了，starter。其实通过前期学习，我们发现用什么技术直接导入对应的 starter，然后就实现了 springboot 整合对应技术，再加上一些简单的配置，就可以直接使用了。这种设计方式对开发者非常友好，本章就通过一个案例的制作，开发自定义 starter 来实现自定义功能的快捷添加。</p>
<h3 id="yl-2-1案例记录系统访客独立ip访问次数"><a class="markdownIt-Anchor" href="#yl-2-1案例记录系统访客独立ip访问次数">#</a> YL-2-1. 案例：记录系统访客独立 IP 访问次数</h3>
<p>​		本案例的功能是统计网站独立 IP 访问次数的功能，并将访问信息在后台持续输出。整体功能是在后台每 10 秒输出一次监控信息（格式：IP + 访问次数） ，当用户访问网站时，对用户的访问行为进行统计。</p>
<p>​		例如：张三访问网站功能 15 次，IP 地址：192.168.0.135，李四访问网站功能 20 次，IP 地址：61.129.65.248。那么在网站后台就输出如下监控信息，此信息每 10 秒刷新一次。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">         IP访问监控</span><br><span class="line">+-----ip-address-----+--num--+</span><br><span class="line">|     192.168.0.135  |   15  |</span><br><span class="line">|     61.129.65.248  |   20  |</span><br><span class="line">+--------------------+-------+</span><br></pre></td></tr></table></figure>
<p>​		在进行具体制作之前，先对功能做具体的分析</p>
<ol>
<li>
<p>数据记录在什么位置</p>
<p>最终记录的数据是一个字符串（IP 地址）对应一个数字（访问次数），此处可以选择的数据存储模型可以使用 java 提供的 map 模型，也就是 key-value 的键值对模型，或者具有 key-value 键值对模型的存储技术，例如 redis 技术。本案例使用 map 作为实现方案，有兴趣的小伙伴可以使用 redis 作为解决方案。</p>
</li>
<li>
<p>统计功能运行位置，因为每次 web 请求都需要进行统计，因此使用拦截器会是比较好的方案，本案例使用拦截器来实现。不过在制作初期，先使用调用的形式进行测试，等功能完成了，再改成拦截器的实现方案。</p>
</li>
<li>
<p>为了提升统计数据展示的灵活度，为统计功能添加配置项。输出频度，输出的数据格式，统计数据的显示模式均可以通过配置实现调整。</p>
<ul>
<li>输出频度，默认 10 秒</li>
<li>数据特征：累计数据 / 阶段数据，默认累计数据</li>
<li>输出格式：详细模式 / 极简模式</li>
</ul>
</li>
</ol>
<p>​		在下面的制作中，分成若干个步骤实现。先完成最基本的统计功能的制作，然后开发出统计报表，接下来把所有的配置都设置好，最后将拦截器功能实现，整体功能就做完了。</p>
<h3 id="yl-2-2ip计数业务功能开发自定义starter"><a class="markdownIt-Anchor" href="#yl-2-2ip计数业务功能开发自定义starter">#</a> YL-2-2.IP 计数业务功能开发（自定义 starter）</h3>
<p>​		本功能最终要实现的效果是在现有的项目中导入一个 starter，对应的功能就添加上了，删除掉对应的 starter，功能就消失了，要求功能要与原始项目完全解耦。因此需要开发一个独立的模块，制作对应功能。</p>
<p><strong>步骤一：创建全新的模块，定义业务功能类</strong></p>
<p>​		功能类的制作并不复杂，定义一个业务类，声明一个 Map 对象，用于记录 ip 访问次数，key 是 ip 地址，value 是访问次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		有些小伙伴可能会有疑问，不设置成静态的，如何在每次请求时进行数据共享呢？记得，当前类加载成 bean 以后是一个单例对象，对象都是单例的，哪里存在多个对象共享变量的问题。</p>
<p><strong>步骤二：制作统计功能</strong></p>
<p>​		制作统计操作对应的方法，每次访问后对应 ip 的记录次数 + 1。需要分情况处理，如果当前没有对应 ip 的数据，新增一条数据，否则就修改对应 key 的值 + 1 即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//每次调用当前操作，就记录当前访问的IP，然后累加访问次数</span></span><br><span class="line">        <span class="comment">//1.获取当前操作的IP地址</span></span><br><span class="line">        String ip = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//2.根据IP地址从Map取值，并递增</span></span><br><span class="line">        Integer count = ipCountMap.get(ip);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ipCountMap.put(ip,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ipCountMap.put(ip,count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		因为当前功能最终导入到其他项目中进行，而导入当前功能的项目是一个 web 项目，可以从容器中直接获取请求对象，因此获取 IP 地址的操作可以通过自动装配得到请求对象，然后获取对应的访问 IP 地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//当前的request对象的注入工作由使用当前starter的工程提供自动装配</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest httpServletRequest;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//每次调用当前操作，就记录当前访问的IP，然后累加访问次数</span></span><br><span class="line">        <span class="comment">//1.获取当前操作的IP地址</span></span><br><span class="line">        String ip = httpServletRequest.getRemoteAddr();</span><br><span class="line">        <span class="comment">//2.根据IP地址从Map取值，并递增</span></span><br><span class="line">        Integer count = ipCountMap.get(ip);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ipCountMap.put(ip,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ipCountMap.put(ip,count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤三：定义自动配置类</strong></p>
<p>​		我们需要做到的效果是导入当前模块即开启此功能，因此使用自动配置实现功能的自动装载，需要开发自动配置类在启动项目时加载当前功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpCountService <span class="title">ipCountService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IpCountService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		自动配置类需要在 spring.factories 文件中做配置方可自动运行。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">cn.itcast.autoconfig.IpAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤四：在原始项目中模拟调用，测试功能</strong></p>
<p>​		原始调用项目中导入当前开发的 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ip_spring_boot_starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		推荐选择调用方便的功能做测试，推荐使用分页操作，当然也可以换其他功能位置进行测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IpCountService ipCountService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">getPage</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="keyword">int</span> pageSize,Book book)</span></span>&#123;</span><br><span class="line">        ipCountService.count();</span><br><span class="line">        IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize,book);</span><br><span class="line">        <span class="keyword">if</span>( currentPage &gt; page.getPages())&#123;</span><br><span class="line">            page = bookService.getPage((<span class="keyword">int</span>)page.getPages(), pageSize,book);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> R(<span class="keyword">true</span>, page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		由于当前制作的功能需要在对应的调用位置进行坐标导入，因此必须保障仓库中具有当前开发的功能，所以每次原始代码修改后，需要重新编译并安装到仓库中。为防止问题出现，建议每次安装之前先 clean 然后 install，保障资源进行了更新。切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		每次调用分页操作后，可以在控制台输出当前访问的 IP 地址，此功能可以在 count 操作中添加日志或者输出语句进行测试。</p>
<h3 id="yl-2-3定时任务报表开发"><a class="markdownIt-Anchor" href="#yl-2-3定时任务报表开发">#</a> YL-2-3. 定时任务报表开发</h3>
<p>​		当前已经实现了在业务功能类中记录访问数据，但是还没有输出监控的信息到控制台。由于监控信息需要每 10 秒输出 1 次，因此需要使用定时器功能。可以选取第三方技术 Quartz 实现，也可以选择 Spring 内置的 task 来完成此功能，此处选用 Spring 的 task 作为实现方案。</p>
<p><strong>步骤一：开启定时任务功能</strong></p>
<p>​		定时任务功能开启需要在当前功能的总配置中设置，结合现有业务设定，比较合理的位置是设置在自动配置类上。加载自动配置类即启用定时任务功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpCountService <span class="title">ipCountService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IpCountService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤二：制作显示统计数据功能</strong></p>
<p>​		定义显示统计功能的操作 print ()，并设置定时任务，当前设置每 5 秒运行一次统计数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;         IP访问监控&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;+-----ip-address-----+--num--+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;|%18s  |%5d  |&quot;</span>,key,value));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------------------+-------+&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其中关于统计报表的显示信息拼接可以使用各种形式进行，此处使用 String 类中的格式化字符串操作进行，学习者可以根据自己的喜好调整实现方案。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先 clean 然后 install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		每次调用分页操作后，可以在控制台看到统计数据，到此基础功能已经开发完毕。</p>
<h3 id="yl-2-4使用属性配置设置功能参数"><a class="markdownIt-Anchor" href="#yl-2-4使用属性配置设置功能参数">#</a> YL-2-4. 使用属性配置设置功能参数</h3>
<p>​		由于当前报表显示的信息格式固定，为提高报表信息显示的灵活性，需要通过 yml 文件设置参数，控制报表的显示格式。</p>
<p><strong>步骤一：定义参数格式</strong></p>
<p>​		设置 3 个属性，分别用来控制显示周期（cycle），阶段数据是否清空（cycleReset），数据显示格式（model）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tools:</span></span><br><span class="line">  <span class="attr">ip:</span></span><br><span class="line">    <span class="attr">cycle:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">cycleReset:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">model:</span> <span class="string">&quot;detail&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤二：定义封装参数的属性类，读取配置参数</strong></p>
<p>​		为防止项目组定义的参数种类过多，产生冲突，通常设置属性前缀会至少使用两级属性作为前缀进行区分。</p>
<p>​		日志输出模式是在若干个类别选项中选择某一项，对于此种分类性数据建议制作枚举定义分类数据，当然使用字符串也可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;tools.ip&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpProperties</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志显示周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long cycle = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否周期内重置数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean cycleReset = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志输出模式  detail：详细模式  simple：极简模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String model = LogModel.DETAIL.value;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LogModel</span></span>&#123;</span><br><span class="line">        DETAIL(<span class="string">&quot;detail&quot;</span>),</span><br><span class="line">        SIMPLE(<span class="string">&quot;simple&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> String value;</span><br><span class="line">        LogModel(String value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤三：加载属性类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(IpProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpCountService <span class="title">ipCountService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IpCountService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤四：应用配置属性</strong></p>
<p>​		在应用配置属性的功能类中，使用自动装配加载对应的配置 bean，然后使用配置信息做分支处理。</p>
<p>​		注意：清除数据的功能一定要在输出后运行，否则每次查阅的数据均为空白数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IpProperties ipProperties;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ipProperties.getModel().equals(IpProperties.LogModel.DETAIL.getValue()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;         IP访问监控&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;+-----ip-address-----+--num--+&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) &#123;</span><br><span class="line">                String key = entry.getKey();</span><br><span class="line">                Integer value = entry.getValue();</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;|%18s  |%5d  |&quot;</span>,key,value));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;+--------------------+-------+&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ipProperties.getModel().equals(IpProperties.LogModel.SIMPLE.getValue()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;     IP访问监控&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;+-----ip-address-----+&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String key: ipCountMap.keySet()) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;|%18s  |&quot;</span>,key));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;+--------------------+&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阶段内统计数据归零</span></span><br><span class="line">        <span class="keyword">if</span>(ipProperties.getCycleReset())&#123;</span><br><span class="line">            ipCountMap.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先 clean 然后 install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		在 web 程序端可以通过控制 yml 文件中的配置参数对统计信息进行格式控制。但是数据显示周期还未进行控制。</p>
<h3 id="yl-2-5使用属性配置设置定时器参数"><a class="markdownIt-Anchor" href="#yl-2-5使用属性配置设置定时器参数">#</a> YL-2-5. 使用属性配置设置定时器参数</h3>
<p>​		在使用属性配置中的显示周期数据时，遇到了一些问题。由于无法在 @Scheduled 注解上直接使用配置数据，改用曲线救国的方针，放弃使用 @EnableConfigurationProperties 注解对应的功能，改成最原始的 bean 定义格式。</p>
<p><strong>步骤一：@Scheduled 注解使用 #{} 读取 bean 属性值</strong></p>
<p>​		此处读取 bean 名称为 ipProperties 的 bean 的 cycle 属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/#&#123;ipProperties.cycle&#125; * * * * ?&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤二：属性类定义 bean 并指定 bean 的访问名称</strong></p>
<p>​		如果此处不设置 bean 的访问名称，spring 会使用自己的命名生成器生成 bean 的长名称，无法实现属性的读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;ipProperties&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;tools.ip&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpProperties</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤三：弃用 @EnableConfigurationProperties 注解对应的功能，改为导入 bean 的形式加载配置属性类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="comment">//@EnableConfigurationProperties(IpProperties.class)</span></span><br><span class="line"><span class="meta">@Import(IpProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpCountService <span class="title">ipCountService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IpCountService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先 clean 然后 install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		在 web 程序端可以通过控制 yml 文件中的配置参数对统计信息的显示周期进行控制</p>
<h3 id="yl-2-6拦截器开发"><a class="markdownIt-Anchor" href="#yl-2-6拦截器开发">#</a> YL-2-6. 拦截器开发</h3>
<p>​		基础功能基本上已经完成了制作，下面进行拦截器的开发。开发时先在 web 工程中制作，然后将所有功能挪入 starter 模块中</p>
<p><strong>步骤一：开发拦截器</strong></p>
<p>​		使用自动装配加载统计功能的业务类，并在拦截器中调用对应功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IpCountService ipCountService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">                             HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ipCountService.count();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤二：配置拦截器</strong></p>
<p>​		配置 mvc 拦截器，设置拦截对应的请求路径。此处拦截所有请求，用户可以根据使用需要设置要拦截的请求。甚至可以在此处加载 IpCountProperties 中的属性，通过配置设置拦截器拦截的请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(ipCountInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpCountInterceptor <span class="title">ipCountInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IpCountInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先 clean 然后 install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		在 web 程序端导入对应的 starter 后功能开启，去掉坐标后功能消失，实现自定义 starter 的效果。</p>
<p>​		到此当前案例全部完成，自定义 stater 的开发其实在第一轮开发中就已经完成了，就是创建独立模块导出独立功能，需要使用的位置导入对应的 starter 即可。如果是在企业中开发，记得不仅需要将开发完成的 starter 模块 install 到自己的本地仓库中，开发完毕后还要 deploy 到私服上，否则别人就无法使用了。</p>
<h3 id="yl-2-7功能性完善开启yml提示功能"><a class="markdownIt-Anchor" href="#yl-2-7功能性完善开启yml提示功能">#</a> YL-2-7. 功能性完善 —— 开启 yml 提示功能</h3>
<p>​		我们在使用 springboot 的配置属性时，都可以看到提示，尤其是导入了对应的 starter 后，也会有对应的提示信息出现。但是现在我们的 starter 没有对应的提示功能，这种设定就非常的不友好，本节解决自定义 starter 功能如何开启配置提示的问题。</p>
<p>​		springboot 提供有专用的工具实现此功能，仅需要导入下列坐标。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		程序编译后，在 META-INF 目录中会生成对应的提示文件，然后拷贝生成出的文件到自己开发的 META-INF 目录中，并对其进行编辑。打开生成的文件，可以看到如下信息。其中 groups 属性定义了当前配置的提示信息总体描述，当前配置属于哪一个属性封装类，properties 属性描述了当前配置中每一个属性的具体设置，包含名称、类型、描述、默认值等信息。hints 属性默认是空白的，没有进行设置。hints 属性可以参考 springboot 源码中的制作，设置当前属性封装类专用的提示信息，下例中为日志输出模式属性 model 设置了两种可选提示信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;groups&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;properties&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.cycle&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;java.lang.Long&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;日志显示周期&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span>,</span><br><span class="line">      <span class="string">&quot;defaultValue&quot;</span>: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.cycle-reset&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;java.lang.Boolean&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;是否周期内重置数据&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span>,</span><br><span class="line">      <span class="string">&quot;defaultValue&quot;</span>: <span class="keyword">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.model&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;日志输出模式  detail：详细模式  simple：极简模式&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;hints&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.model&quot;</span>,</span><br><span class="line">      <span class="string">&quot;values&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;value&quot;</span>: <span class="string">&quot;detail&quot;</span>,</span><br><span class="line">          <span class="string">&quot;description&quot;</span>: <span class="string">&quot;详细模式.&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;value&quot;</span>: <span class="string">&quot;simple&quot;</span>,</span><br><span class="line">          <span class="string">&quot;description&quot;</span>: <span class="string">&quot;极简模式.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>自定义 starter 其实就是做一个独立的功能模块，核心技术是利用自动配置的效果在加载模块后加载对应的功能</li>
<li>通常会为自定义 starter 的自动配置功能添加足够的条件控制，而不会做成 100% 加载对功能的效果</li>
<li>本例中使用 map 保存数据，如果换用 redis 方案，在 starter 开发模块中就要导入 redis 对应的 starter</li>
<li>对于配置属性务必开启提示功能，否则使用者无法感知配置应该如何书写</li>
</ol>
<h2 id="yl-3springboot程序启动流程解析"><a class="markdownIt-Anchor" href="#yl-3springboot程序启动流程解析">#</a> YL-3.SpringBoot 程序启动流程解析</h2>
<p>​		原理篇学习到这里即将结束，最后一章说一下 springboot 程序的启动流程。对于 springboot 技术来说，它用于加速 spring 程序的开发，核心本质还是 spring 程序的运行，所以于其说是 springboot 程序的启动流程，不如说是 springboot 对 spring 程序的启动流程做了哪些更改。</p>
<p>​		其实不管是 springboot 程序还是 spring 程序，启动过程本质上都是在做容器的初始化，并将对应的 bean 初始化出来放入容器。在 spring 环境中，每个 bean 的初始化都要开发者自己添加设置，但是切换成 springboot 程序后，自动配置功能的添加帮助开发者提前预设了很多 bean 的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得略微复杂，但是核心本质还是在做一件事，初始化容器。作为开发者只要搞清楚 springboot 提供了哪些参数设置的环节，同时初始化容器的过程中都做了哪些事情就行了。</p>
<p>​		springboot 初始化的参数根据参数的提供方，划分成如下 3 个大类，每个大类的参数又被封装了各种各样的对象，具体如下：</p>
<ul>
<li>环境属性（Environment）</li>
<li>系统配置（spring.factories）</li>
<li>参数（Arguments、application.properties）</li>
</ul>
<p>​		以下通过代码流向介绍了 springboot 程序启动时每一环节做的具体事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Springboot30StartupApplication【<span class="number">10</span>】-&gt;SpringApplication.run(Springboot30StartupApplication.class, args);</span><br><span class="line">    SpringApplication【<span class="number">1332</span>】-&gt;<span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">        SpringApplication【<span class="number">1343</span>】-&gt;<span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">            SpringApplication【<span class="number">1343</span>】-&gt;SpringApplication(primarySources)</span><br><span class="line">            # 加载各种配置信息，初始化各种配置对象</span><br><span class="line">                SpringApplication【<span class="number">266</span>】-&gt;<span class="keyword">this</span>(<span class="keyword">null</span>, primarySources);</span><br><span class="line">                    SpringApplication【<span class="number">280</span>】-&gt;<span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span></span></span><br><span class="line"><span class="function">                        SpringApplication【281】-&gt;<span class="keyword">this</span>.resourceLoader </span>= resourceLoader;</span><br><span class="line">                        # 初始化资源加载器</span><br><span class="line">                        SpringApplication【<span class="number">283</span>】-&gt;<span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">                        # 初始化配置类的类名信息（格式转换）</span><br><span class="line">                        SpringApplication【<span class="number">284</span>】-&gt;<span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">                        # 确认当前容器加载的类型</span><br><span class="line">                        SpringApplication【<span class="number">285</span>】-&gt;<span class="keyword">this</span>.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();</span><br><span class="line">                        # 获取系统配置引导信息</span><br><span class="line">                        SpringApplication【<span class="number">286</span>】-&gt;setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">                        # 获取ApplicationContextInitializer.class对应的实例</span><br><span class="line">                        SpringApplication【<span class="number">287</span>】-&gt;setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">                        # 初始化监听器，对初始化过程及运行过程进行干预</span><br><span class="line">                        SpringApplication【<span class="number">288</span>】-&gt;<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">                        # 初始化了引导类类名信息，备用</span><br><span class="line">            SpringApplication【<span class="number">1343</span>】-&gt;<span class="keyword">new</span> SpringApplication(primarySources).run(args)</span><br><span class="line">            # 初始化容器，得到ApplicationContext对象</span><br><span class="line">                SpringApplication【<span class="number">323</span>】-&gt;StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">                # 设置计时器</span><br><span class="line">                SpringApplication【<span class="number">324</span>】-&gt;stopWatch.start();</span><br><span class="line">                # 计时开始</span><br><span class="line">                SpringApplication【<span class="number">325</span>】-&gt;DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">                # 系统引导信息对应的上下文对象</span><br><span class="line">                SpringApplication【<span class="number">327</span>】-&gt;configureHeadlessProperty();</span><br><span class="line">                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）</span><br><span class="line">                    java.awt.headless=<span class="keyword">true</span></span><br><span class="line">                SpringApplication【<span class="number">328</span>】-&gt;SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">                # 获取当前注册的所有监听器</span><br><span class="line">                SpringApplication【<span class="number">329</span>】-&gt;listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line">                # 监听器执行了对应的操作步骤</span><br><span class="line">                SpringApplication【<span class="number">331</span>】-&gt;ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">                # 获取参数</span><br><span class="line">                SpringApplication【<span class="number">333</span>】-&gt;ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">                # 将前期读取的数据加载成了一个环境对象，用来描述信息</span><br><span class="line">                SpringApplication【<span class="number">333</span>】-&gt;configureIgnoreBeanInfo(environment);</span><br><span class="line">                # 做了一个配置，备用</span><br><span class="line">                SpringApplication【<span class="number">334</span>】-&gt;Banner printedBanner = printBanner(environment);</span><br><span class="line">                # 初始化logo</span><br><span class="line">                SpringApplication【<span class="number">335</span>】-&gt;context = createApplicationContext();</span><br><span class="line">                # 创建容器对象，根据前期配置的容器类型进行判定并创建</span><br><span class="line">                SpringApplication【<span class="number">363</span>】-&gt;context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">                # 设置启动模式</span><br><span class="line">                SpringApplication【<span class="number">337</span>】-&gt;prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">                # 对容器进行设置，参数来源于前期的设定</span><br><span class="line">                SpringApplication【<span class="number">338</span>】-&gt;refreshContext(context);</span><br><span class="line">                # 刷新容器环境</span><br><span class="line">                SpringApplication【<span class="number">339</span>】-&gt;afterRefresh(context, applicationArguments);</span><br><span class="line">                # 刷新完毕后做后处理</span><br><span class="line">                SpringApplication【<span class="number">340</span>】-&gt;stopWatch.stop();</span><br><span class="line">                # 计时结束</span><br><span class="line">                SpringApplication【<span class="number">341</span>】-&gt;<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">                # 判定是否记录启动时间的日志</span><br><span class="line">                SpringApplication【<span class="number">342</span>】-&gt;    <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">                # 创建日志对应的对象，输出日志信息，包含启动时间</span><br><span class="line">                SpringApplication【<span class="number">344</span>】-&gt;listeners.started(context);</span><br><span class="line">                # 监听器执行了对应的操作步骤</span><br><span class="line">                SpringApplication【<span class="number">345</span>】-&gt;callRunners(context, applicationArguments);</span><br><span class="line">                # 调用运行器</span><br><span class="line">                SpringApplication【<span class="number">353</span>】-&gt;listeners.running(context);</span><br><span class="line">                # 监听器执行了对应的操作步骤</span><br></pre></td></tr></table></figure>
<p>​		上述过程描述了 springboot 程序启动过程中做的所有的事情，这个时候好奇宝宝们就会提出一个问题。如果想干预 springboot 的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入 springboot 的启动流程呢？</p>
<p>​		遇到这样的问题，大部分技术是这样设计的，设计若干个标准接口，对应程序中的所有标准过程。当你想干预某个过程时，实现接口就行了。例如 spring 技术中 bean 的生命周期管理就是采用标准接口进行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Abc</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//销毁操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		springboot 启动过程由于存在着大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。那 springboot 如何解决这个问题呢？它采用了一种最原始的设计模式来解决这个问题，这就是监听器模式，使用监听器来解决这个问题。</p>
<p>​		springboot 将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：</p>
<ul>
<li>org.springframework.boot.context.event.ApplicationStartingEvent
<ul>
<li>应用启动事件，在应用运行但未进行任何处理时，将发送 ApplicationStartingEvent</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent
<ul>
<li>环境准备事件，当 Environment 被使用，且上下文创建之前，将发送 ApplicationEnvironmentPreparedEvent</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationContextInitializedEvent
<ul>
<li>上下文初始化事件</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationPreparedEvent
<ul>
<li>应用准备事件，在开始刷新之前，bean 定义被加载之后发送 ApplicationPreparedEvent</li>
</ul>
</li>
<li>org.springframework.context.event.ContextRefreshedEvent
<ul>
<li>上下文刷新事件</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationStartedEvent
<ul>
<li>应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 ApplicationStartedEvent</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationReadyEvent
<ul>
<li>应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 ApplicationReadyEvent，用于通知应用已经准备处理请求</li>
</ul>
</li>
<li>org.springframework.context.event.ContextClosedEvent（上下文关闭事件，对应容器关闭）</li>
</ul>
<p>​		上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户还可以根据需要自定义开发当前事件触发时要做的其他动作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设定监听器，在应用启动开始事件时进行功能追加</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationStartingEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationStartingEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//自定义事件处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		按照上述方案处理，用户就可以干预 springboot 启动过程的所有工作节点，设置自己的业务系统中独有的功能点。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 启动流程是先初始化容器需要的各种配置，并加载成各种对象，初始化容器时读取这些对象，创建容器</li>
<li>整体流程采用事件监听的机制进行过程控制，开发者可以根据需要自行扩展，添加对应的监听器绑定具体事件，就可以在事件触发位置执行开发者的业务代码</li>
</ol>
<h2 id="原理篇完结"><a class="markdownIt-Anchor" href="#原理篇完结">#</a> 原理篇完结</h2>
<p>​		原理篇到这里就要结束了，springboot2 整套课程的基础篇、实用篇和原理篇就全部讲完了。</p>
<p>​		原理篇个人感觉略微有点偷懒，怎么说呢？学习原理篇需要的前置铺垫知识太多，比如最后一节讲到启动流程时，看到 reflush 方法时我就想现在在看这套课程的小伙伴是否真的懂这个过程呢？但是如果把这些东西都讲了，那估计要补充的知识就太多了，就是将 spring 的很多知识加入到这里面重新讲解了，会出现喧宾夺主的现象。很纠结，(´・︵・`)</p>
<p>​		课程做到这里就要和各位小伙伴先 say 顾拜了，感谢各位小伙伴的支持，也欢迎各位小伙伴持续关注黑马程序员出品的各种视频教程。黑马程序员的每位老师做课程都是认真的，都是为了各位致力于 IT 研发事业的小伙伴能够学习之路上少遇沟沟坎坎，顺利到达成功的彼岸。</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>教程</tag>
        <tag>SpringBoot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot讲义-运维实用篇</title>
    <url>/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<h1 id="springboot运维实用篇"><a class="markdownIt-Anchor" href="#springboot运维实用篇">#</a> SpringBoot 运维实用篇</h1>
<h3 id="前言白嫖发言"><a class="markdownIt-Anchor" href="#前言白嫖发言">#</a> 前言（白嫖发言）</h3>
<p>​		这个笔记是从黑马老师那里嫖来的，放在这里是为了方便查看，没有商用的意思，转载请标明<strong>黑马程序员</strong>以及链接。</p>
<p>​		从此刻开始，咱们就要进入到实用篇的学习了。实用篇是在基础篇的根基之上，补全 SpringBoot 的知识图谱。比如在基础篇中只给大家讲了 yaml 的语法格式，但是具体写 yaml 文件的时候还有很多实用开发过程中的坑，这些在实用篇中都要进行学习。</p>
<p>​		实用篇共分为两块内容，分别是运维实用篇和开发实用篇。其实划分的标准是我自己制定的，因为这里面的知识有一些还是比较散的，做两个阶段的划分是为了更好的将同类知识点进行归类，帮助学习者找到知识之间的关联性，这样有助于知识的记忆存储转换，经过一系列的知识反复出现与强化练习，将临时记忆转换成永久性记忆。做课程嘛，不能仅以讲完为目标，要以学习者的学习收获为目标，这也是我这么多年教学秉承的基本理念。</p>
<p>​		下面就从运维实用篇开始讲，在运维实用篇中，我给学习者的定位是玩转配置，为开发实用篇中做各种技术的整合做好准备工作。与开发实用篇相比，运维实用篇的内容显得略微单薄，并且有部分知识模块在运维实用篇和开发实用篇中都要讲一部分，这些内容都后置到开发实用篇中了。废话不说了，先看看运维实用篇中都包含哪些内容：</p>
<ul>
<li>SpringBoot 程序的打包与运行</li>
<li>配置高级</li>
<li>多环境开发</li>
<li>日志</li>
</ul>
<p>​		下面开启第一部分 SpringBoot 程序打包与运行的学习</p>
<h2 id="yw-1springboot程序的打包与运行"><a class="markdownIt-Anchor" href="#yw-1springboot程序的打包与运行">#</a> YW-1.SpringBoot 程序的打包与运行</h2>
<p>​		刚开始做开发学习的小伙伴可能在有一个知识上面有错误的认知，我们天天写程序是在 Idea 下写的，运行也是在 Idea 下运行的。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211201091317258.png" alt="image-20211201091317258" style="zoom:67%;">
<p>​		但是实际开发完成后，我们的项目是不可能运行在自己的电脑上的。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211201091341645.png" alt="image-20211201091341645" style="zoom:67%;">
<p>​		我们以后制作的程序是运行在专用的服务器上的，简单说就是将你做的程序放在一台独立运行的电脑上，这台电脑要比你开发使用的计算机更专业，并且安全等级各个方面要远超过你现在的电脑。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211201091502040.png" alt="image-20211201091502040" style="zoom:67%;">
<p>​		那我们的程序如何放置在这台专用的电脑上呢，这就要将我们的程序先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。</p>
<ol>
<li>开发部门使用 Git、SVN 等版本控制工具上传工程到版本服务器</li>
<li>服务器使用版本控制工具下载工程</li>
<li>服务器上使用 Maven 工具在当前真机环境下重新构建项目</li>
<li>启动服务</li>
</ol>
<p>​		继续说我们的打包和运行过程。所谓打包指将程序转换成一个可执行的文件，所谓运行指不依赖开发环境执行打包产生的文件。上述两个操作都有对应的命令可以快速执行。</p>
<h3 id="程序打包"><a class="markdownIt-Anchor" href="#程序打包">#</a> <strong>程序打包</strong></h3>
<p>​		SpringBoot 程序是基于 Maven 创建的，在 Maven 中提供有打包的指令，叫做 package。本操作可以在 Idea 环境下执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn <span class="keyword">package</span></span><br></pre></td></tr></table></figure>
<p>​		打包后会产生一个与工程名类似的 jar 文件，其名称是由模块名 + 版本号 +.jar 组成的。</p>
<h3 id="程序运行"><a class="markdownIt-Anchor" href="#程序运行">#</a> <strong>程序运行</strong></h3>
<p>​		程序包打好以后，就可以直接执行了。在程序包所在路径下，执行指令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar 工程包名.jar</span><br></pre></td></tr></table></figure>
<p>​		执行程序打包指令后，程序正常运行，与在 Idea 下执行程序没有区别。</p>
<p>​		<font color="#ff0000"><b>特别关注</b></font>：如果你的计算机中没有安装 java 的 jdk 环境，是无法正确执行上述操作的，因为程序执行使用的是 java 指令。</p>
<p>​		<font color="#ff0000"><b>特别关注</b></font>：在使用向导创建 SpringBoot 工程时，pom.xml 文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>SpringBoot 工程可以基于 java 环境下独立运行 jar 文件启动服务</li>
<li>SpringBoot 工程执行 mvn 命令 package 进行打包</li>
<li>执行 jar 命令：java –jar 工程名.jar</li>
</ol>
<h3 id="springboot程序打包失败处理"><a class="markdownIt-Anchor" href="#springboot程序打包失败处理">#</a> SpringBoot 程序打包失败处理</h3>
<p>​		有些小伙伴打包以后执行会出现一些问题，导致程序无法正常执行，例如下面的现象</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211201094223991.png" alt="image-20211201094223991" style="zoom:67%;">
<p>​		要想搞清楚这个问题就要说说.jar 文件的工作机制了，知道了这个东西就知道如何避免此类问题的发生了。</p>
<p>​		搞 java 开发平时会接触很多 jar 包，比如 mysql 的驱动 jar 包，而上面我们打包程序后得到的也是一个 jar 文件。这个时候如果你使用上面的 java -jar 指令去执行 mysql 的驱动 jar 包就会出现上述不可执行的现象，而我们的 SpringBoot 项目为什么能执行呢？其实是因为打包方式不一样。</p>
<p>​		在 SpringBoot 工程的 pom.xml 中有下面这组配置，这组配置决定了打包出来的程序包是否可以执行。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		我们分别开启这段配置和注释掉这段配置分别执行两次打包，然后观察两次打包后的程序包的差别，共有 3 处比较明显的特征</p>
<ul>
<li>打包后文件的大小不同</li>
<li>打包后所包含的内容不同</li>
<li>打包程序中个别文件内容不同</li>
</ul>
<p>​		先看第一个现象，文件大小不同。带有配置时打包生成的程序包大小如下：</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211201095610270.png" alt="image-20211201095610270" style="zoom:150%;">
<p>​		不难看出，带有配置的程序包体积比不带配置的大了 30 倍，那这里面都有什么呢？能差这么多？下面看看里面的内容有什么区别。</p>
<p>​		<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211201101541267.png" alt="image-20211201101541267" style="zoom:50%;"><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211201101652868.png" alt="image-20211201101652868" style="zoom:50%;"></p>
<p>​		我们发现内容也完全不一样，仅有一个目录是一样的，叫做 META-INF。打开容量大的程序包中的 BOOT-INF 目录下的 classes 目录，我们发现其中的内容居然和容量小的程序包中的内容完全一样。</p>
<p>​		<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211201101805569.png" alt="image-20211201101805569" style="zoom:50%;"><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211201101652868.png" alt="image-20211201101652868" style="zoom:50%;"></p>
<p>​		原来大的程序包中除了包含小的程序包中的内容，还有别的东西。都有什么呢？回到 BOOT-INF 目录下，打开 lib 目录，里面显示了很多个 jar 文件。</p>
<p>​		<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211201102025791.png" alt="image-20211201102025791" style="zoom:50%;"></p>
<p>​		仔细翻阅不难发现，这些 jar 文件都是我们制作这个工程时导入的坐标对应的文件。大概可以想明白了，SpringBoot 程序为了让自己打包生成的程序可以独立运行，不仅将项目中自己开发的内容进行了打包，还把当前工程运行需要使用的 jar 包全部打包进来了。为什么这样做呢？就是为了可以独立运行。不依赖程序包外部的任何资源可以独立运行当前程序。这也是为什么大的程序包容量是小的程序包容量的 30 倍的主要原因。</p>
<p>​		再看看大程序包还有什么不同之处，在最外层目录包含一个 org 目录，进入此目录，目录名是 org\springframework\boot\loader，在里面可以找到一个<font color="#ff0000"><b>JarLauncher.class</b></font>的文件，先记得这个文件。再看这套目录名，明显是一个 Spring 的目录名，为什么要把 Spring 框架的东西打包到这个程序包中呢？不清楚。</p>
<p>​		回到两个程序包的最外层目录，查看名称相同的文件夹 META-INF 下都有一个叫做 MANIFEST.MF 的文件，但是大小不同，打开文件，比较内容区别</p>
<ul>
<li>
<p>小容量文件的 MANIFEST.MF</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Implementation-Title: springboot_08_ssmp</span><br><span class="line">Implementation-Version: <span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT</span><br><span class="line">Build-Jdk-Spec: <span class="number">1.8</span></span><br><span class="line">Created-By: Maven Jar Plugin <span class="number">3.2</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>大容量文件的 MANIFEST.MF</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx</span><br><span class="line">Implementation-Title: springboot_08_ssmp</span><br><span class="line">Implementation-Version: <span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT</span><br><span class="line">Spring-Boot-Layers-Index: BOOT-INF/layers.idx</span><br><span class="line">Start-Class: com.itheima.SSMPApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Build-Jdk-Spec: <span class="number">1.8</span></span><br><span class="line">Spring-Boot-Version: <span class="number">2.5</span><span class="number">.4</span></span><br><span class="line">Created-By: Maven Jar Plugin <span class="number">3.2</span><span class="number">.0</span></span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​		大文件中明显比小文件中多了几行信息，其中最后一行信息是 Main-Class: org.springframework.boot.loader.<font color="#ff0000"><b>JarLauncher</b></font>。这句话什么意思呢？如果使用 java -jar 执行此程序包，将执行 Main-Class 属性配置的类，这个类恰巧就是前面看到的那个文件。原来 SpringBoot 打包程序中出现 Spring 框架的东西是为这里服务的。而这个 org.springframework.boot.loader.<font color="#ff0000"><b>JarLauncher</b></font>类内部要查找 Start-Class 属性中配置的类，并执行对应的类。这个属性在当前配置中也存在，对应的就是我们的引导类类名。</p>
<p>​		现在这组设定的作用就搞清楚了</p>
<ol>
<li>SpringBoot 程序添加配置后会打出一个特殊的包，包含 Spring 框架部分功能，原始工程内容，原始工程依赖的 jar 包</li>
<li>首先读取 MANIFEST.MF 文件中的 Main-Class 属性，用来标记执行 java -jar 命令后运行的类</li>
<li>JarLauncher 类执行时会找到 Start-Class 属性，也就是启动类类名</li>
<li>运行启动类时会运行当前工程的内容</li>
<li>运行当前工程时会使用依赖的 jar 包，从 lib 目录中查找</li>
</ol>
<p>​		看来 SpringBoot 打出来了包为了能够独立运行，简直是煞费苦心，将所有需要使用的资源全部都添加到了这个包里。这就是为什么这个 jar 包能独立运行的原因。</p>
<p>​		再来看之前的报错信息：</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211201094223991.png" alt="image-20211201094223991" style="zoom:67%;">
<p>​		由于打包时没有使用那段配置，结果打包后形成了一个普通的 jar 包，在 MANIFEST.MF 文件中也就没有了 Main-Class 对应的属性了，所以运行时提示找不到主清单属性，这就是报错的原因。</p>
<p>​		上述内容搞清楚对我们编程意义并不大，但是对各位小伙伴理清楚 SpringBoot 工程独立运行的机制是有帮助的。其实整体过程主要是带着大家分析，如果以后遇到了类似的问题，多给自己提问，多问一个为什么，兴趣自己就可以独立解决问题了。</p>
<p><strong>总结</strong></p>
<ol>
<li>spring-boot-maven-plugin 插件用于将当前程序打包成一个可以独立运行的程序包</li>
</ol>
<h3 id="命令行启动常见问题及解决方案"><a class="markdownIt-Anchor" href="#命令行启动常见问题及解决方案">#</a> 命令行启动常见问题及解决方案</h3>
<p>​		各位小伙伴在 DOS 环境下启动 SpringBoot 工程时，可能会遇到端口占用的问题。给大家一组命令，不用深入学习，备用吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 查询端口</span><br><span class="line">netstat -ano</span><br><span class="line"># 查询指定端口</span><br><span class="line">netstat -ano |findstr <span class="string">&quot;端口号&quot;</span></span><br><span class="line"># 根据进程PID查询进程名称</span><br><span class="line">tasklist |findstr <span class="string">&quot;进程PID号&quot;</span></span><br><span class="line"># 根据PID杀死任务</span><br><span class="line">taskkill /F /PID <span class="string">&quot;进程PID号&quot;</span></span><br><span class="line"># 根据进程名称杀死任务</span><br><span class="line">taskkill -f -t -im <span class="string">&quot;进程名称&quot;</span></span><br></pre></td></tr></table></figure>
<p>​		关于打包与运行程序其实还有一系列的配置和参数，下面的内容中遇到再说，这里先开个头，知道如何打包和运行程序。</p>
<h3 id="springboot项目快速启动linux版"><a class="markdownIt-Anchor" href="#springboot项目快速启动linux版">#</a> SpringBoot 项目快速启动（Linux 版）</h3>
<p>​		其实对于 Linux 系统下的程序运行与 Windows 系统下的程序运行差别不大，命令还是那组命令，只不过各位小伙伴可能对 Linux 指令不太熟悉，结果就会导致各种各样的问题发生。比如防火墙如何关闭，IP 地址如何查询，JDK 如何安装等等。这里不作为重点内容给大家普及了，了解一下整体过程就行了。</p>
<h2 id="yw-2配置高级"><a class="markdownIt-Anchor" href="#yw-2配置高级">#</a> YW-2. 配置高级</h2>
<p>​		关于配置在基础篇讲过一部分，基础篇的配置总体上来说就是让各位小伙伴掌握配置的格式。比如配置文件如何写啊，写好的数据如何读取啊，都是基础的语法级知识。在实用篇中就要集中在配置的应用这个方面了，下面就开始配置高级相关内容的第一部分学习，为什么说第一部分，因为在开发实用篇中还有对应的配置高级知识要进行学习。</p>
<h3 id="yw-2-1临时属性设置"><a class="markdownIt-Anchor" href="#yw-2-1临时属性设置">#</a> YW-2-1. 临时属性设置</h3>
<p>​		目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是 8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了 8080 端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成 80。</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206095113771.png" alt="image-20211206095113771">             <img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206095524343.png" alt="image-20211206095524343">             <img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206095101581.png" alt="image-20211206095101581"></p>
<p>​		SpringBoot 提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java –jar springboot.jar –-server.port=<span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>​		上面的命令是启动 SpringBoot 程序包的命令，在命令输入完毕后，空一格，然后输入两个 - 号。下面按照属性名 = 属性值的形式添加对应参数就可以了。记得，这里的格式不是 yaml 中的书写格式，当属性存在多级名称时，中间使用点分隔，和 properties 文件中的属性格式完全相同。</p>
<p>​		如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java –jar springboot.jar –-server.port=<span class="number">80</span> --logging.level.root=debug</span><br></pre></td></tr></table></figure>
<h4 id="属性加载优先级"><a class="markdownIt-Anchor" href="#属性加载优先级">#</a> <strong>属性加载优先级</strong></h4>
<p>​		现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。地址奉上：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206100859236.png" alt="image-20211206100859236" style="zoom:67%;">
<p>​		我们可以看到，居然有 14 种配置的位置，而我们现在使用的是这里面的 2 个。第 3 条 Config data 说的就是使用配置文件，第 11 条 Command line arguments 说的就是使用命令行临时参数。而这 14 种配置的顺序就是 SpringBoot 加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。</p>
<p>​		比如你现在加载了一个 user.name 属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。</p>
<p>​		我在课程评论区看到小伙伴学习基础篇的时候问这个问题了，就是这个原因造成的。在 yaml 中配置了 user.name 属性值，然后读取出来的时候居然不是自己的配置值，<a href="http://xn--user-k84fuita7h16u3uk1nizyar90cda546lea4601afs1g0rh.name">因为在系统属性中有一个属性叫做 user.name</a>，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是 5 号，高于 3 号，<a href="http://xn--SpringBootuser-9z9vsyw87bww6bbbpp1j67ybr4i4wi4pak9i275m9hk.name">所以 SpringBoot 最终会加载系统配置属性 user.name</a>。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用 jar 命令启动 SpringBoot 工程时可以使用临时属性替换配置文件中的属性</li>
<li>临时属性添加方式：java –jar 工程名.jar –- 属性名 = 值</li>
<li>多个临时属性之间使用空格分隔</li>
<li>临时属性必须是当前 boot 工程支持的属性，否则设置无效</li>
</ol>
<h4 id="开发环境中使用临时属性"><a class="markdownIt-Anchor" href="#开发环境中使用临时属性">#</a> 开发环境中使用临时属性</h4>
<p>​		临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是 Idea 界面下如何操作了。</p>
<p>​		打开 SpringBoot 引导类的运行界面，在里面找到配置项。其中 Program arguments 对应的位置就是添加临时属性的，可以加几个试试效果。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206101947622.png" alt="image-20211206101947622" style="zoom:80%;">
<p>​		做到这里其实可以产生一个思考了，如果对 java 编程熟悉的小伙伴应该知道，我们运行 main 方法的时候，如果想使用 main 方法的参数，也就是下面的 args 参数，就是在上面这个位置添加的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		原来是这样，通过这个 args 就可以获取到参数。再来看我们的引导类是如何书写的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(SSMPApplication.class,args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		这个 args 参数居然传递给了 run 方法，看来在 Idea 中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个 args 是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样外部临时属性就无法进入到 SpringBoot 程序中了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(SSMPApplication.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arg = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">    arg[<span class="number">0</span>] = <span class="string">&quot;--server.port=8082&quot;</span>;</span><br><span class="line">    SpringApplication.run(SSMPApplication.class, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>启动 SpringBoot 程序时，可以选择是否使用命令行属性为 SpringBoot 程序传递启动属性</li>
</ol>
<p><strong>思考</strong></p>
<p>​		现在使用临时属性可以在启动项目前临时更改配置了，但是新的问题又出来了。临时属性好用是好用，就是写的多了会很麻烦。比如我现在有个需求，上线的时候使用临时属性配置 20 个值，这下可麻烦了，能不能搞得简单点，集中管理一下呢？比如说搞个文件，加载指定文件？还真可以。怎么做呢？咱们下一节再说。</p>
<h3 id="yw-2-2配置文件分类"><a class="markdownIt-Anchor" href="#yw-2-2配置文件分类">#</a> YW-2-2. 配置文件分类</h3>
<p>​		SpringBoot 提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这一节要说说配置文件了。其实这个配置文件我们一直在使用，只不过我们用的是 SpringBoot 提供的 4 级配置文件中的其中一个级别。4 个级别分别是：</p>
<ul>
<li>类路径下配置文件（一直使用的是这个，也就是 resources 目录中的 application.yml 文件）</li>
<li>类路径下 config 目录下配置文件</li>
<li>程序包所在目录中配置文件</li>
<li>程序包所在目录中 config 目录下配置文件</li>
</ul>
<p>​		好复杂，一个一个说。其实上述 4 种文件是提供给你了 4 种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4 种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入 4 个文件我都有，里面都有一样的配置，谁生效的问题。上面 4 个文件的加载优先顺序为</p>
<ol>
<li>file ：config/application.yml <strong>【最高】</strong></li>
<li>file ：application.yml</li>
<li>classpath：config/application.yml</li>
<li>classpath：application.yml  <strong>【最低】</strong></li>
</ol>
<p>​		那为什么设计这种多种呢？说一个最典型的应用吧。</p>
<ul>
<li>场景 A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用 4 这个级别，也就是之前一直用的 application.yml。</li>
<li>场景 B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。</li>
<li>场景 C：测试完了，一切 OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景 B 中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？</li>
</ul>
<p>​		解决方案很简单，用上面的 3 这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为 config 目录中的配置加载优先级比你的高，所以配置项如果和级别 4 里面的内容相同就覆盖了，这样是不是很简单？</p>
<p>​		级别 1 和 2 什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。</p>
<p><strong>总结</strong></p>
<ol>
<li>
<p>配置文件分为 4 种</p>
<ul>
<li>项目类路径配置文件：服务于开发人员本机开发与测试</li>
<li>项目类路径 config 目录中配置文件：服务于项目经理整体调控</li>
<li>工程路径配置文件：服务于运维人员配置涉密线上环境</li>
<li>工程路径 config 目录中配置文件：服务于运维经理整体调控</li>
</ul>
</li>
<li>
<p>多层级配置文件间的属性采用叠加并覆盖的形式作用于程序</p>
</li>
</ol>
<h3 id="yw-2-3自定义配置文件"><a class="markdownIt-Anchor" href="#yw-2-3自定义配置文件">#</a> YW-2-3. 自定义配置文件</h3>
<p>​		之前咱们做配置使用的配置文件都是 application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我 2020 年 4 月 1 日搞活动，走了一组配置，2020 年 5 月 1 日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。</p>
<p>​		自定义配置文件方式有如下两种：</p>
<p><strong>方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名</strong></p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206105548238.png" alt="image-20211206105548238" style="zoom:67%;">
<p><strong>方式二：使用临时属性设置配置文件路径，这个是全路径名</strong></p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206105716450.png" alt="image-20211206105716450" style="zoom:67%;">
<p>​		也可以设置加载多个配置文件</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206105750285.png" alt="image-20211206105750285" style="zoom:67%;">
<p>​		<a href="http://xn--spring-9m7iglw9hpv0ctyiphst29bh8d.config.name">使用的属性一个是 spring.config.name</a>，另一个是 spring.config.location，这个一定要区别清楚。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		我们现在研究的都是 SpringBoot 单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于 SpringCloud 技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。这里不再说这些了，后面再讲这些东西。</p>
<p><strong>总结</strong></p>
<ol>
<li>配置文件可以修改名称，通过启动参数设定</li>
<li>配置文件可以修改路径，通过启动参数设定</li>
<li>微服务开发中配置文件通过配置中心进行设置</li>
</ol>
<h2 id="yw-3多环境开发"><a class="markdownIt-Anchor" href="#yw-3多环境开发">#</a> YW-3. 多环境开发</h2>
<p>​		讲的内容距离线上开发越来越近了，下面说一说多环境开发问题。</p>
<p>​		什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾 3 种环境设置，开发环境 —— 自己用的，测试环境 —— 自己公司用的，生产环境 —— 甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206110958819.png" alt="image-20211206110958819" style="zoom:67%;">
<h3 id="yw-3-1多环境开发yaml单一文件版"><a class="markdownIt-Anchor" href="#yw-3-1多环境开发yaml单一文件版">#</a> YW-3-1. 多环境开发（yaml 单一文件版）</h3>
<p>​		那什么是多环境开发？就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>​		如何想设计两组环境呢？中间使用三个减号分隔开</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>
<p>​		如何区分两种环境呢？起名字呗</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">pro</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>
<p>​		那用哪一个呢？设置默认启动哪个就可以了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">		<span class="attr">active:</span> <span class="string">pro</span>		<span class="comment"># 启动pro</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">pro</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>
<p>​		就这么简单，再多来一组环境也 OK</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">		<span class="attr">active:</span> <span class="string">pro</span>		<span class="comment"># 启动pro</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">pro</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">81</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>
<p>​		其中关于环境名称定义上述格式是过时格式，标准格式如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">config:</span></span><br><span class="line">    	<span class="attr">activate:</span></span><br><span class="line">        	<span class="attr">on-profile:</span> <span class="string">pro</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>多环境开发需要设置若干种常用环境，例如开发、生产、测试环境</li>
<li>yaml 格式中设置多环境使用 — 区分环境设置边界</li>
<li>每种环境的区别在于加载的配置属性不同</li>
<li>启用某种环境时需要指定启动时使用该环境</li>
</ol>
<h3 id="yw-3-2多环境开发yaml多文件版"><a class="markdownIt-Anchor" href="#yw-3-2多环境开发yaml多文件版">#</a> YW-3-2. 多环境开发（yaml 多文件版）</h3>
<p>​		将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。</p>
<p><strong>主配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">		<span class="attr">active:</span> <span class="string">pro</span>		<span class="comment"># 启动pro</span></span><br></pre></td></tr></table></figure>
<p><strong>环境配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>​		环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。</p>
<p><strong>application-pro.yaml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p><strong>application-dev.yaml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>
<p>​		文件的命名规则为：application - 环境名.yml。</p>
<p>​		在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。</p>
<ul>
<li>主配置文件中设置公共配置（全局）</li>
<li>环境分类配置文件中常用于设置冲突属性（局部）</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>
<p>可以使用独立配置文件定义环境属性</p>
</li>
<li>
<p>独立配置文件便于线上系统维护更新并保障系统安全性</p>
</li>
</ol>
<h3 id="yw-3-3多环境开发properties多文件版"><a class="markdownIt-Anchor" href="#yw-3-3多环境开发properties多文件版">#</a> YW-3-3. 多环境开发（properties 多文件版）</h3>
<p>​		SpringBoot 最早期提供的配置文件格式是 properties 格式的，这种格式的多环境配置也了解一下吧。</p>
<p><strong>主配置文件</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">pro</span></span><br></pre></td></tr></table></figure>
<p><strong>环境配置文件</strong></p>
<p><strong>application-pro.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure>
<p><strong>application-dev.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">81</span></span><br></pre></td></tr></table></figure>
<p>​		文件的命名规则为：application - 环境名.properties。</p>
<p><strong>总结</strong></p>
<ol>
<li>properties 文件多环境配置仅支持多文件格式</li>
</ol>
<h3 id="yw-3-4多环境开发独立配置文件书写技巧"><a class="markdownIt-Anchor" href="#yw-3-4多环境开发独立配置文件书写技巧">#</a> YW-3-4. 多环境开发独立配置文件书写技巧</h3>
<p>​		作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。</p>
<p><strong>准备工作</strong></p>
<p>​		将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下</p>
<ul>
<li>application-devDB.yml</li>
<li>application-devRedis.yml</li>
<li>application-devMVC.yml</li>
</ul>
<p><strong>使用</strong></p>
<p>​		使用 include 属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">    	<span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">devDB,devRedis,devMVC</span></span><br></pre></td></tr></table></figure>
<p>​		比较一下，现在相当于加载 dev 配置时，再加载对应的 3 组配置，从结构上就很清晰，用了什么，对应的名称是什么</p>
<p><strong>注意</strong></p>
<p>​		当主环境 dev 与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效</p>
<p><strong>改良</strong></p>
<p>​		但是上面的设置也有一个问题，比如我要切换 dev 环境为 pro 时，include 也要修改。因为 include 属性只能使用一次，这就比较麻烦了。SpringBoot 从 2.4 版开始使用 group 属性替代 include 属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">    	<span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">        <span class="attr">group:</span></span><br><span class="line">        	<span class="attr">&quot;dev&quot;:</span> <span class="string">devDB,devRedis,devMVC</span></span><br><span class="line">      		<span class="attr">&quot;pro&quot;:</span> <span class="string">proDB,proRedis,proMVC</span></span><br><span class="line">      		<span class="attr">&quot;test&quot;:</span> <span class="string">testDB,testRedis,testMVC</span></span><br></pre></td></tr></table></figure>
<p>​		现在再来看，如果切换 dev 到 pro，只需要改一下是不是就结束了？完美！</p>
<p><strong>总结</strong></p>
<ol>
<li>多环境开发使用 group 属性设置配置文件分组，便于线上维护管理</li>
</ol>
<h3 id="yw-3-5多环境开发控制"><a class="markdownIt-Anchor" href="#yw-3-5多环境开发控制">#</a> YW-3-5. 多环境开发控制</h3>
<p>​		多环境开发到这里基本上说完了，最后说一个冲突问题。就是 maven 和 SpringBoot 同时设置多环境的话怎么搞。</p>
<p>​		要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。</p>
<p>​		maven 是做什么的？项目构建管理的，最终生成代码包的，SpringBoot 是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠 maven 来管理整个工程，所以 SpringBoot 应该听 maven 的。整个确认后下面就好做了。大体思想如下：</p>
<ul>
<li>先在 maven 环境中设置用什么具体的环境</li>
<li>在 SpringBoot 中读取 maven 设置的环境即可</li>
</ul>
<p><strong>maven 中设置多环境（使用属性方式区分环境）</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>		<span class="comment">&lt;!--默认启动环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>SpringBoot 中读取 maven 设置值</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">    	<span class="attr">active:</span> <span class="string">@profile.active@</span></span><br></pre></td></tr></table></figure>
<p>​		上面的 @属性名 @就是读取 maven 中配置的属性值的语法格式。</p>
<p><strong>总结</strong></p>
<ol>
<li>当 Maven 与 SpringBoot 同时对多环境进行控制时，以 Mavn 为主，SpringBoot 使用 @…@占位符读取 Maven 对应的配置属性值</li>
<li>基于 SpringBoot 读取 Maven 配置属性的前提下，如果在 Idea 下测试工程时 pom.xml 每次更新需要手动 compile 方可生效</li>
</ol>
<h2 id="yw-4日志"><a class="markdownIt-Anchor" href="#yw-4日志">#</a> YW-4. 日志</h2>
<p>​		运维篇最后一部分我们来聊聊日志，日志大家不陌生，简单介绍一下。日志其实就是记录程序日常运行的信息，主要作用如下：</p>
<ul>
<li>编程期调试代码</li>
<li>运营期记录信息</li>
<li>记录日常运营重要信息（峰值流量、平均响应时长……）</li>
<li>记录应用报错信息（错误堆栈）</li>
<li>记录运维过程数据（扩容、宕机、报警……）</li>
</ul>
<p>​		或许各位小伙伴并不习惯于使用日志，没关系，慢慢多用，习惯就好。想进大厂，这是最基本的，别去面试的时候说没用过，完了，没机会了。</p>
<h4 id="yw-4-1代码中使用日志工具记录日志"><a class="markdownIt-Anchor" href="#yw-4-1代码中使用日志工具记录日志">#</a> YW-4-1. 代码中使用日志工具记录日志</h4>
<p>​		日志的使用格式非常固定，直接上操作步骤：</p>
<p><strong>步骤①</strong>：添加日志记录操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> <span class="keyword">extends</span> <span class="title">BaseClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(BookController.class);</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;debug...&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;info...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warn...&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springboot is running...2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		上述代码中 log 对象就是用来记录日志的对象，下面的 log.debug，log.info 这些操作就是写日志的 API 了。</p>
<p><strong>步骤②</strong>：设置日志输出级别</p>
<p>​		日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为 6 种，分别是：</p>
<ul>
<li>TRACE：运行堆栈信息，使用率低</li>
<li>DEBUG：程序员调试代码使用</li>
<li>INFO：记录运维过程数据</li>
<li>WARN：记录运维过程报警数据</li>
<li>ERROR：记录错误堆栈信息</li>
<li>FATAL：灾难信息，合并计入 ERROR</li>
</ul>
<p>​		一般情况下，开发时候使用 DEBUG，上线后使用 INFO，运维信息记录使用 WARN 即可。下面就设置一下日志级别：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>​		这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志级别，root表示根节点，即整体应用日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">level:</span></span><br><span class="line">    	<span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>
<p>​		还可以再设置更细粒度的控制</p>
<p><strong>步骤③</strong>：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="comment"># 设置日志组</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">    	<span class="comment"># 自定义组名，设置当前组中所包含的包</span></span><br><span class="line">        <span class="attr">ebank:</span> <span class="string">com.itheima.controller</span></span><br><span class="line">    <span class="attr">level:</span></span><br><span class="line">    	<span class="attr">root:</span> <span class="string">warn</span></span><br><span class="line">        <span class="comment"># 为对应组设置日志级别</span></span><br><span class="line">        <span class="attr">ebank:</span> <span class="string">debug</span></span><br><span class="line">    	<span class="comment"># 为对包设置日志级别</span></span><br><span class="line">        <span class="attr">com.itheima.controller:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>
<p>​		说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。</p>
<p><strong>总结</strong></p>
<ol>
<li>日志用于记录开发调试与运维过程消息</li>
<li>日志的级别共 6 种，通常使用 4 种即可，分别是 DEBUG，INFO,WARN,ERROR</li>
<li>可以通过日志组或代码包的形式进行日志显示级别的控制</li>
</ol>
<h4 id="教你一招优化日志对象创建代码"><a class="markdownIt-Anchor" href="#教你一招优化日志对象创建代码">#</a> 教你一招：优化日志对象创建代码</h4>
<p>​		写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的 lombok 技术给我们提供的工具类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> <span class="keyword">extends</span> <span class="title">BaseClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(BookController.class);	<span class="comment">//这一句可以不写了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		导入 lombok 后使用注解搞定，日志对象名为 log</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>		<span class="comment">//这个注解替代了下面那一行</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> <span class="keyword">extends</span> <span class="title">BaseClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(BookController.class);	<span class="comment">//这一句可以不写了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>基于 lombok 提供的 @Slf4j 注解为类快速添加日志对象</li>
</ol>
<h4 id="yw-4-2日志输出格式控制"><a class="markdownIt-Anchor" href="#yw-4-2日志输出格式控制">#</a> YW-4-2. 日志输出格式控制</h4>
<p>​		日志已经能够记录了，但是目前记录的格式是 SpringBoot 给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206123431222.png" alt="image-20211206123431222"></p>
<p>​		对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID 与线程名用于做精准分析。了解这些信息后就可以 DIY 日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">pattern:</span></span><br><span class="line">    	<span class="attr">console:</span> <span class="string">&quot;%d %clr(%p) --- [%16t] %clr(%-40.40c)&#123;cyan&#125; : %m %n&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>日志输出格式设置规则</li>
</ol>
<h4 id="yw-4-3日志文件"><a class="markdownIt-Anchor" href="#yw-4-3日志文件">#</a> YW-4-3. 日志文件</h4>
<p>​		日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。</p>
<p>​		对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。这里主要研究日志文件如何记录。</p>
<p>​		记录日志到文件中格式非常简单，设置日志文件名即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">file:</span></span><br><span class="line">    	<span class="attr">name:</span> <span class="string">server.log</span></span><br></pre></td></tr></table></figure>
<p>​		虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">logback:</span></span><br><span class="line">    	<span class="attr">rollingpolicy:</span></span><br><span class="line">        	<span class="attr">max-file-size:</span> <span class="string">3KB</span></span><br><span class="line">            <span class="attr">file-name-pattern:</span> <span class="string">server.%d&#123;yyyy-MM-dd&#125;.%i.log</span></span><br></pre></td></tr></table></figure>
<p>​		以上格式是基于 logback 日志技术设置每日日志文件的设置格式，要求容量到达 3KB 以后就转存信息到第二个文件中。文件命名规则中的 % d 标识日期，% i 是一个递增变量，用于区分日志文件。</p>
<p><strong>总结</strong></p>
<ol>
<li>日志记录到文件</li>
<li>日志文件格式设置</li>
</ol>
<h2 id="运维实用篇完结"><a class="markdownIt-Anchor" href="#运维实用篇完结">#</a> 运维实用篇完结</h2>
<p>​		运维实用篇到这里就要先告一段落了，为什么不说结束呢？因为运维篇中还有一些知识，但是现在讲解过于分散了。所以要把这些知识与开发实用篇的知识结合在一起讲，也是本课程的教学设计的体现。</p>
<p>​		在整体运维实用篇中带着大家学习了 4 块内容，首先学习了如何运行 SpringBoot 程序，也就是程序的打包与运行，接下来对配置进行了升级学习，不再局限在配置文件中进行设置，通过临时属性，外部配置文件对项目的配置进行管控。在多环境开发中给大家介绍了多种多环境开发的格式，其实掌握一种即可，此外还给大家讲了多环境开发的一些技巧以及与 maven 的冲突解决方案。最后给大家介绍了日志系统，老实说日志这里讲的相当的潦草，因为大部分日志相关的知识都不应该在这门课中学习，这里只是告诉大家如何整合实用而已。</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>教程</tag>
        <tag>SpringBoot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的中序遍历</title>
    <url>/passages/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="二叉树的中序遍历"><a class="markdownIt-Anchor" href="#二叉树的中序遍历">#</a> 二叉树的中序遍历</h1>
<p>​		大一 -&gt; 大二暑期算法作业</p>
<p>​		<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>
<h2 id="看到题目的感想"><a class="markdownIt-Anchor" href="#看到题目的感想">#</a> 看到题目的感想</h2>
<p>​		被离散数学<strong>折磨</strong>之后看见树就会想到离散数学，虽然学习离散数学的时候老师<strong>教过中序遍历</strong>，但是看到这个题的时候还是<strong>没有想起来</strong>中序遍历是个啥，索性就去搜索了一下（快进到被老师打死）。</p>
<p>​		附上百度百科链接：</p>
<p>​		<strong>中序遍历：<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">https://baike.baidu.com/item/ 中序遍历</a></strong></p>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2>
<p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p>
<p>输入：root = [1,null,2,3]<br>
 输出：[1,3,2]</p>
<p><strong>示例 2：</strong></p>
<p>输入：root = []<br>
 输出：[]</p>
<p><strong>示例 3：</strong></p>
<p>输入：root = [1]<br>
 输出：[1]</p>
<p><strong>示例 4：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img"></p>
<p>输入：root = [1,2]<br>
 输出：[2,1]</p>
<p><strong>示例 5：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img"></p>
<p>输入：root = [1,null,2]<br>
 输出：[1,2]</p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>
 - 100 &lt;= Node.val &lt;= 100</p>
<p>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a></p>
<h2 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答">#</a> 题目解答</h2>
<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>
<h3 id="1递归算法"><a class="markdownIt-Anchor" href="#1递归算法">#</a> 1. 递归算法</h3>
<p>利用递归的思想解题也是老朋友了，在之前的算法题里面有过接触，所以并不是很难理解。</p>
<h4 id="1解题思路"><a class="markdownIt-Anchor" href="#1解题思路">#</a> （1）解题思路</h4>
<p>​		在解题的时候，了解到了一个名叫 <strong>vector</strong> 的东西，可以理解为 C++ 和 Java 中的一种动态数组。记得第一次听到这个名词的时候还是在翁恺老师的《C 语言程序设计》这门课上听到的，想想还真是怀念。（跑远了</p>
<p>附上一些链接（<strong>配合梯子一起食用</strong>）：</p>
<p><strong>vector：内存在堆上</strong></p>
<p>​    <strong>注意：vector 每添加一次都会把之前的全复制一遍，所以效率并不高。</strong></p>
<p>​    <strong>1）</strong> <strong><a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-160">https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-160</a>  来源：Microsoft C++、C 和汇编程序文档</strong></p>
<p>​    <strong>2） <a href="https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/package-summary.html">https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/jdk/incubator/vector/package-summary.html</a>  来源：Java 官方文档里的包（纯英文比较难顶</strong></p>
<p>​    <strong>3） <a href="https://baike.baidu.com/item/Vector/3330482">https://baike.baidu.com/item/Vector/3330482</a> 来源：百度百科</strong></p>
<p>​    <strong>4） <a href="https://www.w3cschool.cn/cpp/cpp-i6da2pq0.html">https://www.w3cschool.cn/cpp/cpp-i6da2pq0.html</a>  来源：某不知名 C++ 教程</strong></p>
<p>​    <strong>《C 语言程序设计》：<a href="https://www.icourse163.org/learn/ZJU-9001?tid=9001#/learn/announce">https://www.icourse163.org/learn/ZJU-9001?tid=9001#/learn/announce</a>  来源：中国大学 MOOC</strong></p>
<p>​		本题可以通过递归思想对给出的二叉树的<strong>左子树、根节点、右子树依次进行遍历（中序遍历）</strong>，并将各个数据存放在设置好的 vector<int>中（由于 vector 是<strong>动态分配内存</strong>的，所以比用担心大小会不够用），最后即可得到该二叉树的中序遍历。</int></p>
<h4 id="2代码"><a class="markdownIt-Anchor" href="#2代码">#</a> （2）代码</h4>
<p>​		解题代码如下（<strong>配合题目链接食用</strong>）：</p>
<h5 id="c"><a class="markdownIt-Anchor" href="#c">#</a> <strong>C++</strong></h5>
<p><strong>有一种比较好用的 C++ 容器，比 vector 好用，只是不能自增。（本题未使用）</strong></p>
<p><strong>array：内存在栈上</strong></p>
<p><strong>array： <a href="http://c.biancheng.net/view/6688.html">http://c.biancheng.net/view/6688.html</a> 来源：C 语言中文网</strong></p>
<p><strong>array： <a href="https://www.bilibili.com/video/BV18b4y1X7EB?from=search&amp;seid=11718690349134275715">https://www.bilibili.com/video/BV18b4y1X7EB?from=search&amp;seid=11718690349134275715</a> 来源：哔哩哔哩（是一个油管的小哥哥，讲的很棒，圈粉了）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123; <span class="comment">// 如果碰到空节点，说明该部分遍历已完成，return出去</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, res); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将该节点的值增加在动态数组末尾</span></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, res); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 新建一个int类型的vector,用来存放遍历结果</span></span><br><span class="line">        <span class="built_in">inorder</span>(root, res); <span class="comment">// 从根节点root开始遍历，依次放入值</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回遍历结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><img src="https://img12.360buyimg.com/ddimg/jfs/t1/178612/13/21226/22498/61284220E9e541099/4f61f1de25898a99.png" alt="image-20210827092120481.png"></li>
</ul>
<h5 id="java"><a class="markdownIt-Anchor" href="#java">#</a> <strong>Java</strong></h5>
<p>List &amp; ArrayList 是 Java 中的一种列表。</p>
<p><strong>List &amp; ArrayList：<a href="https://www.jianshu.com/p/25aa92f8d681">https://www.jianshu.com/p/25aa92f8d681</a> 来源：简书</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// 新建Integer的List来存放数值</span></span><br><span class="line">        inorder(root, res); <span class="comment">// 从根节点root开始遍历，依次将数值放入</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回遍历结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 如果碰到空节点，说明该部分遍历已完成，return出去</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, res); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        res.add(root.val); <span class="comment">// 将该节点的值增加在末尾</span></span><br><span class="line">        inorder(root.right, res); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img14.360buyimg.com/ddimg/jfs/t1/200702/31/3771/22855/6128423eE4f6965f0/3afc9e3dfe9a422d.png" alt="image-20210827092151479.png"></p>
<h5 id="c来自题解"><a class="markdownIt-Anchor" href="#c来自题解">#</a> <strong>C（来自题解）</strong></h5>
<p>（C 语言中的动态数组不会玩，于是把题解拿过来）</p>
<p><strong>C 语言动态数组 <a href="https://www.runoob.com/w3cnote/c-dynamic-array.html">https://www.runoob.com/w3cnote/c-dynamic-array.html</a> 来源：菜鸟教程</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* res, <span class="keyword">int</span>* resSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root-&gt;left, res, resSize);</span><br><span class="line">    res[(*resSize)++] = root-&gt;val;</span><br><span class="line">    inorder(root-&gt;right, res, resSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">inorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">501</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    inorder(root, res, returnSize);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h4 id="3总结"><a class="markdownIt-Anchor" href="#3总结">#</a> （3）总结</h4>
<p>​		利用递归思想来解题还是比较舒服的，也很好用，适合我这种菜鸡。</p>
<h3 id="2迭代算法"><a class="markdownIt-Anchor" href="#2迭代算法">#</a> 2. 迭代算法</h3>
<p><strong>关于迭代算法的基本思想：</strong></p>
<p><strong>迭代算法 <a href="https://www.cnblogs.com/cs-whut/p/11024564.html">https://www.cnblogs.com/cs-whut/p/11024564.html</a> 来源：博客园</strong></p>
<p>​		迭代算法之前没有接触过，上手有点看不懂。</p>
<h4 id="1解题思路-2"><a class="markdownIt-Anchor" href="#1解题思路-2">#</a> （1）解题思路</h4>
<p>​		通过迭代 + 栈模型来清楚的展现解题流程（题解中有动画展示，配合食用比较好理解）。</p>
<h4 id="2代码-2"><a class="markdownIt-Anchor" href="#2代码-2">#</a> （2）代码</h4>
<p>​		解题代码如下（<strong>配合题目链接食用</strong>）：</p>
<h5 id="c-2"><a class="markdownIt-Anchor" href="#c-2">#</a> <strong>C++</strong></h5>
<p>C++ 的栈：</p>
<p><strong>stack <a href="http://c.biancheng.net/view/478.html">http://c.biancheng.net/view/478.html</a> 来源：C 语言中文网</strong></p>
<p><strong>stack <a href="https://www.apiref.com/cpp-zh/cpp/container/stack.html">https://www.apiref.com/cpp-zh/cpp/container/stack.html</a> 来源：C++ 文档</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 新建一个int类型的vector,用来存放遍历结果</span></span><br><span class="line">        stack&lt;TreeNode*&gt; stk; <span class="comment">// 新建栈</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123; <span class="comment">// 节点有数值 或 栈不为空</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123; <span class="comment">// 当节点有值时</span></span><br><span class="line">                stk.<span class="built_in">push</span>(root); <span class="comment">// 数据入栈</span></span><br><span class="line">                root = root-&gt;left; <span class="comment">// 访问左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>(); <span class="comment">// 找到栈顶数据的节点</span></span><br><span class="line">            <span class="comment">// top()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// pop()：弹出栈顶元素。</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 在vector末尾添加当前节点数据</span></span><br><span class="line">            root = root-&gt;right; <span class="comment">// 访问右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/191173/7/19840/22319/6128425eE22b3e07d/1ca7845e69631535.png" alt="image-20210827092218700.png"></p>
<h5 id="java-2"><a class="markdownIt-Anchor" href="#java-2">#</a> <strong>Java</strong></h5>
<p>Java 的栈：</p>
<p><strong>Deque： <a href="https://www.jianshu.com/p/d78a7c982edb">https://www.jianshu.com/p/d78a7c982edb</a> 来源：简书</strong></p>
<p><strong>stack：</strong>**</p>
<p><strong>（1） <a href="https://www.javatpoint.com/java-stack">https://www.javatpoint.com/java-stack</a>  来源：某 Java 文档</strong></p>
<p><strong>（2） <a href="https://blog.csdn.net/YQYnsmile/article/details/78457539">https://blog.csdn.net/YQYnsmile/article/details/78457539</a>  来源：屑 C 某某 N</strong></p>
<p><strong>（3） <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Stack.html">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Stack.html</a>  来源：某全英文 Java 文档</strong></p>
<p>Deque 可以作为堆栈（LIFO 后进先出），此接口优于传统 Stack 类的使用。</p>
<p><strong>Stack 和 Deque 方法的比较</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">栈方法</th>
<th style="text-align:center">等效 Deque 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">push(e)</td>
<td style="text-align:center">addFirst(e)</td>
</tr>
<tr>
<td style="text-align:left">pop()</td>
<td style="text-align:center">removeFirst()</td>
</tr>
<tr>
<td style="text-align:left">peek()</td>
<td style="text-align:center">peekFirst()</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// 新建List来保存数据</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); <span class="comment">// 新建栈</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stk.isEmpty()) &#123; <span class="comment">// 节点有数值 或 栈不为空</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123; <span class="comment">// 节点有数值时</span></span><br><span class="line">                stk.push(root); <span class="comment">// 将数据放入栈</span></span><br><span class="line">                root = root.left; <span class="comment">// 访问左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop(); <span class="comment">// pop()：弹出栈顶元素。</span></span><br><span class="line">            res.add(root.val); <span class="comment">// 在List末尾添加当前节点数据</span></span><br><span class="line">            root = root.right; <span class="comment">// 访问右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/177616/31/21117/22717/6128427aE9968827a/f401017322512ef0.png" alt="image-20210827092339328.png"></p>
<h5 id="c来自题解-2"><a class="markdownIt-Anchor" href="#c来自题解-2">#</a> <strong>C</strong>（来自题解）</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">inorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">501</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>** <span class="title">stk</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode*) * <span class="number">501</span>);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            stk[top++] = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk[--top];</span><br><span class="line">        res[(*returnSize)++] = root-&gt;val;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h4 id="3总结-2"><a class="markdownIt-Anchor" href="#3总结-2">#</a> （3）总结</h4>
<p>​		利用迭代算法来解题的思想还没有怎么接触过没上手感觉比较难。（<strong>还是递归香</strong>    <strong>确信</strong>）</p>
<h3 id="3morris-中序遍历来自题解"><a class="markdownIt-Anchor" href="#3morris-中序遍历来自题解">#</a> 3.Morris 中序遍历（来自题解）</h3>
<p>​		这个就是真的闻所未闻了，看了题解，决定搬过来</p>
<h4 id="1思路与算法"><a class="markdownIt-Anchor" href="#1思路与算法">#</a> （1）思路与算法</h4>
<ol>
<li>
<p><strong>Morris 遍历算法</strong>是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O (1) O (1)。</p>
<p><strong>Morris 遍历算法</strong>整体步骤如下（假设当前遍历到的节点为 xx）：</p>
</li>
<li>
<p>如果 xx 无左孩子，先将 xx 的值加入答案数组，再访问 xx 的右孩子，即 x  =  x . right。<br>
如果 xx 有左孩子，则找到 xx 左子树上最右的节点（<strong>即左子树中序遍历的最后一个节点，xx 在中序遍历中的前驱节点</strong>），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。</p>
<ul>
<li>如果 predecessor 的右孩子为空，则将其右孩子指向 xx，然后访问 xx 的左孩子，即  x  =  x . left。</li>
<li>如果 predecessor 的右孩子不为空，则此时其右孩子指向 xx，说明我们已经遍历完 xx 的左子树，我们将 predecessor 的右孩子置空，将 xx 的值加入答案数组，然后访问 xx 的右孩子，即  x  =  x . right。</li>
</ul>
</li>
<li>
<p>重复上述操作，直至访问完整棵树。</p>
<p>4. 其实整个过程我们就多做一步：假设当前遍历到的节点为 xx，将 xx 的左子树中最右边的节点的右孩子指向 xx，这样在左子树遍历完成后我们通过这个指向走回了 xx，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p>
</li>
</ol>
<h4 id="2代码-3"><a class="markdownIt-Anchor" href="#2代码-3">#</a> （2）代码</h4>
<p><strong>题解链接： <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</a> 来源：力扣</strong></p>
<p>​		不想搬运代码了，就给出了链接。<strong>Morris 中序遍历</strong>是题解中的第三种解法，题解带有动画教程，可以看看。</p>
<h4 id="3总结-3"><a class="markdownIt-Anchor" href="#3总结-3">#</a> （3）总结</h4>
<p>​		一种没听过的中序遍历算法，搬运题解来的。（主要还是太菜了没玩明白）</p>
<h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2>
<p>​		此次题目中，出现了<strong>递归算法、迭代算法、Morris 遍历算法</strong>三种解题思路。</p>
<p>​		总的来说，还是递归较好理解，写起来难度稍微低一些；迭代算法初次了解，试了试水；Morris 遍历算法第一次见，还是看题解叭（还是人菜）。</p>
]]></content>
      <tags>
        <tag>算法作业</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/passages/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="acwing-785-快速排序"><a class="markdownIt-Anchor" href="#acwing-785-快速排序">#</a> AcWing 785. 快速排序</h1>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2>
<p>给定你一个长度为 n 的整数数列。</p>
<p>请你使用快速排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4>
<p>输入共两行，第一行包含整数 n。</p>
<p>第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。</p>
<h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4>
<p>输出共一行，包含 n 个整数，表示排好序的数列。</p>
<h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4>
<p>1≤n≤100000</p>
<h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure>
<h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2>
<h4 id="题意理解"><a class="markdownIt-Anchor" href="#题意理解">#</a> 题意理解</h4>
<p>这道题目显然是要我们将一个无序数列排序，成为具有升序性质的升序序列.</p>
<h4 id="算法处理"><a class="markdownIt-Anchor" href="#算法处理">#</a> 算法处理</h4>
<p>一道排序题目，数据范围是关键，我们发现这道题目只能让我们使用 O (nlogn) 的算法，显然我们可以选择快速排序，归并排序等算法，这里我们就使用快速排序.</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2>
<h4 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C++</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 如果没有数据或者只有一个数字的话，则不用排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = q[(l + r) / <span class="number">2</span>],i = l - <span class="number">1</span>, j = r + <span class="number">1</span>; <span class="comment">// 确定分界点和指针</span></span><br><span class="line">    <span class="comment">// 注意：分界点有四种取法，这里取的是中间的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123; <span class="comment">// i和j未相遇时，一直循环</span></span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x); <span class="comment">// 寻找</span></span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x); <span class="comment">// 寻找</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i],q[j]); <span class="comment">// 未相遇则交换，相遇了就不交换</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继续对整理出的两段数据进行排序</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j); </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span> ,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="java"><a class="markdownIt-Anchor" href="#java">#</a> Java</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> 基础算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick_Sort</span> </span>&#123; <span class="comment">// 快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> N = (<span class="keyword">int</span>) (<span class="number">1e6</span> +<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n; <span class="comment">// 要排序的整数的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] p = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 如果没有数据或者只有一个数字的话，则不用排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = p[(l + r)/<span class="number">2</span>],i = l - <span class="number">1</span>,j = r + <span class="number">1</span>;<span class="comment">// 确定分界点和指针</span></span><br><span class="line">        <span class="comment">// 注意：分界点有四种取法，这里取的是中间的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123; <span class="comment">// i和j未相遇时，一直循环</span></span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span>(p[i] &lt; x); <span class="comment">// 寻找</span></span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span>(p[j] &gt; x); <span class="comment">// 寻找</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) &#123; <span class="comment">// 指针未相遇则交换，相遇了就不交换</span></span><br><span class="line">                <span class="keyword">int</span> t = p[i];</span><br><span class="line">                p[i] = p[j];</span><br><span class="line">                p[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quick_sort(p,l,j); <span class="comment">// 递归处理左半边</span></span><br><span class="line">        quick_sort(p,j+<span class="number">1</span>,r); <span class="comment">// 递归处理右半边</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            p[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quick_sort(p,<span class="number">0</span>,n-<span class="number">1</span>); <span class="comment">// 快排</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            System.out.println(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="acwing-787-归并排序"><a class="markdownIt-Anchor" href="#acwing-787-归并排序">#</a> AcWing 787. 归并排序</h1>
<h2 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2">#</a> 题目描述</h2>
<p>给定你一个长度为 n 的整数数列。</p>
<p>请你使用归并排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<h4 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h4>
<p>输入共两行，第一行包含整数 n。</p>
<p>第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。</p>
<h4 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h4>
<p>输出共一行，包含 n 个整数，表示排好序的数列。</p>
<h4 id="数据范围-2"><a class="markdownIt-Anchor" href="#数据范围-2">#</a> 数据范围</h4>
<p>1≤n≤100000</p>
<h4 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2">#</a> 输入样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure>
<h4 id="输出样例-2"><a class="markdownIt-Anchor" href="#输出样例-2">#</a> 输出样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h2 id="解题思路-2"><a class="markdownIt-Anchor" href="#解题思路-2">#</a> 解题思路</h2>
<h4 id="题意理解-2"><a class="markdownIt-Anchor" href="#题意理解-2">#</a> 题意理解</h4>
<p>这道题目还是让我们排序，只不过这里强制要求我们使用归并排序，所以既然如此的话，让我们好好地康康这道题目.</p>
<h4 id="算法处理-2"><a class="markdownIt-Anchor" href="#算法处理-2">#</a> 算法处理</h4>
<p>归并排序，它有两大核心操作.</p>
<p>一个是将数组一分为二，一个无序的数组成为两个数组.</p>
<p>另外一个操作就是，合二为一，将两个有序数组合并成为一个有序数组.</p>
<p><img src="https://cdn.acwing.com/media/article/image/2019/05/19/1130_4cf170747a-3.gif" alt></p>
<h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2">#</a> 代码实现</h2>
<h4 id="c-2"><a class="markdownIt-Anchor" href="#c-2">#</a> C++</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 要排序的整数的个数</span></span><br><span class="line"><span class="keyword">int</span> q[N],tmp[N]; <span class="comment">// 排序的数组和功能数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 归并排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">// 选取中间点，相当于 int mid = (l+r) / 2;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid); <span class="comment">// 对左半部分进行递归</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r); <span class="comment">// 对右半部分进行递归</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,i = l,j = mid+<span class="number">1</span>; <span class="comment">// 设置递归左右两边区域时使用的三个指针</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) <span class="comment">// 左右两边都没遍历完的时候</span></span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++]; <span class="comment">// 后指针指的数字更小的话，将后指针所指数字放入功能数组并指向下一位</span></span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++]; <span class="comment">// 前指针指的数字更小的话，将前指针所指数字放入功能数组并指向下一位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将未遍历完的部分放入功能数组</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++]; <span class="comment">// 将前半部分未遍历完的部分放入功能数组</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k++] = q[j++]; <span class="comment">// 将后半部分未遍历完的部分放入功能数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) q[i] = tmp[j]; <span class="comment">// 将功能数组中排好序的数字复制到原始数组中</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="java-2"><a class="markdownIt-Anchor" href="#java-2">#</a> Java</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 基础算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge_Sort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> N = (<span class="keyword">int</span>) (<span class="number">1e6</span> +<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n; <span class="comment">// 要排序的整数的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] p = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">// 选取中间点，相当于 int mid = (l+r) / 2;</span></span><br><span class="line"></span><br><span class="line">        merge_sort(p,l,mid); <span class="comment">// 对左半部分进行递归</span></span><br><span class="line">        merge_sort(p,mid+<span class="number">1</span>,r); <span class="comment">// 对右半部分进行递归</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>,i = l,j = mid+<span class="number">1</span>; <span class="comment">// 设置递归左右两边区域时使用的三个指针  // 这句易错</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) <span class="comment">// 左右两边都没遍历完的时候</span></span><br><span class="line">            <span class="keyword">if</span>(p[i] &lt;= p[j]) tmp[k++] = p[i++]; <span class="comment">// 后指针指的数字更小的话，将后指针所指数字放入功能数组并指向下一位</span></span><br><span class="line">            <span class="keyword">else</span> tmp[k++] = p[j++]; <span class="comment">// 前指针指的数字更小的话，将前指针所指数字放入功能数组并指向下一位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将未遍历完的部分放入功能数组</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = p[i++]; <span class="comment">// 将前半部分未遍历完的部分放入功能数组</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) tmp[k++] = p[j++]; <span class="comment">// 将后半部分未遍历完的部分放入功能数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) p[i] = tmp[j]; <span class="comment">// 将功能数组中排好序的数字复制到原始数组中</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            p[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        merge_sort(p,<span class="number">0</span>,n-<span class="number">1</span>); <span class="comment">// 快排</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            System.out.println(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="acwing-789-数的范围二分"><a class="markdownIt-Anchor" href="#acwing-789-数的范围二分">#</a> AcWing 789. 数的范围（二分）</h1>
<h2 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3">#</a> 题目描述</h2>
<p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p>
<p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 00 开始计数）。</p>
<p>如果数组中不存在该元素，则返回  <code>-1 -1</code> 。</p>
<h4 id="输入格式-3"><a class="markdownIt-Anchor" href="#输入格式-3">#</a> 输入格式</h4>
<p>第一行包含整数 n 和 q，表示数组长度和询问个数。</p>
<p>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。</p>
<p>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p>
<h4 id="输出格式-3"><a class="markdownIt-Anchor" href="#输出格式-3">#</a> 输出格式</h4>
<p>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p>
<p>如果数组中不存在该元素，则返回  <code>-1 -1</code> 。</p>
<h4 id="数据范围-3"><a class="markdownIt-Anchor" href="#数据范围-3">#</a> 数据范围</h4>
<p>1≤n≤100000<br>
1≤q≤10000<br>
1≤k≤10000</p>
<h4 id="输入样例-3"><a class="markdownIt-Anchor" href="#输入样例-3">#</a> 输入样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h4 id="输出样例-3"><a class="markdownIt-Anchor" href="#输出样例-3">#</a> 输出样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>
<h2 id="解题思路-3"><a class="markdownIt-Anchor" href="#解题思路-3">#</a> 解题思路</h2>
<h4 id="整数二分"><a class="markdownIt-Anchor" href="#整数二分">#</a> 整数二分</h4>
<p>二分的本质是二段性不是单调性。</p>
<p>当想找不满足性质的边界值（红色区域的右边界值）</p>
<p><img src="https://gitee.com/adameta/img/raw/master/1580979705_20200206160241434_9286.png" alt></p>
<p>找中间值  <code>mid = (l+r+1)/2</code> <br>
if (check (mid)) 等于 true 或者是 false<br>
check (m) 是检查 m 是在<strong>不满足性质的区间</strong>（检查是不是在红色区间）<br>
更新 l 或者 r</p>
<p><img src="https://gitee.com/adameta/img/raw/master/1580979706_20200206161754906_7010.png" alt></p>
<p>当想找满足性质的边界值（绿色区域的左边界值）</p>
<ol>
<li>找中间值  <code>mid = (l+r)/2</code></li>
<li>if (check (mid)) 等于 true 或者是 false<br>
check (m) 是检查 m 是在<strong>满足性质的区间</strong>（检查是不是在绿色区间）</li>
<li>更新 l 或者 r</li>
</ol>
<p><img src="https://gitee.com/adameta/img/raw/master/1580979706_20200206163113295_29079.png" alt></p>
<p>归结上面的两种二分方法，步骤为：</p>
<ol>
<li>先写一个 check 函数</li>
<li>判定在 check 的情况下（true 和 false 的情况下），如何更新区间。</li>
<li>在 check (m)==true 的分支下是:
<ol>
<li><code>l=mid</code>  的情况，中间点的更新方式是 <code>m=(l+r+1)/2</code></li>
<li><code>r=mid</code>  的情况，中间点的更新方式是 <code>m=(l+r)/2</code></li>
</ol>
</li>
</ol>
<p>这种方法保证了：</p>
<ol>
<li>最后的 <code>l==r</code></li>
<li>搜索到达的答案是闭区间的，即 a [l] 是满足 check () 条件的。</li>
</ol>
<h2 id="代码实现-3"><a class="markdownIt-Anchor" href="#代码实现-3">#</a> 代码实现</h2>
<h4 id="java-3"><a class="markdownIt-Anchor" href="#java-3">#</a> Java</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> N = (<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt(); <span class="comment">// 读入数组长度</span></span><br><span class="line">        m = in.nextInt(); <span class="comment">// 读入询问个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;n;i++) q[i] = in.nextInt(); <span class="comment">// 读入数组数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(m-- &gt; <span class="number">0</span>) &#123; <span class="comment">// 询问个数大于0（还未询问完）</span></span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            x = in.nextInt(); <span class="comment">// 读入要询问的数字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>; <span class="comment">// 选取左右指针(数组的左右两边)</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 当指针未相遇时(未找到想找到的边界时)</span></span><br><span class="line">                <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// mid = l // 定义中间量 用于检查数据和更新指针</span></span><br><span class="line">                <span class="keyword">if</span> (q[mid] &gt;= x) r = mid; <span class="comment">// 更新右指针</span></span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>; <span class="comment">// 更新左指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q[l] != x) System.out.println(<span class="string">&quot;-1 -1&quot;</span>); <span class="comment">// 未找到想要的边界(未找到想要的数字(找到的位置上的数字不是我们想要的))</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(l + <span class="string">&quot; &quot;</span>); <span class="comment">// 输出我们想要的左边界(查询的数字第一次出现的位置)</span></span><br><span class="line">                l = <span class="number">0</span>;r = n - <span class="number">1</span>; <span class="comment">// 重新选取选取左右指针(数组的左右两边)</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// // 当指针未相遇时(未找到想找到的边界时)</span></span><br><span class="line">                    <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; <span class="comment">// mid = r // 重新定义中间量 用于检查数据和更新指针</span></span><br><span class="line">                    <span class="keyword">if</span> (q[mid] &lt;= x) l = mid; <span class="comment">// 更新左指针</span></span><br><span class="line">                    <span class="keyword">else</span> r = mid - <span class="number">1</span>; <span class="comment">// 更新右指针</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(l); <span class="comment">// 输出我们想要的右边界(查询的数字最后一次出现的位置)</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="c-3"><a class="markdownIt-Anchor" href="#c-3">#</a> C++</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--) &#123; <span class="comment">// 询问个数大于0（还未查询完）</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); <span class="comment">// 读入要查询的数字</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>; <span class="comment">// 选取左右指针（数组的左右两边）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确定左边界（第一次出现的位置）</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123; <span class="comment">// 当指针未相遇时(未找到想找到的边界时)）</span></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">// mid = l // 定义中间量 用于检查数据和更新指针</span></span><br><span class="line">            <span class="keyword">if</span>(q[mid] &gt;= x) r = mid; <span class="comment">// 更新右指针</span></span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>; <span class="comment">// 更新左指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q[l] != x) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl; <span class="comment">// 未找到想要的边界(未找到想要的数字(找到的位置上的数字不是我们想要的))</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> ; <span class="comment">// 输出我们想要的左边界(查询的数字第一次出现的位置)</span></span><br><span class="line">            l = <span class="number">0</span>,r = n<span class="number">-1</span>; <span class="comment">// 重新选取选取左右指针(数组的左右两边)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 确定左边界（第一次出现的位置）</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt; r) &#123; <span class="comment">// 当指针未相遇时(未找到想找到的边界时)</span></span><br><span class="line">                <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// mid = r // 重新定义中间量 用于检查数据和更新指针</span></span><br><span class="line">                <span class="keyword">if</span>(q[mid] &lt;= x) l = mid; <span class="comment">// 更新左指针</span></span><br><span class="line">                <span class="keyword">else</span> r = mid<span class="number">-1</span>; <span class="comment">// 更新右指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl; <span class="comment">// 输出我们想要的右边界(查询的数字最后一次出现的位置)</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="acwing-790-数的三次方根二分"><a class="markdownIt-Anchor" href="#acwing-790-数的三次方根二分">#</a> AcWing 790. 数的三次方根（二分）</h1>
<h2 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4">#</a> 题目描述</h2>
<p>给定一个浮点数 n，求它的三次方根。</p>
<h4 id="输入格式-4"><a class="markdownIt-Anchor" href="#输入格式-4">#</a> 输入格式</h4>
<p>共一行，包含一个浮点数 n。</p>
<h4 id="输出格式-4"><a class="markdownIt-Anchor" href="#输出格式-4">#</a> 输出格式</h4>
<p>共一行，包含一个浮点数，表示问题的解。</p>
<p>注意，结果保留 6 位小数。</p>
<h4 id="数据范围-4"><a class="markdownIt-Anchor" href="#数据范围-4">#</a> 数据范围</h4>
<p>−10000≤n≤10000</p>
<h4 id="输入样例-4"><a class="markdownIt-Anchor" href="#输入样例-4">#</a> 输入样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000.00</span><br></pre></td></tr></table></figure>
<h4 id="输出样例-4"><a class="markdownIt-Anchor" href="#输出样例-4">#</a> 输出样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.000000</span><br></pre></td></tr></table></figure>
<h2 id="解题思路-4"><a class="markdownIt-Anchor" href="#解题思路-4">#</a> 解题思路</h2>
<p>学会整数二分后，相信这个大家有手就行。</p>
<h2 id="代码实现-4"><a class="markdownIt-Anchor" href="#代码实现-4">#</a> 代码实现</h2>
<h4 id="c-4"><a class="markdownIt-Anchor" href="#c-4">#</a> C++</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; x; <span class="comment">// 读入数据</span></span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-10000</span>,r = <span class="number">10000</span>; <span class="comment">// 设定范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>) &#123; <span class="comment">// 是否找到</span></span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">// 中间值</span></span><br><span class="line">        <span class="keyword">if</span>(mid*mid*mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,l); <span class="comment">// %lf默认保留六位小数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="java-4"><a class="markdownIt-Anchor" href="#java-4">#</a> Java</h4>
<p><strong><a href="https://cloud.tencent.com/developer/article/1607231">JAVA 字符串格式化 ——String.format () 的使用</a></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        x = in.nextDouble(); <span class="comment">// 读入数据</span></span><br><span class="line">        <span class="keyword">double</span> l = -<span class="number">10000</span>,r = <span class="number">10000</span>; <span class="comment">// 设定范围</span></span><br><span class="line">        <span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>) &#123; <span class="comment">// 是否找到</span></span><br><span class="line">            <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">// 中间值</span></span><br><span class="line">            <span class="keyword">if</span>(mid*mid*mid &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%.6f&quot;</span>, l)); <span class="comment">// 保留六位小数</span></span><br><span class="line">        <span class="comment">// System.out.printf(&quot;%.6f&quot;,l); // 作用相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="acwing-791-高精度加法"><a class="markdownIt-Anchor" href="#acwing-791-高精度加法">#</a> AcWing 791. 高精度加法</h1>
<h2 id="题目描述-5"><a class="markdownIt-Anchor" href="#题目描述-5">#</a> 题目描述</h2>
<p>给定两个正整数（不含前导 00），计算它们的和。</p>
<h4 id="输入格式-5"><a class="markdownIt-Anchor" href="#输入格式-5">#</a> 输入格式</h4>
<p>共两行，每行包含一个整数。</p>
<h4 id="输出格式-5"><a class="markdownIt-Anchor" href="#输出格式-5">#</a> 输出格式</h4>
<p>共一行，包含所求的和。</p>
<h4 id="数据范围-5"><a class="markdownIt-Anchor" href="#数据范围-5">#</a> 数据范围</h4>
<p>1≤整数长度≤1000001≤整数长度≤100000</p>
<h4 id="输入样例-5"><a class="markdownIt-Anchor" href="#输入样例-5">#</a> 输入样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">23</span><br></pre></td></tr></table></figure>
<h4 id="输出样例-5"><a class="markdownIt-Anchor" href="#输出样例-5">#</a> 输出样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure>
<h2 id="解题思路-5"><a class="markdownIt-Anchor" href="#解题思路-5">#</a> 解题思路</h2>
<ol>
<li>
<p>因为是长整数的加法运算，普通的数据类型无法存放，所以选择了 vector（也因为有  <code>.size</code>  这个函数才采用它）。</p>
</li>
<li>
<p>过长的数据使我选择了字符串来读入，用循环放入 vector 即可（将数字低位在前高位在后的放入）。</p>
</li>
<li>
<p>在循环中通过算子 <code>t</code>  来进行每一位的运算，并将下一次运算的进位算出： <code>t /= 10;</code> （参与下一位数的运算），剩余部分写入结果中： <code>C.push_back(t%10);</code> 。</p>
</li>
<li>
<p>循环结束（各位的运算完成）后，如果最高位时 0，则需要进一位： <code>C.push_back(1);</code></p>
</li>
</ol>
<h2 id="代码实现-5"><a class="markdownIt-Anchor" href="#代码实现-5">#</a> 代码实现</h2>
<h4 id="c-5"><a class="markdownIt-Anchor" href="#c-5">#</a> C++</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A,vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123; <span class="comment">// 使用引用传参，就不用再复制一遍了</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C; <span class="comment">// 储存结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 运算的算子以及进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>();i++) &#123; <span class="comment">// 加法运算，A或B未读完时，加法继续</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i]; <span class="comment">// 从个位数开始加，一次循环加一位</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i]; <span class="comment">// 从个位数开始加，一次循环加一位</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>); <span class="comment">// 排除t中需要进位的部分并将剩下的放在C里面</span></span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">// 下一次运算时的进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 运算后最高位是0，则进1</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// 使用字符串读入数据</span></span><br><span class="line">    <span class="comment">// 在下面一步时，注意字符串的末尾有&#x27;0&#x27;，所以有 size() - 1 </span></span><br><span class="line">    <span class="comment">// 而 a[i] - &#x27;0&#x27; 是为了拿到数据(eg: &#x27;2&#x27; - &#x27;0&#x27; = 0)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 将数据放入vector中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 将数据放入vector中</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C = <span class="built_in">add</span>(A,B); <span class="comment">// 进行加法运算并将结果放入C中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在下面这一步时，要注意size() - 1,不然的话结果前面会多一个0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]); <span class="comment">// 输出结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="acwing-792-高精度减法"><a class="markdownIt-Anchor" href="#acwing-792-高精度减法">#</a> AcWing 792. 高精度减法</h1>
<h2 id="题目描述-6"><a class="markdownIt-Anchor" href="#题目描述-6">#</a> 题目描述</h2>
<p>给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。</p>
<h4 id="输入格式-6"><a class="markdownIt-Anchor" href="#输入格式-6">#</a> 输入格式</h4>
<p>共两行，每行包含一个整数。</p>
<h4 id="输出格式-6"><a class="markdownIt-Anchor" href="#输出格式-6">#</a> 输出格式</h4>
<p>共一行，包含所求的差。</p>
<h4 id="数据范围-6"><a class="markdownIt-Anchor" href="#数据范围-6">#</a> 数据范围</h4>
<p>1≤整数长度≤105</p>
<h4 id="输入样例-6"><a class="markdownIt-Anchor" href="#输入样例-6">#</a> 输入样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line">11</span><br></pre></td></tr></table></figure>
<h4 id="输出样例-6"><a class="markdownIt-Anchor" href="#输出样例-6">#</a> 输出样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>
<h2 id="解题思路-6"><a class="markdownIt-Anchor" href="#解题思路-6">#</a> 解题思路</h2>
<p>判断需要相减的两个数的大小，然后进行逐位相减。</p>
<h2 id="代码实现-6"><a class="markdownIt-Anchor" href="#代码实现-6">#</a> 代码实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A - B 是否大于0</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>(); <span class="comment">// 先看长度，长度长的大</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="comment">// 从个位开始比较，相同跳过这位数，不相同返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 都相同，返回true(此时A - B = 0)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法运算</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="comment">// 从个位开始逐位相减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t; <span class="comment">// 减去上一次的借位</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i]; <span class="comment">// 由于A&gt;B,i有可能超出B的位数，需要验证</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>); <span class="comment">// 添加结果(包含t&gt;0与t&lt;0的情况) --&gt; t&gt;0: t%10,  t&lt;0: (t + 10) % 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算借位</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 消除结果前的0(eg: 111-110=001 , 需要去除两个数字 0 使结果变成 1 )</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// 读入数据为字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 转换成数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 转换成数字</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C; <span class="comment">// 定义结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// A &gt; B 时,sub(A, B),否则 sub(B, A),并输出一个&#x27;-&#x27;号</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B)) C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">    <span class="keyword">else</span> C = <span class="built_in">sub</span>(B, A), cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="写在后面"><a class="markdownIt-Anchor" href="#写在后面">#</a> 写在后面</h1>
<p>暂时先写这么多，学了其他的继续写（~~ 菜鸡嘤嘤</p>
]]></content>
      <tags>
        <tag>算法基础课</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/passages/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start">#</a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post">#</a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server">#</a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files">#</a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites">#</a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: [Deployment](<a href="https://hexo.io/docs/one-command-deployment.html">https://hexo.io/docs/one-command-deployment.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用java将ResultSet中的数据打印成表格</title>
    <url>/passages/%E4%BD%BF%E7%94%A8java%E5%B0%86ResultSet%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%89%93%E5%8D%B0%E6%88%90%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="背景介绍"><a class="markdownIt-Anchor" href="#背景介绍">#</a> 背景介绍</h1>
<p>在写课设的时候呢，有一个需求是将数据库的数据输出到控制台，最好是格式化输出。</p>
<p>刚开始的时候我使用的方法是使用 select 语句讲数据拿到 ResultSet 中，之后将数据一条一条的放进对象中，之后放进 Arraylist 中来遍历输出。这种方法的效率较低，占用的时间空间都比较大。于是开始寻找一些方便好用的格式化输出 ResultSet 数据的方法，最终在参考了一些资料后整理出了这个方法。</p>
<h1 id="需求描述"><a class="markdownIt-Anchor" href="#需求描述">#</a> 需求描述</h1>
<p><code>MySQL</code>  的查询语句输出如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+------------+-----------+-----------+</span><br><span class="line">| id         | name      | phone     |</span><br><span class="line">+------------+-----------+-----------+</span><br><span class="line">| <span class="number">2007040901</span> | 小亮      | <span class="number">789789789</span> |</span><br><span class="line">| <span class="number">2007040902</span> | 小白      | <span class="number">852852852</span> |</span><br><span class="line">| <span class="number">2007040903</span> | 小明      | <span class="number">123123123</span> |</span><br><span class="line">| <span class="number">2007040904</span> | 小红      | <span class="number">456456456</span> |</span><br><span class="line">| <span class="number">2007040905</span> | 大飞      | <span class="number">456645564</span> |</span><br><span class="line">| <span class="number">2007041001</span> | 小青      | <span class="number">123456789</span> |</span><br><span class="line">| <span class="number">2007041002</span> | 小飞      | <span class="number">321654987</span> |</span><br><span class="line">| <span class="number">2007041003</span> | 小跑      | <span class="number">963852741</span> |</span><br><span class="line">| <span class="number">2007041004</span> | 大白      | <span class="number">789789789</span> |</span><br><span class="line">| <span class="number">2007041101</span> | 小王      | <span class="number">111222333</span> |</span><br><span class="line">| <span class="number">2007041102</span> | 小星      | <span class="number">444555666</span> |</span><br><span class="line">| <span class="number">2007041103</span> | 小义      | <span class="number">777888999</span> |</span><br><span class="line">| <span class="number">2007041104</span> | 萧山      | <span class="number">111444777</span> |</span><br><span class="line">| <span class="number">2007041105</span> | 大王      | <span class="number">123123123</span> |</span><br><span class="line">| <span class="number">2007041201</span> | 赵小花    | <span class="number">222555888</span> |</span><br><span class="line">| <span class="number">2007041202</span> | 赵大花    | <span class="number">333666999</span> |</span><br><span class="line">| <span class="number">2007041203</span> | 赵老花    | <span class="number">159357123</span> |</span><br><span class="line">| <span class="number">2007041204</span> | 赵仙花    | <span class="number">623847456</span> |</span><br><span class="line">| <span class="number">2007041205</span> | 大力      | <span class="number">915915159</span> |</span><br><span class="line">| <span class="number">2007041301</span> | 郭小凯    | <span class="number">159159159</span> |</span><br><span class="line">| <span class="number">2007041302</span> | 郭大凯    | <span class="number">357357357</span> |</span><br><span class="line">| <span class="number">2007041303</span> | 郭老凯    | <span class="number">852852852</span> |</span><br><span class="line">| <span class="number">2007041304</span> | 郭仙凯    | <span class="number">963963963</span> |</span><br><span class="line">| <span class="number">2007041305</span> | 大明      | <span class="number">357537753</span> |</span><br><span class="line">+------------+-----------+-----------+</span><br><span class="line"><span class="number">24</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p>使用 <code>JDBC</code>  执行上述的查询语句，将结果集中的查询结果以表格的形式打印出来。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路">#</a> 思路</h1>
<ul>
<li>通过结果集的元数据可以知道结果集中的列数，和列名.</li>
<li>然后遍历结果集，分别统计每一列中的最大字符数。</li>
<li>然后通过 <code>System.out.printf()</code>  方法进行格式化输出。</li>
</ul>
<h1 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现">#</a> 具体实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSetMetaData;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果集打印机.将结果集中的数据打印成表格.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSetPrinter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printResultSet</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ResultSetMetaData resultSetMetaData = rs.getMetaData();</span><br><span class="line">        <span class="comment">// 获取列数</span></span><br><span class="line">        <span class="keyword">int</span> ColumnCount = resultSetMetaData.getColumnCount();</span><br><span class="line">        <span class="comment">// 保存当前列最大长度的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] columnMaxLengths = <span class="keyword">new</span> <span class="keyword">int</span>[ColumnCount];</span><br><span class="line">        <span class="comment">// 缓存结果集,结果集可能有序,所以用ArrayList保存变得打乱顺序.</span></span><br><span class="line">        ArrayList&lt;String[]&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 按行遍历</span></span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="comment">// 保存当前行所有列</span></span><br><span class="line">            String[] columnStr = <span class="keyword">new</span> String[ColumnCount];</span><br><span class="line">            <span class="comment">// 获取属性值.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ColumnCount; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取一列</span></span><br><span class="line">                columnStr[i] = rs.getString(i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 计算当前列的最大长度</span></span><br><span class="line">                columnMaxLengths[i] = Math.max(columnMaxLengths[i], (columnStr[i] == <span class="keyword">null</span>) ? <span class="number">0</span> : columnStr[i].length());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缓存这一行.</span></span><br><span class="line">            results.add(columnStr);</span><br><span class="line">        &#125;</span><br><span class="line">        printSeparator(columnMaxLengths);</span><br><span class="line">        printColumnName(resultSetMetaData, columnMaxLengths);</span><br><span class="line">        printSeparator(columnMaxLengths);</span><br><span class="line">        <span class="comment">// 遍历集合输出结果</span></span><br><span class="line">        Iterator&lt;String[]&gt; iterator = results.iterator();</span><br><span class="line">        String[] columnStr;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            columnStr = iterator.next();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ColumnCount; i++) &#123;</span><br><span class="line">                <span class="comment">// System.out.printf(&quot;|%&quot; + (columnMaxLengths[i] + 1) + &quot;s&quot;, columnStr[i]);</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;|%&quot;</span> + columnMaxLengths[i] + <span class="string">&quot;s&quot;</span>, columnStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printSeparator(columnMaxLengths);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出列名.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultSetMetaData 结果集的元数据对象.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMaxLengths  每一列最大长度的字符串的长度.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printColumnName</span><span class="params">(ResultSetMetaData resultSetMetaData, <span class="keyword">int</span>[] columnMaxLengths)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> columnCount = resultSetMetaData.getColumnCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">            <span class="comment">// System.out.printf(&quot;|%&quot; + (columnMaxLengths[i] + 1) + &quot;s&quot;, resultSetMetaData.getColumnName(i + 1));</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;|%&quot;</span> + columnMaxLengths[i] + <span class="string">&quot;s&quot;</span>, resultSetMetaData.getColumnName(i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出分隔符.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMaxLengths 保存结果集中每一列的最长的字符串的长度.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSeparator</span><span class="params">(<span class="keyword">int</span>[] columnMaxLengths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnMaxLengths.length; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">            <span class="comment">// for (int j = 0; j &lt; columnMaxLengths[i] + 1; j++) &#123;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columnMaxLengths[i]; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="测试"><a class="markdownIt-Anchor" href="#测试">#</a> 测试</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String URL = <span class="string">&quot;jdbc:mysql://localhost:3306/student_information?useUnicode=true&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDBC测试.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JDBCexample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.加载数据库驱动</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        testStatement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试Statement的用法.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="comment">// 2.打开数据库连接</span></span><br><span class="line">             Connection conn = DriverManager.getConnection(URL, user, password);</span><br><span class="line">             <span class="comment">// 3.创建语句</span></span><br><span class="line">             Statement stmt = conn.createStatement()) &#123;</span><br><span class="line">            <span class="comment">// 模拟SQL注入</span></span><br><span class="line">            testSqlInjecton(stmt);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SQLException : &quot;</span> + sqle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟SQL注入.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt Statement对象.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSqlInjecton</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from student&quot;</span>;</span><br><span class="line">        ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line">        ResultSetPrinter.printResultSet(rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JDBCexample();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果">#</a> 运行结果</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+----------+---+---------+</span><br><span class="line">|        id|name|    phone|</span><br><span class="line">+----------+---+---------+</span><br><span class="line">|<span class="number">2007040901</span>| 小亮|<span class="number">789789789</span>|</span><br><span class="line">|<span class="number">2007040902</span>| 小白|<span class="number">852852852</span>|</span><br><span class="line">|<span class="number">2007040903</span>| 小明|<span class="number">123123123</span>|</span><br><span class="line">|<span class="number">2007040904</span>| 小红|<span class="number">456456456</span>|</span><br><span class="line">|<span class="number">2007040905</span>| 大飞|<span class="number">456645564</span>|</span><br><span class="line">|<span class="number">2007041001</span>| 小青|<span class="number">123456789</span>|</span><br><span class="line">|<span class="number">2007041002</span>| 小飞|<span class="number">321654987</span>|</span><br><span class="line">|<span class="number">2007041003</span>| 小跑|<span class="number">963852741</span>|</span><br><span class="line">|<span class="number">2007041004</span>| 大白|<span class="number">789789789</span>|</span><br><span class="line">|<span class="number">2007041101</span>| 小王|<span class="number">111222333</span>|</span><br><span class="line">|<span class="number">2007041102</span>| 小星|<span class="number">444555666</span>|</span><br><span class="line">|<span class="number">2007041103</span>| 小义|<span class="number">777888999</span>|</span><br><span class="line">|<span class="number">2007041104</span>| 萧山|<span class="number">111444777</span>|</span><br><span class="line">|<span class="number">2007041105</span>| 大王|<span class="number">123123123</span>|</span><br><span class="line">|<span class="number">2007041201</span>|赵小花|<span class="number">222555888</span>|</span><br><span class="line">|<span class="number">2007041202</span>|赵大花|<span class="number">333666999</span>|</span><br><span class="line">|<span class="number">2007041203</span>|赵老花|<span class="number">159357123</span>|</span><br><span class="line">|<span class="number">2007041204</span>|赵仙花|<span class="number">623847456</span>|</span><br><span class="line">|<span class="number">2007041205</span>| 大力|<span class="number">915915159</span>|</span><br><span class="line">|<span class="number">2007041301</span>|郭小凯|<span class="number">159159159</span>|</span><br><span class="line">|<span class="number">2007041302</span>|郭大凯|<span class="number">357357357</span>|</span><br><span class="line">|<span class="number">2007041303</span>|郭老凯|<span class="number">852852852</span>|</span><br><span class="line">|<span class="number">2007041304</span>|郭仙凯|<span class="number">963963963</span>|</span><br><span class="line">|<span class="number">2007041305</span>| 大明|<span class="number">357537753</span>|</span><br><span class="line">+----------+---+---------+</span><br></pre></td></tr></table></figure>
<h2 id="提示"><a class="markdownIt-Anchor" href="#提示">#</a> 提示</h2>
<p>在使用时可以根据具体情况适当的做一些微调，以便达到想要的效果。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>太平洋大西洋水流问题</title>
    <url>/passages/%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="太平洋大西洋水流问题"><a class="markdownIt-Anchor" href="#太平洋大西洋水流问题">#</a> 太平洋大西洋水流问题</h1>
<p>​		大一 -&gt; 大二暑期算法作业</p>
<p>​		<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>
<h2 id="看到题目的感想"><a class="markdownIt-Anchor" href="#看到题目的感想">#</a> 看到题目的感想</h2>
<p>​		刚看到这个题目的时候感觉他不是很熟悉，没有见过类似的题目，也没有见过类似的场景，感觉有点意思。</p>
<p>​		题目不算很长，但感觉难度不小。</p>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2>
<p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。</p>
<p><strong>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</strong></p>
<p>请找出那些水流<strong>既可以</strong>流动到 “太平洋”，<strong>又能</strong>流动到 “大西洋” 的陆地单元的坐标。</p>
<p>提示：</p>
<p>输出坐标的<strong>顺序不重要</strong><br>
 m 和 n 都<strong>小于 150</strong></p>
<p>示例：</p>
<p>给定下面的 5x5 矩阵:</p>
<dl>
<dt>太平洋～~   ~   ~   ~</dt>
<dd>1   2   2   3  (5) /</dd>
<dd>3   2   3  (4) (4) /</dd>
<dd>2   4  (5)  3   1  /</dd>
<dd>(6) (7)  1   4   5  /</dd>
<dd>(5)  1   1   2   4  /</dd>
</dl>
<p>​            /    /    /    /    /   大西洋</p>
<p>返回:</p>
<p>[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元). （序号先左后上）</p>
<h2 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答">#</a> 题目解答</h2>
<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>
<h3 id="逆流而上"><a class="markdownIt-Anchor" href="#逆流而上">#</a> 逆流而上</h3>
<p>​		最开始的名字叫<strong>逆着水流向上找</strong>，后面才想起来有<strong>逆流而上</strong>这个成语，才改了名字。</p>
<p>​		最开始浮现的思路是想暴力解题，后来发现暴力解题太过于麻烦，效率也不高，索性就放弃了。之后才有的现在这个想法。</p>
<h3 id="1解题思路"><a class="markdownIt-Anchor" href="#1解题思路">#</a> （1）解题思路</h3>
<p>​		本题找的是<strong>能够让水流留到两片水域</strong>的陆地单元的位置坐标，那么既然水能过去，那我们反过来找，<strong>分别找到两个水域的水能流到的地方，之后取交集</strong>，就得到了我们想要的答案。</p>
<h3 id="2代码"><a class="markdownIt-Anchor" href="#2代码">#</a> （2）代码</h3>
<p><strong>配合题目链接食用</strong></p>
<h4 id="java"><a class="markdownIt-Anchor" href="#java">#</a> Java</h4>
<p><strong>注：这个代码在 idea 上可以正常运行，但在力扣上会有报错。报错如下：</strong></p>
<p>error: incompatible types: List&lt;int[]&gt; cannot be converted to List&lt;List<Integer>&gt; [in <strong>Driver</strong>.java]</Integer></p>
<p>List&lt;List<Integer>&gt; ret = new Solution().pacificAtlantic(param_1);</Integer></p>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/197276/28/5074/29323/612842a4E395ba9f9/a2ea88eb469c810c.png" alt="image-20210827093245188.png"></p>
<p><strong>List &amp; ArrayList：<a href="https://www.jianshu.com/p/25aa92f8d681">https://www.jianshu.com/p/25aa92f8d681</a> 来源：简书</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">                List&lt;<span class="keyword">int</span>[]&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 储存最终数据</span></span><br><span class="line">                <span class="keyword">int</span> m = matrix.length; <span class="comment">// 获取矩阵一边的长度</span></span><br><span class="line">                <span class="keyword">if</span>(m &lt; <span class="number">1</span>) <span class="keyword">return</span> ret; <span class="comment">// 矩阵大小为0时</span></span><br><span class="line">                <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length; <span class="comment">// 获取矩阵另一边的长度</span></span><br><span class="line">                <span class="keyword">boolean</span>[][] Pacific = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n]; <span class="comment">// 太平洋的</span></span><br><span class="line">                <span class="keyword">boolean</span>[][] Atlantic = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n]; <span class="comment">// 大西洋的</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123; <span class="comment">// 递归判断一条边</span></span><br><span class="line">                    dfs(matrix, i, <span class="number">0</span>, Pacific, matrix[i][<span class="number">0</span>]);</span><br><span class="line">                    dfs(matrix, i, n-<span class="number">1</span>, Atlantic, matrix[i][n-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 递归判断另一条边</span></span><br><span class="line">                    dfs(matrix, <span class="number">0</span>, i, Pacific, matrix[<span class="number">0</span>][i]);</span><br><span class="line">                    dfs(matrix, m-<span class="number">1</span>, i, Atlantic, matrix[m-<span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123; <span class="comment">// 取交集得到最终结果</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                        <span class="keyword">if</span>(Pacific[i][j] &amp;&amp; Atlantic[i][j])</span><br><span class="line">                            ret.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;); <span class="comment">// 放入数据</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret; <span class="comment">// 返回结果</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 超出边界 或 判断过是可以的 或 不能继续向上流动，则返回</span></span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= m.length || y &gt;= m[<span class="number">0</span>].length || visited[x][y] || m[x][y] &lt; pre)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                visited[x][y] = <span class="keyword">true</span>; <span class="comment">// 可以向上流</span></span><br><span class="line">                dfs(m, x+<span class="number">1</span>, y, visited, m[x][y]); <span class="comment">// 递归判断相邻行或列</span></span><br><span class="line">                dfs(m, x-<span class="number">1</span>, y, visited, m[x][y]); <span class="comment">// 递归判断相邻行或列</span></span><br><span class="line">                dfs(m, x, y+<span class="number">1</span>, visited, m[x][y]); <span class="comment">// 递归判断相邻行或列</span></span><br><span class="line">                dfs(m, x, y-<span class="number">1</span>, visited, m[x][y]); <span class="comment">// 递归判断相邻行或列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3总结"><a class="markdownIt-Anchor" href="#3总结">#</a> （3）总结</h3>
<p>​		这个解题思路来看的话感觉还是可以的，就是会有一些<strong>奇怪的 bug</strong>，不知道怎么肥四。</p>
<h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2>
<p>​		这个题目难度比之前的大一些，不好做，包括写的时候也查了一些资料（<strong>运用不熟练</strong>），好在最后搞出来了（虽然有一些奇怪的 bug）。</p>
<p>​		（<strong>递归真香</strong>）</p>
]]></content>
      <tags>
        <tag>算法作业</tag>
      </tags>
  </entry>
  <entry>
    <title>某菜鸡艰难的you-get使用历程</title>
    <url>/passages/%E6%9F%90%E8%8F%9C%E9%B8%A1%E8%89%B0%E9%9A%BE%E7%9A%84you-get%E4%BD%BF%E7%94%A8%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<p>​        <strong>声明：本文主要功能是记录使用 you-get 的感受和经历，也写了一些使用的过程，可以参考，但不是教学式的教程。（需要教程请百度 / 必应一下）</strong></p>
<h1 id="you-get初体验"><a class="markdownIt-Anchor" href="#you-get初体验">#</a> you-get 初体验</h1>
<p>​        偶尔有看到身边的同学在用 you-get，并推荐给了我们，当时并没有感觉有很棒，但是后来感觉还是很好用的（真香定律。</p>
<h1 id="you-get的使用"><a class="markdownIt-Anchor" href="#you-get的使用">#</a> you-get 的使用</h1>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装">#</a> 安装</h2>
<p>​        首先我们需要准备 Python 环境，可以去 python 官网下载，大于等于 Python3 即可，我用的是 python3.9.7。</p>
<p><img src="https://s3.bmp.ovh/imgs/2021/09/d969338599694a69.png" alt></p>
<p>​        准备好环境之后就可以下载 you-get 了。（cmd 和 git bush 都可以）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install you-get</span><br><span class="line"></span><br><span class="line"># 如果下载的慢，可以使用国内的源站下载</span><br><span class="line">#豆瓣</span><br><span class="line">pip install -i http://pypi.douban.com/simple/ you-get</span><br><span class="line">#清华</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple you-get</span><br></pre></td></tr></table></figure>
<p>​        安装之后输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get</span><br></pre></td></tr></table></figure>
<p>​        出现如下内容说明安装好了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usage: you-get [OPTION]... URL...</span><br><span class="line"></span><br><span class="line">A tiny downloader that scrapes the web</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -V, --version         Print version and exit</span><br><span class="line">  -h, --help            Print this help message and exit</span><br><span class="line"></span><br><span class="line">Dry-run options:</span><br><span class="line">  (no actual downloading)</span><br><span class="line"></span><br><span class="line">  -i, --info            Print extracted information</span><br><span class="line">  -u, --url             Print extracted information with URLs</span><br><span class="line">  --json                Print extracted URLs in JSON format</span><br><span class="line"></span><br><span class="line">Download options:</span><br><span class="line">  -n, --no-merge        Do not merge video parts</span><br><span class="line">  --no-caption          Do not download captions (subtitles, lyrics, danmaku, ...)</span><br><span class="line">  -f, --force           Force overwriting existing files</span><br><span class="line">  --skip-existing-file-size-check</span><br><span class="line">                        Skip existing file without checking file size</span><br><span class="line">  -F STREAM_ID, --format STREAM_ID</span><br><span class="line">                        Set video format to STREAM_ID</span><br><span class="line">  -O FILE, --output-filename FILE</span><br><span class="line">                        Set output filename</span><br><span class="line">  -o DIR, --output-dir DIR</span><br><span class="line">                        Set output directory</span><br><span class="line">  -p PLAYER, --player PLAYER</span><br><span class="line">                        Stream extracted URL to a PLAYER</span><br><span class="line">  -c COOKIES_FILE, --cookies COOKIES_FILE</span><br><span class="line">                        Load cookies.txt or cookies.sqlite</span><br><span class="line">  -t SECONDS, --timeout SECONDS</span><br><span class="line">                        Set socket timeout</span><br><span class="line">  -d, --debug           Show traceback and other debug info</span><br><span class="line">  -I FILE, --input-file FILE</span><br><span class="line">                        Read non-playlist URLs from FILE</span><br><span class="line">  -P PASSWORD, --password PASSWORD</span><br><span class="line">                        Set video visit password to PASSWORD</span><br><span class="line">  -l, --playlist        Prefer to download a playlist</span><br><span class="line">  -a, --auto-rename     Auto rename same name different files</span><br><span class="line">  -k, --insecure        ignore ssl errors</span><br><span class="line"></span><br><span class="line">Proxy options:</span><br><span class="line">  -x HOST:PORT, --http-proxy HOST:PORT</span><br><span class="line">                        Use an HTTP proxy for downloading</span><br><span class="line">  -y HOST:PORT, --extractor-proxy HOST:PORT</span><br><span class="line">                        Use an HTTP proxy for extracting only</span><br><span class="line">  --no-proxy            Never use a proxy</span><br><span class="line">  -s HOST:PORT or USERNAME:PASSWORD@HOST:PORT, --socks-proxy HOST:PORT or USERNAME:PASSWORD@HOST:PORT</span><br><span class="line">                        Use an SOCKS5 proxy for downloading</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​        里面也包含了可用参数和命令。<br>
​        其中比较重要的有：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>显示资源信息，比如说格式、清晰度、大小等</td>
</tr>
<tr>
<td>-i</td>
<td>指定下载或查看的 url，有时候可以省略 - u 直接加上 url</td>
</tr>
<tr>
<td>-o</td>
<td>设置输出文件夹，即保存路径，若不指定，则保存在当前工作目录</td>
</tr>
<tr>
<td>-O</td>
<td>设置文件名，可采用默认文件名</td>
</tr>
<tr>
<td>-f</td>
<td>强制覆盖已存在的文件</td>
</tr>
<tr>
<td>-l</td>
<td>优先下载整个列表</td>
</tr>
<tr>
<td>-P</td>
<td>使用密码（若访问视频需要密码）</td>
</tr>
<tr>
<td>-t</td>
<td>设置超时时间，单位是秒</td>
</tr>
<tr>
<td>-c</td>
<td>使用 cookie，加载 cookies.txt 或者 cookies.sqlite</td>
</tr>
</tbody>
</table>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用">#</a> 使用</h2>
<p>​        好的终于是安装成功了，可以愉快的开始使用了。</p>
<p>​        我们这里以蛋黄派 2021.9.7 更新的视频为例来下载。</p>
<p>​        输入如下语句来进行下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get https://www.bilibili.com/video/BV1Eb4y1U7hY?spm_id_from=333.851.b_7265636f6d6d656e64.1</span><br></pre></td></tr></table></figure>
<p>​        之后就可以在默认路径下找到你下载的视频啦～</p>
<p><img src="https://s3.bmp.ovh/imgs/2021/09/fbaaaa0c69a96bb6.png" alt></p>
<p>​        下载成功的话会有一个 MP4 文件和一个 XML 文件，分别对应视频和弹幕。</p>
<p>​        在这个步骤部分小伙伴会有疑问：<strong>为森么我下载下来是 FLV 文件和 XML 文件呢</strong>？</p>
<p>我们可以通过 -i 指令来查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get -i https://www.bilibili.com/video/BV1Eb4y1U7hY?spm_id_from=333.851.b_7265636f6d6d656e64.1</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2021/09/4e6e16c7e83a9394.png" alt></p>
<p>​        在这里我们可以找到 1080p 的 MP4 格式的下载指令，于是我们删除之前下载的文件，输入如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get --format=dash-flv https://www.bilibili.com/video/BV1Eb4y1U7hY?spm_id_from=333.851.b_7265636f6d6d656e64.1</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2021/09/af6db85327aa8ef7.png" alt></p>
<p>​        在这一步之后，有人（比如我）会发现：<strong>咦？为森么下载了两个 MP4 文件，是原视频的音频和视频分开的那种</strong>。</p>
<p>​        这里就要提到一个叫<strong> FFmpeg</strong> 的东西了，它可以解决这个问题，具体解决方法建议自行百度 / 必应。（主要是因为我的问题是萱琪姐姐帮忙解决的，具体操作我也不是很清楚</p>
<p>​       还要推荐一个叫 Windows powerShell 的东西，这个也比较好用。在文件夹处 shift + 邮件即可呼出，我们可以通过 Windows powerShell 来使用 git 和 cmd，当然使用 Windows powerShell 配合 you-get 下载也十分的方便。</p>
<p>​        最后附上 Windows powerShell 的下载界面。<br>
<img src="https://s3.bmp.ovh/imgs/2021/09/5f81eae2d969af1a.png" alt></p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>最大正方形</title>
    <url>/passages/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="最大正方形"><a class="markdownIt-Anchor" href="#最大正方形">#</a> <strong>最大正方形</strong></h1>
<p>​		大一 -&gt; 大二暑期算法作业</p>
<p>​		<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>
<h2 id="看到题目的感想"><a class="markdownIt-Anchor" href="#看到题目的感想">#</a> <strong>看到题目的感想</strong></h2>
<p>​		寻找最大正方形是小时候经常玩的一种游戏，说是可以锻炼观察力与判断力什么的，现在也会有家长带着小孩玩这个游戏，不过不是很多。</p>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> <strong>题目描述</strong></h2>
<p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" alt></p>
<p>输入：matrix = [[“1”,“0”,“1”,“0”,“0”],[“1”,“0”,“1”,“1”,“1”],[“1”,“1”,“1”,“1”,“1”],[“1”,“0”,“0”,“1”,“0”]]<br>
 输出：4</p>
<p>示例 2：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg" alt></p>
<p>输入：matrix = [[“0”,“1”],[“1”,“0”]]<br>
 输出：1</p>
<p>示例 3：</p>
<p>输入：matrix = [[“0”]]<br>
 输出：0</p>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/maximal-square">https://leetcode-cn.com/problems/maximal-square</a><br>
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答">#</a> <strong>题目解答</strong></h2>
<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>
<h3 id="1-暴力计算"><a class="markdownIt-Anchor" href="#1-暴力计算">#</a> 1、<strong>暴力计算</strong></h3>
<h4 id="1解题思路"><a class="markdownIt-Anchor" href="#1解题思路">#</a> <strong>（1）解题思路</strong></h4>
<p>语言描述不是很棒，大家凑活看叭，┭┮﹏┭┮</p>
<p>想了想，暴力计算是最简单直观的做法，具体做法如下：</p>
<ol>
<li>遍历矩阵中的元素，当遇到 1 时，将该元素作为正方形的左上角的位置。</li>
<li>确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围 - 不能超出矩阵的行和列），在该范围内寻找只包含 1 的最大正方形；</li>
<li>每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 1。（方便起见，需要先判断选取的点的右下角的点是否为 1。若不是，则跳出本次循环并储存当前的最大正方形，找到下一个元素是 1 的节点作为左上角点，重复 2、3 步；若是，则判断下一行和右一列的其他元素是否都为 1 <strong>（注：这里不是下一行右一列的所有元素，而是初始左上角和以当前点为右下角的正方形的范围内的点，如下图）</strong> ，若不都为 1，则跳出本次循环并储存当前的最大正方形，找到下一个元素是 1 的节点作为左上角点，重复 2、3 步；若都为 1，则继续第 3 步）。</li>
</ol>
<h4 id="2代码"><a class="markdownIt-Anchor" href="#2代码">#</a> <strong>（2）代码</strong></h4>
<p><strong>配合题目链接食用</strong></p>
<h5 id="java"><a class="markdownIt-Anchor" href="#java">#</a> java</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123; <span class="comment">// 没有矩阵或矩阵大小为0时</span></span><br><span class="line">            <span class="keyword">return</span> maxSide;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123; <span class="comment">// 遇到一个 1 作为正方形的左上角</span></span><br><span class="line">                    maxSide = Math.max(maxSide, <span class="number">1</span>); <span class="comment">// 更新可能的最大正方形边长</span></span><br><span class="line">                    <span class="keyword">int</span> currentMaxSide = Math.min(rows - i, columns - j); <span class="comment">// 当前最大正方形边长</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; currentMaxSide; k++) &#123; <span class="comment">// 判断新增的一行一列是否均为 1</span></span><br><span class="line">                        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + k][j + k] == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 判断右下角的点</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123; <span class="comment">// 判断下一行右一列</span></span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + k][j + m] == <span class="string">&#x27;0&#x27;</span> || matrix[i + m][j + k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 若判断都是1，则更新，不是则退出本次循环，寻找下一个左上角</span></span><br><span class="line">                            maxSide = Math.max(maxSide, k + <span class="number">1</span>); <span class="comment">// 更新可能的最大正方形边长</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/185126/31/21226/19810/61284443E0d3f0dfd/b2db3058f56d7f8b.png" alt="image-20210827093335340.png"></p>
<h4 id="3总结"><a class="markdownIt-Anchor" href="#3总结">#</a> <strong>（3）总结</strong></h4>
<p>​		暴力的思路比其他方法简单（但是我的描述可能会有些不顺畅），但是效率不高。</p>
<h3 id="2-dp算法动态规划来自题解"><a class="markdownIt-Anchor" href="#2-dp算法动态规划来自题解">#</a> <strong>2、dp 算法（动态规划）（来自题解）</strong></h3>
<p>​		又一次见到了动态规划，还是有无从下手的感觉。</p>
<h4 id="1解题思路-2"><a class="markdownIt-Anchor" href="#1解题思路-2">#</a> <strong>（1）解题思路</strong></h4>
<p>​		方法一虽然直观，但是时间复杂度太高，有没有办法降低时间复杂度呢？</p>
<p>可以使用动态规划降低时间复杂度。我们用 dp (i,j) 表示以 (i,j) 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp (i,j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p>
<p>那么如何计算 dp 中的每个元素值呢？对于每个位置 (i,j)，检查在矩阵中该位置的值：</p>
<ul>
<li>
<p>如果该位置的值是 0，则 dp (i,j)=0，因为当前位置不可能在由 1 组成的正方形中；</p>
</li>
<li>
<p>如果该位置的值是 11，则 dp (i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p>
<p>​	dp(i,j) = min( dp(i−1,j) , dp(i−1,j−1) , dp(i,j−1) ) + 1</p>
<p>如果读者对这个状态转移方程感到不解，<a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-2/">可以参考 1277. 统计全为 1 的正方形子矩阵的官方题解</a>，其中给出了详细的证明。</p>
</li>
</ul>
<p>此外，还需要考虑边界条件。如果 i 和 j 中至少有一个为 0，则以位置 (i, j)(i,j) 为右下角的最大正方形的边长只能是 11，因此 dp (i,j)=1。</p>
<p>以下用一个例子具体说明。原始矩阵如下。</p>
<p>0 1 1 1 0<br>
1 1 1 1 0<br>
0 1 1 1 1<br>
0 1 1 1 1<br>
0 0 1 1 1<br>
 对应的 dp 值如下。</p>
<p>0 1 1 1 0<br>
1 1 2 2 0<br>
0 1 2 3 1<br>
0 1 2 3 2<br>
0 0 1 2 3</p>
<p>下图也给出了计算 dp 值的过程。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/221/221_fig1.png" alt></p>
<h4 id="2代码-2"><a class="markdownIt-Anchor" href="#2代码-2">#</a> <strong>（2）代码</strong></h4>
<p><strong>配合题目链接食用</strong></p>
<h5 id="java-2"><a class="markdownIt-Anchor" href="#java-2">#</a> Java</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxSide;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h5 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C++</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(columns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = <span class="built_in">max</span>(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h4 id="3总结-2"><a class="markdownIt-Anchor" href="#3总结-2">#</a> <strong>（3）总结</strong></h4>
<p>​		动态规划解题的思想还需要学习，现在还上不了手。</p>
<h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> <strong>题目总结</strong></h2>
<p>​		这次的题目是数最大正方形，暴力方法还是最先考虑到的，之后菜知道动态规划也可以解决。（动态规划现在还属实不会）</p>
]]></content>
      <tags>
        <tag>算法作业</tag>
      </tags>
  </entry>
  <entry>
    <title>爬楼梯</title>
    <url>/passages/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="爬楼梯"><a class="markdownIt-Anchor" href="#爬楼梯">#</a> 爬楼梯</h1>
<p>​		大一 -&gt; 大二暑期算法作业</p>
<p>​		<strong>本文档中有对动态规划的解读（来自题解）</strong></p>
<p>​		<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>
<h2 id="看到题目的想法"><a class="markdownIt-Anchor" href="#看到题目的想法">#</a> 看到题目的想法</h2>
<p>​		这是一道比较经典的题目，之前好像见过类似的题目，所以上手还是有一些思路的。</p>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意</strong>：给定 n 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<p>输入： 2<br>
 输出： 2<br>
 解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<p><strong>示例 2：</strong></p>
<p>输入： 3<br>
 输出： 3<br>
 解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
<li></li>
</ol>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/climbing-stairs">https://leetcode-cn.com/problems/climbing-stairs</a><br>
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答">#</a> 题目解答</h2>
<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>
<h3 id="1动态规划"><a class="markdownIt-Anchor" href="#1动态规划">#</a> 1. 动态规划</h3>
<h4 id="1解题思路"><a class="markdownIt-Anchor" href="#1解题思路">#</a> （1）解题思路</h4>
<p>​       刚开始事项用递归写一下的，后来发现递归会超时，于是选用了动态规划。</p>
<p>​       这是一道典型的动态规划题，<strong>由于每步只能走一或两阶台阶，所以到达这一阶的方法数是 跨一阶到达 + 跨两阶到达</strong>。所以走到第一阶有一种方法，走到第二阶有两种方法，<strong>从第三阶开始</strong>，每一阶的方法数等于前两阶的方法数的代数和（跨一阶到达 + 跨两阶到达）（ps：可以用数组储存，但没必要，因为我们需要的是最终结果。</p>
<p>​       （有斐波那契那味了。</p>
<h4 id="2代码"><a class="markdownIt-Anchor" href="#2代码">#</a> （2）代码</h4>
<p>​		由于思路比较简单，也是顺利的写出了代码。（<strong>配合题目链接食用</strong>）</p>
<h5 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C++</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 遍历计算直到算出想要的结果</span></span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r; <span class="comment">// 返回想要的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img14.360buyimg.com/ddimg/jfs/t1/178109/1/21048/19824/612843b1Ebbddf701/64ca411d00d898bb.png" alt="image-20210827092530062.png"></p>
<h5 id="java"><a class="markdownIt-Anchor" href="#java">#</a> Java</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 遍历计算直到算出想要的结果</span></span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r; <span class="comment">// 返回想要的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/192688/38/20306/19931/612843c8Ead5d61e5/fbbd50516680a252.png" alt="image-20210827092554179.png"></p>
<h5 id="c-2"><a class="markdownIt-Anchor" href="#c-2">#</a> C</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 遍历计算直到算出想要的结果</span></span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r; <span class="comment">// 返回想要的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/181789/27/21163/20033/612843d9E4033bcc2/15eb1d8b958eb431.png" alt="image-20210827092619237.png"></p>
<h4 id="3总结"><a class="markdownIt-Anchor" href="#3总结">#</a> （3）总结</h4>
<p>​		这样直接计算的方法思路很简单，但是问题是计算的结果无法保留，用一次就要重新计算一次，十分的不方便。</p>
<h3 id="2斐波那契数列"><a class="markdownIt-Anchor" href="#2斐波那契数列">#</a> 2. 斐波那契数列</h3>
<h4 id="1解题思路-2"><a class="markdownIt-Anchor" href="#1解题思路-2">#</a> （1）解题思路</h4>
<p>​		不难看出，此题的数据就是我们熟悉的<strong>斐波那契数列</strong>，因此我们可以<strong>借助斐波那契数列的通项公式</strong>来快速算出我们想要的结果（前一种解发是从头计算出来的，台阶数较大时效率低  。</p>
<p>​		这种方法简单粗暴，就是通项公式不好记。</p>
<p>​		通项公式的推导过程就不写了，可以去题解里面看一下。+</p>
<p><strong>题目链接（去看官方题解）：<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/">https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</a></strong></p>
<h4 id="2代码-2"><a class="markdownIt-Anchor" href="#2代码-2">#</a> （2）代码</h4>
<h5 id="c-3"><a class="markdownIt-Anchor" href="#c-3">#</a> C++</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibn = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>); <span class="comment">// 斐波那契数列通项公式</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">round</span>(fibn / sqrt5); <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/186997/39/20254/20066/612843eaE3f9c5968/88a470ca748a910b.png" alt="image-20210827092637917.png"></p>
<h5 id="java-2"><a class="markdownIt-Anchor" href="#java-2">#</a> Java</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibn = Math.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - Math.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>); <span class="comment">// 斐波那契数列通项公式</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.round(fibn / sqrt5); <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/197749/9/5098/19966/612843f7E025f4b3d/8647b6a5672410fd.png" alt="image-20210827092704192.png"></p>
<h5 id="c-4"><a class="markdownIt-Anchor" href="#c-4">#</a> C</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">double</span> fibn = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>); <span class="comment">// 斐波那契数列通项公式</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) round(fibn / sqrt5); <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img12.360buyimg.com/ddimg/jfs/t1/197249/18/5090/19858/61284418E58cc0b79/4adf3d43edded4c7.png" alt="image-20210827092720313.png"></p>
<h4 id="3总结-2"><a class="markdownIt-Anchor" href="#3总结-2">#</a> （3）总结</h4>
<p>​		这种解决办法方便快捷，也不会浪费多余的时间空间来计算，比较好用。<strong>（缺点就是通项公式并不容易记住）</strong></p>
<h3 id="3矩阵快速幂来自题解"><a class="markdownIt-Anchor" href="#3矩阵快速幂来自题解">#</a> 3. 矩阵快速幂（来自题解）</h3>
<h4 id="1解题思路-代码"><a class="markdownIt-Anchor" href="#1解题思路-代码">#</a> （1）解题思路 + 代码</h4>
<p>​		说实话，行看到这种方法的时候<strong>感觉回到了线性代数的课堂上</strong>，又是熟悉的矩阵操作，让人头疼</p>
<p>​		具体的解题思路和代码就不搬过来了，可以去<strong>官方题解</strong>下查看。</p>
<p><strong>题目链接（去看官方题解）：<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/">https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</a></strong></p>
<h4 id="2总结"><a class="markdownIt-Anchor" href="#2总结">#</a> （2）总结</h4>
<p>​		<strong>利用矩阵运算解题</strong>的方法还是没见过的，对我来说比较新奇，还需要认真的研究研究。</p>
<h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2>
<p>​		这道题的难度中规中矩，但也会有很奇妙很方便的解决方案，也让我知道了<strong>运用矩阵运算来解题</strong>的方法，很棒。</p>
<h2 id="拓展动态规划摘自题解"><a class="markdownIt-Anchor" href="#拓展动态规划摘自题解">#</a> 拓展（动态规划）（摘自题解）</h2>
<p>​		<strong>本部分附带原作者对本题的总结</strong></p>
<p>不少同学对动态规划还处于朦胧状态，我特意<strong>录了一期视频</strong>，讲一讲<strong>动态规划解题方法论</strong>，这里详细介绍了动规五部曲，相信结合本篇题解，会对你学习动态规划有所帮助。</p>
<p><strong>视频链接：<a href="https://www.bilibili.com/video/BV13Q4y197Wg">https://www.bilibili.com/video/BV13Q4y197Wg</a>)</strong></p>
<p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目 AC 之后，都不太清楚 dp [i] 表示的是什么。</p>
<p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中。</strong></p>
<p>状态转移公式（递推公式）是很重要，但动规<strong>不仅仅只有</strong>递推公式。</p>
<p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>
<ol>
<li>确定 dp 数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp 数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导 dp 数组</li>
</ol>
<p>一些同学可能想<strong>为什么要先确定递推公式，然后在考虑初始化</strong>呢？</p>
<p><strong>因为一些情况是递推公式决定了 dp 数组要如何初始化！</strong></p>
<p>后面的讲解中我都是围绕着这五点来进行讲解。</p>
<p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p>
<p>其实 确定递推公式 仅仅是解题里的一步而已！</p>
<p>一些同学知道递推公式，但搞不清楚 dp 数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p>
<p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p>
<h3 id="动态规划应该如何debug"><a class="markdownIt-Anchor" href="#动态规划应该如何debug">#</a> 动态规划应该如何 debug</h3>
<p>相信动规的题目，很大部分同学都是这样做的。</p>
<p>看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp 数组的初始化，递归公式，遍历顺序，处于一种黑盒的理解状态。</p>
<p><strong>写动规题目，代码出问题很正常！</strong></p>
<p><strong>找问题的最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p>
<p>一些同学对于 dp 的学习是黑盒的状态，就是不清楚 dp 数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。</p>
<p>这是一个很不好的习惯！</p>
<p><strong>做动规的题目，写代码之前一定要把状态转移在 dp 数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。</strong></p>
<p>然后再写代码，如果代码没通过就打印 dp 数组，看看是不是和自己预先推导的哪里不一样。</p>
<p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p>
<p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p>
<p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了。</strong></p>
<p>这也是我为什么在动规五步曲里强调推导 dp 数组的重要性。</p>
<p>举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？</p>
<p>发出这样的问题之前，其实可以自己先思考这三个问题：</p>
<ul>
<li>这道题目我举例推导状态转移公式了么？</li>
<li>我打印 dp 数组的日志了么？</li>
<li>打印出来了 dp 数组和我想的一样么？</li>
</ul>
<p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历 dp 数组的顺序。</p>
<p>然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。</p>
<p><strong>注意这里不是说不让大家问问题哈， 而是说问问题之前要有自己的思考，问题要问到点子上！</strong></p>
<p><strong>大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！</strong></p>
<p>如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。</p>
<p>所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。</p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h3>
<p>这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何 debug。</p>
<p>动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。</p>
<p>在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的 01 背包，leetcode 上的题目都是 01 背包的应用，而没有纯 01 背包的问题，那么就需要在把对应的理论知识讲解一下。</p>
<p>大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。</p>
<p>这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容，大家要重视起来哈。</p>
<h3 id="原作者对本题总结"><a class="markdownIt-Anchor" href="#原作者对本题总结">#</a> 原作者对本题总结</h3>
<p>这道题目和动态规划：斐波那契数题目基本是一样的，但是会发现本题相比动态规划：斐波那契数难多了，为什么呢？</p>
<p>关键是 动态规划：斐波那契数 题目描述就已经把动规五部曲里的递归公式和如何初始化都给出来了，剩下几部曲也自然而然的推出来了。</p>
<p>而本题，就需要逐个分析了，大家现在应该初步感受出关于动态规划，你该了解这些！里给出的动规五部曲了。</p>
<p>简单题是用来掌握方法论的，例如昨天斐波那契的题目够简单了吧，但昨天和今天可以使用一套方法分析出来的，这就是方法论！</p>
<p>所以不要轻视简单题，那种凭感觉就刷过去了，其实和没掌握区别不大，只有掌握方法论并说清一二三，才能触类旁通，举一反三哈！</p>
<h3 id="原作者的题目解答"><a class="markdownIt-Anchor" href="#原作者的题目解答">#</a> 原作者的题目解答</h3>
<p><strong>原作者的题目解答：<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/dai-ma-sui-xiang-lu-dong-tai-gui-hua-jin-y1hw/">https://leetcode-cn.com/problems/climbing-stairs/solution/dai-ma-sui-xiang-lu-dong-tai-gui-hua-jin-y1hw/</a></strong></p>
]]></content>
      <tags>
        <tag>算法作业</tag>
      </tags>
  </entry>
  <entry>
    <title>罗马数字转整数</title>
    <url>/passages/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1 id="罗马数字转整数"><a class="markdownIt-Anchor" href="#罗马数字转整数">#</a> 罗马数字转整数</h1>
<p>​		大一 -&gt; 大二暑期算法作业</p>
<p>​		<strong>分站已经上线简约风算法作业集合（也可以选择阅读模式</strong></p>
<h2 id="看到题目的想法"><a class="markdownIt-Anchor" href="#看到题目的想法">#</a> 看到题目的想法</h2>
<p>​		这个题目看起来挺有意思的，但是好像不好解。</p>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2>
<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ol>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ol>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<p>输入: “III”<br>
 输出: 3</p>
<p><strong>示例 2:</strong></p>
<p>输入: “IV”<br>
 输出: 4</p>
<p><strong>示例 3:</strong></p>
<p>输入: “IX”<br>
 输出: 9</p>
<p><strong>示例 4:</strong></p>
<p>输入: “LVIII”<br>
 输出: 58</p>
<p>解释: L = 50, V= 5, III = 3.</p>
<p><strong>示例 5:</strong></p>
<p>输入: “MCMXCIV”<br>
 输出: 1994<br>
 解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<p><strong>提示：</strong></p>
<ol>
<li>1 &lt;= s.length &lt;= 15</li>
<li>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)</li>
<li>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内</li>
<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>
<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>
<li>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</li>
</ol>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/roman-to-integer">https://leetcode-cn.com/problems/roman-to-integer</a><br>
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="题目解答"><a class="markdownIt-Anchor" href="#题目解答">#</a> 题目解答</h2>
<p>​       （**ps：** 由于做题时采用的是执行代码，并未提交，提交结果均为后来补上，所以时间均为两天前）</p>
<h3 id="1暴力解题"><a class="markdownIt-Anchor" href="#1暴力解题">#</a> 1. 暴力解题</h3>
<h4 id="1解题思路"><a class="markdownIt-Anchor" href="#1解题思路">#</a> （1）解题思路</h4>
<p>​		想了想还是选择了暴力解题（<strong>比较简单</strong>。</p>
<p>​		将特殊情况转为另一个<strong>不在   I， V， X， L，C，D 和 M</strong>  中的单独的字母；再重新挨个求和。</p>
<h4 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码">#</a> （2） 代码</h4>
<p>​		<strong>配合题目链接食用</strong></p>
<p><strong>C++</strong></p>
<p><strong>earse：</strong><a href="https://www.cnblogs.com/ylwn817/articles/1967689.html">C++ 中 string erase 函数的使用 (转载) - jackdesk - 博客园 (cnblogs.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++) <span class="comment">// 将特殊情况转换</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;I&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;I&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;X&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;X&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;C&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;C&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            s[i]=<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++) <span class="comment">// 挨个求和</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(s[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">5</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">50</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">100</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">500</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">9</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">40</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">90</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">400</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:&#123;</span><br><span class="line">                sum+=<span class="number">900</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/177610/31/20874/22139/612842cbEa0f226ee/d8b14650ce07f5ff.png" alt="image-20210827092938870.png"></p>
<h4 id="3总结"><a class="markdownIt-Anchor" href="#3总结">#</a> （3）总结</h4>
<p>​		暴力计算的方法想起来并不复杂，但是写起来麻烦（重复、相似比较多），而且代码的性能也不高，所以还是不建议采用暴力算法。</p>
<h3 id="2模拟来自题解"><a class="markdownIt-Anchor" href="#2模拟来自题解">#</a> 2. 模拟（来自题解）</h3>
<p>​		很巧妙的一种方法，看完之后情不自禁的妙了起来。</p>
<p>​		<strong>妙<sub>啊</sub>～</strong></p>
<p><strong>官方题解：<a href="https://leetcode-cn.com/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/">https://leetcode-cn.com/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/</a></strong></p>
<h4 id="1解题思路-2"><a class="markdownIt-Anchor" href="#1解题思路-2">#</a> （1）解题思路</h4>
<p>** 通常情况下，罗马数字中小的数字在大的数字的右边。** 若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。</p>
<p>例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。</p>
<p>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，<strong>若一个数字右侧的数字比它大，则将该数字的符号取反。</strong></p>
<p>例如 XIV 可视作 X−I+V=10−1+5=14。</p>
<h4 id="2代码"><a class="markdownIt-Anchor" href="#2代码">#</a> （2）代码</h4>
<p>这里用到了<strong> map</strong> 这个东西，可以看看</p>
<h5 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C++</h5>
<p><strong>C++map： <a href="https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html">https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html</a>  来源：某 C ++ 文档</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; symbolValues = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = symbolValues[s[i]];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; value &lt; symbolValues[s[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">                ans -= value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/196645/13/19919/22179/612842e5E892666a7/8ed9cac439b0d859.png" alt="image-20210827093012125.png"></p>
<h5 id="java"><a class="markdownIt-Anchor" href="#java">#</a> Java</h5>
<p><strong>java map：<a href="https://blog.csdn.net/qq_29373285/article/details/81487594">https://blog.csdn.net/qq_29373285/article/details/81487594</a></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; symbolValues = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = symbolValues.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; value &lt; symbolValues.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                ans -= value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/196645/13/19919/22179/612842e5E892666a7/8ed9cac439b0d859.png" alt="image-20210827093028025.png"></p>
<h4 id="3总结-2"><a class="markdownIt-Anchor" href="#3总结-2">#</a> （3）总结</h4>
<p>​		很巧妙地方法，是我没想到的，很棒。</p>
<h2 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结">#</a> 题目总结</h2>
<p>​		听题解说是很经典的字符串匹配的题目，感觉很有意思，就是没有想到巧妙地方法。需要再接再厉。</p>
]]></content>
      <tags>
        <tag>算法作业</tag>
      </tags>
  </entry>
  <entry>
    <title>newPage</title>
    <url>/passages/%E9%BB%91%E7%A5%9E%E8%AF%9D%E6%82%9F%E7%A9%BA%E6%B8%B8%E7%8E%A9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringBoot讲义-开发实用篇</title>
    <url>/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<h1 id="springboot开发实用篇"><a class="markdownIt-Anchor" href="#springboot开发实用篇">#</a> SpringBoot 开发实用篇</h1>
<h3 id="前言白嫖发言"><a class="markdownIt-Anchor" href="#前言白嫖发言">#</a> 前言（白嫖发言）</h3>
<p>​		这个笔记是从黑马老师那里嫖来的，放在这里是为了方便查看，没有商用的意思，转载请标明<strong>黑马程序员</strong>以及链接。</p>
<p>​				开发实用篇中因为牵扯到 SpringBoot 整合各种各样的技术，由于不是每个小伙伴对各种技术都有所掌握，所以在整合每一个技术之前，都会做一个快速的普及，这样的话内容整个开发实用篇所包含的内容就会比较多。各位小伙伴在学习的时候，如果对某一个技术不是很清楚，可以先跳过对应章节，或者先补充一下技术知识，然后再来看对应的课程。开发实用篇具体包含的内容如下：</p>
<ul>
<li>热部署</li>
<li>配置高级</li>
<li>测试</li>
<li>数据层解决方案</li>
<li>整合第三方技术</li>
<li>监控</li>
</ul>
<p>​		看目录感觉内容量并不是很大，但是在数据层解决方案和整合第三方技术中包含了大量的知识，一点一点慢慢学吧。下面开启第一部分热部署相关知识的学习</p>
<h2 id="kf-1热部署"><a class="markdownIt-Anchor" href="#kf-1热部署">#</a> KF-1. 热部署</h2>
<p>​		什么是热部署？简单说就是你程序改了，现在要重新启动服务器，嫌麻烦？不用重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。</p>
<p>​		热部署的功能是如何实现的呢？这就要分两种情况来说了，非 springboot 工程和 springboot 工程的热部署实现方式完全不一样。先说一下原始的非 springboot 项目是如何实现热部署的。</p>
<p><strong>非 springboot 项目热部署实现原理</strong></p>
<p>​		开发非 springboot 项目时，我们要制作一个 web 工程并通过 tomcat 启动，通常需要先安装 tomcat 服务器到磁盘中，开发的程序配置发布到安装的 tomcat 服务器上。如果想实现热部署的效果，这种情况其实有两种做法，一种是在 tomcat 服务器的配置文件中进行配置，这种做法与你使用什么 IDE 工具无关，不管你使用 eclipse 还是 idea 都行。还有一种做法是通过 IDE 工具进行配置，比如在 idea 工具中进行设置，这种形式需要依赖 IDE 工具，每款 IDE 工具不同，对应的配置也不太一样。但是核心思想是一样的，就是使用服务器去监控其中加载的应用，发现产生了变化就重新加载一次。</p>
<p>​		上面所说的非 springboot 项目实现热部署看上去是一个非常简单的过程，几乎每个小伙伴都能自己写出来。如果你不会写，我给你个最简单的思路，但是实际设计要比这复杂一些。例如启动一个定时任务，任务启动时记录每个文件的大小，以后每 5 秒比对一下每个文件的大小是否有改变，或者是否有新文件。如果没有改变，放行，如果有改变，刷新当前记录的文件信息，然后重新启动服务器，这就可以实现热部署了。当然，这个过程肯定不能这么做，比如我把一个打印输出的字符串 &quot;abc&quot; 改成 &quot;cba&quot;，比对大小是没有变化的，但是内容缺实变了，所以这么做肯定不行，只是给大家打个比方，而且重启服务器这就是冷启动了，不能算热部署，领会精神吧。</p>
<p>​		看上去这个过程也没多复杂，在 springboot 项目中难道还有其他的弯弯绕吗？还真有。</p>
<p><strong>springboot 项目热部署实现原理</strong></p>
<p>​		基于 springboot 开发的 web 工程其实有一个显著的特征，就是 tomcat 服务器内置了，还记得内嵌服务器吗？服务器是以一个对象的形式在 spring 容器中运行的。本来我们期望于 tomcat 服务器加载程序后由 tomcat 服务器盯着程序，你变化后我就重新启动重新加载，但是现在 tomcat 和我们的程序是平级的了，都是 spring 容器中的组件，这下就麻烦了，缺乏了一个直接的管理权，那该怎么做呢？简单，再搞一个程序 X 在 spring 容器中盯着你原始开发的程序 A 不就行了吗？确实，搞一个盯着程序 A 的程序 X 就行了，如果你自己开发的程序 A 变化了，那么程序 X 就命令 tomcat 容器重新加载程序 A 就 OK 了。并且这样做有一个好处，spring 容器中东西不用全部重新加载一遍，只需要重新加载你开发的程序那一部分就可以了，这下效率又高了，挺好。</p>
<p>​	下面就说说，怎么搞出来这么一个程序 X，肯定不是我们自己手写了，springboot 早就做好了，搞一个坐标导入进去就行了。</p>
<h3 id="kf-1-1手动启动热部署"><a class="markdownIt-Anchor" href="#kf-1-1手动启动热部署">#</a> KF-1-1. 手动启动热部署</h3>
<p><strong>步骤①</strong>：导入开发者工具对应的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：构建项目，可以使用快捷键激活此功能</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220222121257218.png" alt="image-20220222121257218"></p>
<p>​		对应的快捷键一定要记得</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&lt;CTR&gt;L+&lt;F9&gt;</span><br></pre></td></tr></table></figure>
<p>​		以上过程就实现了 springboot 工程的热部署，是不是挺简单的。不过这里需要把底层的工作工程给普及一下。</p>
<p><strong>重启与重载</strong></p>
<p>​		一个 springboot 项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成 base 类加载器与 restart 类加载器。</p>
<ul>
<li>base 类加载器：用来加载 jar 包中的类，jar 包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化</li>
<li>restart 类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响</li>
</ul>
<p>​		当 springboot 项目启动时，base 类加载器执行，加载 jar 包中的信息后，restart 类加载器执行，加载开发者制作的内容。当执行构建项目后，由于 jar 中的信息不会变化，因此 base 类加载器无需再次执行，所以仅仅运行 restart 类加载即可，也就是将开发者自己制作的内容重新加载就行了，这就完成了一次热部署的过程，也可以说热部署的过程实际上是重新加载 restart 类加载器中的信息。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用开发者工具可以为当前项目开启热部署功能</li>
<li>使用构建项目操作对工程进行热部署</li>
</ol>
<p><strong>思考</strong></p>
<p>​		上述过程每次进行热部署都需要开发者手工操作，不管是点击按钮还是快捷键都需要开发者手工执行。这种操作的应用场景主要是在开发调试期，并且调试的代码处于不同的文件中，比如服务器启动了，我需要改 4 个文件中的内容，然后重启，等 4 个文件都改完了再执行热部署，使用一个快捷键就 OK 了。但是如果现在开发者要修改的内容就只有一个文件中的少量代码，这个时候代码修改完毕如果能够让程序自己执行热部署功能，就可以减少开发者的操作，也就是自动进行热部署，能这么做吗？是可以的。咱们下一节再说。</p>
<p>​</p>
<h3 id="kf-1-2自动启动热部署"><a class="markdownIt-Anchor" href="#kf-1-2自动启动热部署">#</a> KF-1-2. 自动启动热部署</h3>
<p>​		自动热部署其实就是设计一个开关，打开这个开关后，IDE 工具就可以自动热部署。因此这个操作和 IDE 工具有关，以下以 idea 为例设置 idea 中启动热部署</p>
<p><strong>步骤①</strong>：设置自动构建项目</p>
<p>​		打开【File】，选择【settings…】, 在面板左侧的菜单中找到【Compile】选项，然后勾选【Build project automatically】，意思是自动构建项目</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220222123543551.png" alt="image-20220222123543551"></p>
<p>​		自动构建项目选项勾选后</p>
<p><strong>步骤②</strong>：允许在程序运行时进行自动构建</p>
<p>​		使用快捷键【Ctrl】+【Alt】+【Shit】+【/】打开维护面板，选择第 1 项【Registry…】</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220222124006910.png" alt="image-20220222124006910"></p>
<p>​		在选项中搜索 comple，然后勾选对应项即可</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220222124240069.png" alt="image-20220222124240069" style="zoom:80%;">
<p>​		这样程序在运行的时候就可以进行自动构建了，实现了热部署的效果。</p>
<p><font color="#ff0000"><b>关注</b></font>：如果你每敲一个字母，服务器就重新构建一次，这未免有点太频繁了，所以 idea 设置当 idea 工具失去焦点 5 秒后进行热部署。其实就是你从 idea 工具中切换到其他工具时进行热部署，比如改完程序需要到浏览器上去调试，这个时候 idea 就自动进行热部署操作。</p>
<p><strong>总结</strong></p>
<ol>
<li>自动热部署要开启自动构建项目</li>
<li>自动热部署要开启在程序运行时自动构建项目</li>
</ol>
<p><strong>思考</strong></p>
<p>​		现在已经实现了热部署了，但是到企业开发的时候你会发现，为了便于管理，在你的程序目录中除了有代码，还有可能有文档，如果你修改了一下文档，这个时候会进行热部署吗？不管是否进行热部署，这个过程我们需要自己控制才比较合理，那这个东西能控制吗？咱们下一节再说。</p>
<h3 id="kf-1-3参与热部署监控的文件范围配置"><a class="markdownIt-Anchor" href="#kf-1-3参与热部署监控的文件范围配置">#</a> KF-1-3. 参与热部署监控的文件范围配置</h3>
<p>​		通过修改项目中的文件，你可以发现其实并不是所有的文件修改都会激活热部署的，原因在于在开发者工具中有一组配置，当满足了配置中的条件后，才会启动热部署，配置中默认不参与热部署的目录信息如下</p>
<ul>
<li>/META-INF/maven</li>
<li>/META-INF/resources</li>
<li>/resources</li>
<li>/static</li>
<li>/public</li>
<li>/templates</li>
</ul>
<p>​		以上目录中的文件如果发生变化，是不参与热部署的。如果想修改配置，可以通过 application.yml 文件进行设定哪些文件不参与热部署操作</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="comment"># 设置不参与热部署的文件或文件夹</span></span><br><span class="line">      <span class="attr">exclude:</span> <span class="string">static/**,public/**,config/application.yml</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>通过配置可以修改不参与热部署的文件或目录</li>
</ol>
<p><strong>思考</strong></p>
<p>​		热部署功能是一个典型的开发阶段使用的功能，到了线上环境运行程序时，这个功能就没有意义了。能否关闭热部署功能呢？咱们下一节再说。</p>
<h3 id="kf-1-4关闭热部署"><a class="markdownIt-Anchor" href="#kf-1-4关闭热部署">#</a> KF-1-4. 关闭热部署</h3>
<p>​		线上环境运行时是不可能使用热部署功能的，所以需要强制关闭此功能，通过配置可以关闭此功能。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>​		如果当心配置文件层级过多导致相符覆盖最终引起配置失效，可以提高配置的层级，在更高层级中配置关闭热部署。例如在启动容器前通过系统属性设置关闭热部署功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSMPApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;spring.devtools.restart.enabled&quot;</span>,<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        SpringApplication.run(SSMPApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其实上述担心略微有点多余，因为线上环境的维护是不可能出现修改代码的操作的，这么做唯一的作用是降低资源消耗，毕竟那双盯着你项目是不是产生变化的眼睛只要闭上了，就不具有热部署功能了，这个开关的作用就是禁用对应功能。</p>
<p><strong>总结</strong></p>
<ol>
<li>通过配置可以关闭热部署功能降低线上程序的资源消耗</li>
</ol>
<h2 id="kf-2配置高级"><a class="markdownIt-Anchor" href="#kf-2配置高级">#</a> KF-2. 配置高级</h2>
<p>​		进入开发实用篇第二章内容，配置高级，其实配置在基础篇讲了一部分，在运维实用篇讲了一部分，这里还要讲，讲的东西有什么区别呢？距离开发过程越来越接近，解决的问题也越来越靠近线上环境，下面就开启本章的学习。</p>
<h3 id="kf-2-1configurationproperties"><a class="markdownIt-Anchor" href="#kf-2-1configurationproperties">#</a> KF-2-1.@ConfigurationProperties</h3>
<p>​		在基础篇学习了 @ConfigurationProperties 注解，此注解的作用是用来为 bean 绑定属性的。开发者可以在 yml 配置文件中以对象的格式添加若干属性</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">servers:</span></span><br><span class="line">  <span class="attr">ip-address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> </span><br><span class="line">  <span class="attr">port:</span> <span class="number">2345</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>​		然后再开发一个用来封装数据的实体类，注意要提供属性对应的 setter 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		使用 @ConfigurationProperties 注解就可以将配置中的属性值关联到开发的模型类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		这样加载对应 bean 的时候就可以直接加载配置属性值了。但是目前我们学的都是给自定义的 bean 使用这种形式加载属性值，如果是第三方的 bean 呢？能不能用这种形式加载属性值呢？为什么会提出这个疑问？原因就在于当前 @ConfigurationProperties 注解是写在类定义的上方，而第三方开发的 bean 源代码不是你自己书写的，你也不可能到源代码中去添加 @ConfigurationProperties 注解，这种问题该怎么解决呢？下面就来说说这个问题。</p>
<p>​		使用 @ConfigurationProperties 注解其实可以为第三方 bean 加载属性，格式特殊一点而已。</p>
<p><strong>步骤①</strong>：使用 @Bean 注解定义第三方 bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">datasource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DruidDataSource ds = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：在 yml 中定义要绑定的属性，注意 datasource 此时全小写</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：使用 @ConfigurationProperties 注解为第三方 bean 进行属性绑定，注意前缀是全小写的 datasource</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">datasource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DruidDataSource ds = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		操作方式完全一样，只不过 @ConfigurationProperties 注解不仅能添加到类上，还可以添加到方法上，添加到类上是为 spring 容器管理的当前类的对象绑定属性，添加到方法上是为 spring 容器管理的当前方法的返回值对象绑定属性，其实本质上都一样。</p>
<p>​		做到这其实就出现了一个新的问题，目前我们定义 bean 不是通过类注解定义就是通过 @Bean 定义，使用 @ConfigurationProperties 注解可以为 bean 进行属性绑定，那在一个业务系统中，哪些 bean 通过注解 @ConfigurationProperties 去绑定属性了呢？因为这个注解不仅可以写在类上，还可以写在方法上，所以找起来就比较麻烦了。为了解决这个问题，spring 给我们提供了一个全新的注解，专门标注使用 @ConfigurationProperties 注解绑定属性的 bean 是哪些。这个注解叫做 @EnableConfigurationProperties。具体如何使用呢？</p>
<p><strong>步骤①</strong>：在配置类上开启 @EnableConfigurationProperties 注解，并标注要使用 @ConfigurationProperties 注解绑定属性的类</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">@SpringBootApplication</span></span><br><span class="line"><span class="string">@EnableConfigurationProperties(ServerConfig.class)</span></span><br><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">Springboot13ConfigurationApplication</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：在对应的类上直接使用 @ConfigurationProperties 进行属性绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		有人感觉这没区别啊？注意观察，现在绑定属性的 ServerConfig 类并没有声明 @Component 注解。当使用 @EnableConfigurationProperties 注解时，spring 会默认将其标注的类定义为 bean，因此无需再次声明 @Component 注解了。</p>
<p>​		最后再说一个小技巧，使用 @ConfigurationProperties 注解时，会出现一个提示信息</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220222145535749.png" alt="image-20220222145535749"></p>
<p>​		出现这个提示后只需要添加一个坐标此提醒就消失了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>使用 @ConfigurationProperties 可以为使用 @Bean 声明的第三方 bean 绑定属性</li>
<li>当使用 @EnableConfigurationProperties 声明进行属性绑定的 bean 后，无需使用 @Component 注解再次进行 bean 声明</li>
</ol>
<h3 id="kf-2-2宽松绑定松散绑定"><a class="markdownIt-Anchor" href="#kf-2-2宽松绑定松散绑定">#</a> KF-2-2. 宽松绑定 / 松散绑定</h3>
<p>​		在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在 yml 配置文件中将 datasource 修改为 dataSource，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dataSource:</span></span><br><span class="line">  <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<p>​		此时程序可以正常运行，然后又将代码中的前缀 datasource 修改为 dataSource，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;dataSource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">datasource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DruidDataSource ds = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		此时就发生了编译错误，而且并不是 idea 工具导致的，运行后依然会出现问题，配置属性名 dataSource 是无效的</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Configuration property name &#x27;dataSource&#x27; is <span class="keyword">not</span> valid:</span><br><span class="line"></span><br><span class="line">    Invalid characters: &#x27;S&#x27;</span><br><span class="line"><span class="function">    Bean: <span class="title">datasource</span></span></span><br><span class="line"><span class="function">    <span class="title">Reason</span>: <span class="title">Canonical</span> <span class="title">names</span> <span class="title">should</span> <span class="title">be</span> <span class="title">kebab</span>-<span class="title">case</span> (&#x27;-&#x27; <span class="title">separated</span>), <span class="title">lowercase</span> <span class="title">alpha</span>-<span class="title">numeric</span> <span class="title">characters</span> <span class="title">and</span> <span class="title">must</span> <span class="title">start</span> <span class="title">with</span> <span class="title">a</span> <span class="title">letter</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Action</span>:</span></span><br><span class="line"><span class="function"><span class="title">Modify</span> &#x27;<span class="title">dataSource</span>&#x27; <span class="title">so</span> <span class="title">that</span> <span class="title">it</span> <span class="title">conforms</span> <span class="title">to</span> <span class="title">the</span> <span class="title">canonical</span> <span class="title">names</span> <span class="title">requirements</span>.</span></span><br></pre></td></tr></table></figure>
<p>​		为什么会出现这种问题，这就要来说一说 springboot 进行属性绑定时的一个重要知识点了，有关属性名称的宽松绑定，也可以称为宽松绑定。</p>
<p>​		什么是宽松绑定？实际上是 springboot 进行编程时人性化设计的一种体现，即配置文件中的命名格式与变量名的命名格式可以进行格式上的最大化兼容。兼容到什么程度呢？几乎主流的命名格式都支持，例如：</p>
<p>​		在 ServerConfig 中的 ipAddress 属性名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		可以与下面的配置属性名规则全兼容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">servers:</span></span><br><span class="line">  <span class="attr">ipAddress:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span>       <span class="comment"># 驼峰模式</span></span><br><span class="line">  <span class="attr">ip_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span>      <span class="comment"># 下划线模式</span></span><br><span class="line">  <span class="attr">ip-address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span>      <span class="comment"># 烤肉串模式</span></span><br><span class="line">  <span class="attr">IP_ADDRESS:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span>      <span class="comment"># 常量模式</span></span><br></pre></td></tr></table></figure>
<p>​		也可以说，以上 4 种模式最终都可以匹配到 ipAddress 这个属性名。为什么这样呢？原因就是在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与 java 代码中的属性名进行忽略大小写的等值匹配，以上 4 种命名去掉下划线中划线忽略大小写后都是一个词 ipaddress，java 代码中的属性名忽略大小写后也是 ipaddress，这样就可以进行等值匹配了，这就是为什么这 4 种格式都能匹配成功的原因。不过 springboot 官方推荐使用烤肉串模式，也就是中划线模式。</p>
<p>​		到这里我们掌握了一个知识点，就是命名的规范问题。再来看开始出现的编程错误信息</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Configuration property name &#x27;dataSource&#x27; is <span class="keyword">not</span> valid:</span><br><span class="line"></span><br><span class="line">    Invalid characters: &#x27;S&#x27;</span><br><span class="line"><span class="function">    Bean: <span class="title">datasource</span></span></span><br><span class="line"><span class="function">    <span class="title">Reason</span>: <span class="title">Canonical</span> <span class="title">names</span> <span class="title">should</span> <span class="title">be</span> <span class="title">kebab</span>-<span class="title">case</span> (&#x27;-&#x27; <span class="title">separated</span>), <span class="title">lowercase</span> <span class="title">alpha</span>-<span class="title">numeric</span> <span class="title">characters</span> <span class="title">and</span> <span class="title">must</span> <span class="title">start</span> <span class="title">with</span> <span class="title">a</span> <span class="title">letter</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Action</span>:</span></span><br><span class="line"><span class="function"><span class="title">Modify</span> &#x27;<span class="title">dataSource</span>&#x27; <span class="title">so</span> <span class="title">that</span> <span class="title">it</span> <span class="title">conforms</span> <span class="title">to</span> <span class="title">the</span> <span class="title">canonical</span> <span class="title">names</span> <span class="title">requirements</span>.</span></span><br></pre></td></tr></table></figure>
<p>​		其中 Reason 描述了报错的原因，规范的名称应该是烤肉串 (kebab) 模式 (case)，即使用 - 分隔，使用小写字母数字作为标准字符，且必须以字母开头。然后再看我们写的名称 dataSource，就不满足上述要求。闹了半天，在书写前缀时，这个词不是随意支持的，必须使用上述标准。编程写了这么久，基本上编程习惯都养成了，到这里又被 springboot 教育了，没辙，谁让人家东西好用呢，按照人家的要求写吧。</p>
<p>​		最后说一句，以上规则仅针对 springboot 中 @ConfigurationProperties 注解进行属性绑定时有效，对 @Value 注解进行属性映射无效。有人就说，那我不用你不就行了？不用，你小看 springboot 的推广能力了，到原理篇我们看源码时，你会发现内部全是这玩意儿，算了，拿人手短吃人嘴短，认怂吧。</p>
<p><strong>总结</strong></p>
<ol>
<li>@ConfigurationProperties 绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上</li>
<li>@Value 注解不支持松散绑定规则</li>
<li>绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符</li>
</ol>
<h3 id="kf-2-3常用计量单位绑定"><a class="markdownIt-Anchor" href="#kf-2-3常用计量单位绑定">#</a> KF-2-3. 常用计量单位绑定</h3>
<p>​		在前面的配置中，我们书写了如下配置值，其中第三项超时时间 timeout 描述了服务器操作超时时间，当前值是 - 1 表示永不超时。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">servers:</span></span><br><span class="line">  <span class="attr">ip-address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> </span><br><span class="line">  <span class="attr">port:</span> <span class="number">2345</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>​		但是每个人都这个值的理解会产生不同，比如线上服务器完成一次主从备份，配置超时时间 240，这个 240 如果单位是秒就是超时时间 4 分钟，如果单位是分钟就是超时时间 4 小时。面对一次线上服务器的主从备份，设置 4 分钟，简直是开玩笑，别说拷贝过程，备份之前的压缩过程 4 分钟也搞不定，这个时候问题就来了，怎么解决这个误会？</p>
<p>​		除了加强约定之外，springboot 充分利用了 JDK8 中提供的全新的用来表示计量单位的新数据类型，从根本上解决这个问题。以下模型类中添加了两个 JDK8 中新增的类，分别是 Duration 和 DataSize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DurationUnit(ChronoUnit.HOURS)</span></span><br><span class="line">    <span class="keyword">private</span> Duration serverTimeOut;</span><br><span class="line">    <span class="meta">@DataSizeUnit(DataUnit.MEGABYTES)</span></span><br><span class="line">    <span class="keyword">private</span> DataSize dataSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Duration</strong>：表示时间间隔，可以通过 @DurationUnit 注解描述时间单位，例如上例中描述的单位为小时（ChronoUnit.HOURS）</p>
<p><strong>DataSize</strong>：表示存储空间，可以通过 @DataSizeUnit 注解描述存储空间单位，例如上例中描述的单位为 MB（DataUnit.MEGABYTES）</p>
<p>​		使用上述两个单位就可以有效避免因沟通不同步或文档不健全导致的信息不对称问题，从根本上解决了问题，避免产生误读。</p>
<p>Druation 常用单位如下：</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220222173911102.png" alt="image-20220222173911102" style="zoom:50%;">
<p>DataSize 常用单位如下：</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220222174130102.png" alt="image-20220222174130102" style="zoom:67%;">
<h3 id="kf-2-4校验"><a class="markdownIt-Anchor" href="#kf-2-4校验">#</a> KF-2-4. 校验</h3>
<p>​		目前我们在进行属性绑定时可以通过松散绑定规则在书写时放飞自我了，但是在书写时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要 int 类型，配置中给了非法的数值，例如写一个 “a&quot;，这种数据肯定无法有效的绑定，还会引发错误。		SpringBoot 给出了强大的数据校验功能，可以有效的避免此类问题的发生。在 JAVAEE 的 JSR303 规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架，此处使用 Hibernate 提供的校验框架来作为实现进行数据校验。书写应用格式非常固定，话不多说，直接上步骤</p>
<p><strong>步骤①</strong>：开启校验框架</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.导入JSR303规范--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用hibernate框架提供的校验器做实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：在需要开启校验功能的类上使用注解 @Validated 开启校验功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span></span><br><span class="line"><span class="comment">//开启对当前bean的属性注入校验</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：对具体的字段设置校验规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span></span><br><span class="line"><span class="comment">//开启对当前bean的属性注入校验</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置具体的规则</span></span><br><span class="line">    <span class="meta">@Max(value = 8888,message = &quot;最大值不能超过8888&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 202,message = &quot;最小值不能低于202&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		通过设置数据格式校验，就可以有效避免非法数据加载，其实使用起来还是挺轻松的，基本上就是一个格式。</p>
<p><strong>总结</strong></p>
<ol>
<li>开启 Bean 属性校验功能一共 3 步：导入 JSR303 与 Hibernate 校验框架坐标、使用 @Validated 注解启用校验功能、使用具体校验规则规范数据校验格式</li>
</ol>
<h3 id="kf-2-5数据类型转换"><a class="markdownIt-Anchor" href="#kf-2-5数据类型转换">#</a> KF-2-5. 数据类型转换</h3>
<p>​		有关 spring 属性注入的问题到这里基本上就讲完了，但是最近一名开发者向我咨询了一个问题，我觉得需要给各位学习者分享一下。在学习阶段其实我们遇到的问题往往复杂度比较低，单一性比较强，但是到了线上开发时，都是综合性的问题，而这个开发者遇到的问题就是由于 bean 的属性注入引发的灾难。</p>
<p>​		先把问题描述一下，这位开发者连接数据库正常操作，但是运行程序后显示的信息是密码错误。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">java.sql.SQLException: <span class="title">Access</span> <span class="title">denied</span> <span class="title">for</span> <span class="title">user</span> &#x27;<span class="title">root</span>&#x27;@&#x27;<span class="title">localhost</span>&#x27; (<span class="title">using</span> <span class="title">password</span>: <span class="title">YES</span>)</span></span><br></pre></td></tr></table></figure>
<p>​		其实看到这个报错，几乎所有的学习者都能分辨出来，这是用户名和密码不匹配，就就是密码输入错了，但是问题就在于密码并没有输入错误，这就比较讨厌了。给的报错信息无法帮助你有效的分析问题，甚至会给你带到沟里。如果是初学者，估计这会心态就崩了，我密码没错啊，你怎么能说我有错误呢？来看看用户名密码的配置是如何写的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">0127</span></span><br></pre></td></tr></table></figure>
<p>​		这名开发者的生日是 1 月 27 日，所以密码就使用了 0127，其实问题就出在这里了。</p>
<p>​		之前在基础篇讲属性注入时，提到过类型相关的知识，在整数相关知识中有这么一句话，<strong>支持二进制，八进制，十六进制</strong></p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220222225748370.png" alt="image-20220222225748370" style="zoom:80%;">
<p>​		这个问题就处在这里了，因为 0127 在开发者眼中是一个字符串 “0127”，但是在 springboot 看来，这就是一个数字，而且是一个八进制的数字。当后台使用 String 类型接收数据时，如果配置文件中配置了一个整数值，他是先安装整数进行处理，读取后再转换成字符串。巧了，0127 撞上了八进制的格式，所以最终以十进制数字 87 的结果存在了。</p>
<p>​		这里提两个注意点，第一，字符串标准书写加上引号包裹，养成习惯，第二，遇到 0 开头的数据多注意吧。</p>
<p><strong>总结</strong></p>
<ol>
<li>yaml 文件中对于数字的定义支持进制书写格式，如需使用字符串请使用引号明确标注</li>
</ol>
<h2 id="kf-3测试"><a class="markdownIt-Anchor" href="#kf-3测试">#</a> KF-3. 测试</h2>
<p>​		说完 bean 配置相关的内容，下面要对前面讲过的一个知识做加强了，测试。测试是保障程序正确性的唯一屏障，在企业级开发中更是不可缺少，但是由于测试代码往往不产生实际效益，所以一些小型公司并不是很关注，导致一些开发者从小型公司进入中大型公司后，往往这一块比较短板，所以还是要拿出来把这一块知识好好说说，做一名专业的开发人员。</p>
<h3 id="kf-3-1加载测试专用属性"><a class="markdownIt-Anchor" href="#kf-3-1加载测试专用属性">#</a> KF-3-1. 加载测试专用属性</h3>
<p>​		测试过程本身并不是一个复杂的过程，但是很多情况下测试时需要模拟一些线上情况，或者模拟一些特殊情况。如果当前环境按照线上环境已经设定好了，例如是下面的配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">maxMemory:</span> <span class="string">32GB</span></span><br><span class="line">  <span class="attr">minMemory:</span> <span class="string">16GB</span></span><br></pre></td></tr></table></figure>
<p>​		但是你现在想测试对应的兼容性，需要测试如下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">maxMemory:</span> <span class="string">16GB</span></span><br><span class="line">  <span class="attr">minMemory:</span> <span class="string">8GB</span></span><br></pre></td></tr></table></figure>
<p>​		这个时候我们能不能每次测试的时候都去修改源码 application.yml 中的配置进行测试呢？显然是不行的。每次测试前改过来，每次测试后改回去，这太麻烦了。于是我们就想，需要在测试环境中创建一组临时属性，去覆盖我们源码中设定的属性，这样测试用例就相当于是一个独立的环境，能够独立测试，这样就方便多了。</p>
<p><strong>临时属性</strong></p>
<p>​		springboot 已经为我们开发者早就想好了这种问题该如何解决，并且提供了对应的功能入口。在测试用例程序中，可以通过对注解 @SpringBootTest 添加属性来模拟临时属性，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//properties属性可以为当前测试用例添加临时的属性配置</span></span><br><span class="line"><span class="meta">@SpringBootTest(properties = &#123;&quot;test.prop=testValue1&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesAndArgsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;test.prop&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		使用注解 @SpringBootTest 的 properties 属性就可以为当前测试用例添加临时的属性，覆盖源码配置文件中对应的属性值进行测试。</p>
<p><strong>临时参数</strong></p>
<p>​		除了上述这种情况，在前面讲解使用命令行启动 springboot 程序时讲过，通过命令行参数也可以设置属性值。而且线上启动程序时，通常都会添加一些专用的配置信息。作为运维人员他们才不懂 java，更不懂这些配置的信息具体格式该怎么写，那如果我们作为开发者提供了对应的书写内容后，能否提前测试一下这些配置信息是否有效呢？当时是可以的，还是通过注解 @SpringBootTest 的另一个属性来进行设定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//args属性可以为当前测试用例添加临时的命令行参数</span></span><br><span class="line"><span class="meta">@SpringBootTest(args=&#123;&quot;--test.prop=testValue2&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesAndArgsTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;test.prop&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		使用注解 @SpringBootTest 的 args 属性就可以为当前测试用例模拟命令行参数并进行测试。</p>
<p>​		说到这里，好奇宝宝们肯定就有新问题了，如果两者共存呢？其实如果思考一下配置属性与命令行参数的加载优先级，这个结果就不言而喻了。在属性加载的优先级设定中，有明确的优先级设定顺序，还记得下面这个顺序吗？</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206100859236.png" alt="image-20211206100859236" style="zoom:67%;">
<p>​		在这个属性加载优先级的顺序中，明确规定了命令行参数的优先级排序是 11，而配置属性的优先级是 3，结果不言而喻了，args 属性配置优先于 properties 属性配置加载。</p>
<p>​		到这里我们就掌握了如果在测试用例中去模拟临时属性的设定。</p>
<p><strong>总结</strong></p>
<ol>
<li>加载测试临时属性可以通过注解 @SpringBootTest 的 properties 和 args 属性进行设定，此设定应用范围仅适用于当前测试用例</li>
</ol>
<p><strong>思考</strong></p>
<p>​		应用于测试环境的临时属性解决了，如果想在测试的时候临时加载一些 bean 能不做呢？也就是说我测试时，想搞一些独立的 bean 出来，专门应用于测试环境，能否实现呢？咱们下一节再讲。</p>
<h3 id="kf-3-2加载测试专用配置"><a class="markdownIt-Anchor" href="#kf-3-2加载测试专用配置">#</a> KF-3-2. 加载测试专用配置</h3>
<p>​		上一节提出了临时配置一些专用于测试环境的 bean 的需求，这一节我们就来解决这个问题。</p>
<p>​		学习过 Spring 的知识，我们都知道，其实一个 spring 环境中可以设置若干个配置文件或配置类，若干个配置信息可以同时生效。现在我们的需求就是在测试环境中再添加一个配置类，然后启动测试环境时，生效此配置就行了。其实做法和 spring 环境中加载多个配置信息的方式完全一样。具体操作步骤如下：</p>
<p><strong>步骤①</strong>：在测试包 test 中创建专用的测试环境配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bean msg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		上述配置仅用于演示当前实验效果，实际开发可不能这么注入 String 类型的数据</p>
<p><strong>步骤②</strong>：在启动测试环境时，导入测试环境专用的配置类，使用 @Import 注解即可实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Import(&#123;MsgConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testConfiguration</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		到这里就通过 @Import 属性实现了基于开发环境的配置基础上，对配置进行测试环境的追加操作，实现了 1+1 的配置环境效果。这样我们就可以实现每一个不同的测试用例加载不同的 bean 的效果，丰富测试用例的编写，同时不影响开发环境的配置。</p>
<p><strong>总结</strong></p>
<ol>
<li>定义测试环境专用的配置类，然后通过 @Import 注解在具体的测试中导入临时的配置，例如测试用例，方便测试过程，且上述配置不影响其他的测试类环境</li>
</ol>
<p><strong>思考</strong></p>
<p>​		当前我们已经可以实现业务层和数据层的测试，并且通过临时配置，控制每个测试用例加载不同的测试数据。但是实际企业开发不仅要保障业务层与数据层的功能安全有效，也要保障表现层的功能正常。但是我们目的对表现层的测试都是通过 postman 手工测试的，并没有在打包过程中体现表现层功能被测试通过。能否在测试用例中对表现层进行功能测试呢？还真可以，咱们下一节再讲。</p>
<h3 id="kf-3-3web环境模拟测试"><a class="markdownIt-Anchor" href="#kf-3-3web环境模拟测试">#</a> KF-3-3.Web 环境模拟测试</h3>
<p>​		在测试中对表现层功能进行测试需要一个基础和一个功能。所谓的一个基础是运行测试程序时，必须启动 web 环境，不然没法测试 web 功能。一个功能是必须在测试程序中具备发送 web 请求的能力，不然无法实现 web 功能的测试。所以在测试用例中测试表现层接口这项工作就转换成了两件事，一，如何在测试类中启动 web 测试，二，如何在测试类中发送 web 请求。下面一件事一件事进行，先说第一个</p>
<p><strong>测试类中启动 web 环境</strong></p>
<p>​		每一个 springboot 的测试类上方都会标准 @SpringBootTest 注解，而注解带有一个属性，叫做 webEnvironment。通过该属性就可以设置在测试用例中启动 web 环境，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebTest</span> </span>&#123;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		测试类中启动 web 环境时，可以指定启动的 Web 环境对应的端口，springboot 提供了 4 种设置值，分别如下：</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220223125453317.png" alt="image-20220223125453317" style="zoom:80%;">
<ul>
<li>MOCK：根据当前设置确认是否启动 web 环境，例如使用了 Servlet 的 API 就启动 web 环境，属于适配性的配置</li>
<li>DEFINED_PORT：使用自定义的端口作为 web 服务器端口</li>
<li>RANDOM_PORT：使用随机端口作为 web 服务器端口</li>
<li>NONE：不启动 web 环境</li>
</ul>
<p>​		通过上述配置，现在启动测试程序时就可以正常启用 web 环境了，建议大家测试时使用 RANDOM_PORT，避免代码中因为写死设定引发线上功能打包测试时由于端口冲突导致意外现象的出现。就是说你程序中写了用 8080 端口，结果线上环境 8080 端口被占用了，结果你代码中所有写的东西都要改，这就是写死代码的代价。现在你用随机端口就可以测试出来你有没有这种问题的隐患了。</p>
<p>​		测试环境中的 web 环境已经搭建好了，下面就可以来解决第二个问题了，如何在程序代码中发送 web 请求。</p>
<p><strong>测试类中发送请求</strong></p>
<p>​		对于测试类中发送请求，其实 java 的 API 就提供对应的功能，只不过平时各位小伙伴接触的比较少，所以较为陌生。springboot 为了便于开发者进行对应的功能开发，对其又进行了包装，简化了开发步骤，具体操作如下：</p>
<p><strong>步骤①</strong>：在测试类中开启 web 虚拟调用功能，通过注解 @AutoConfigureMockMvc 实现此功能的开启</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="comment">//开启虚拟MVC调用</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：定义发起虚拟调用的对象 MockMVC，通过自动装配的形式初始化对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="comment">//开启虚拟MVC调用</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testWeb</span><span class="params">(<span class="meta">@Autowired</span> MockMvc mvc)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：创建一个虚拟请求对象，封装请求的路径，并使用 MockMVC 对象发送对应请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="comment">//开启虚拟MVC调用</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testWeb</span><span class="params">(<span class="meta">@Autowired</span> MockMvc mvc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//http://localhost:8080/books</span></span><br><span class="line">        <span class="comment">//创建虚拟请求，当前访问/books</span></span><br><span class="line">        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(<span class="string">&quot;/books&quot;</span>);</span><br><span class="line">        <span class="comment">//执行对应的请求</span></span><br><span class="line">        mvc.perform(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		执行测试程序，现在就可以正常的发送 /books 对应的请求了，注意访问路径不要写 http://localhost:8080/books，因为前面的服务器 IP 地址和端口使用的是当前虚拟的 web 环境，无需指定，仅指定请求的具体路径即可。</p>
<p><strong>总结</strong></p>
<ol>
<li>在测试类中测试 web 层接口要保障测试类启动时启动 web 容器，使用 @SpringBootTest 注解的 webEnvironment 属性可以虚拟 web 环境用于测试</li>
<li>为测试方法注入 MockMvc 对象，通过 MockMvc 对象可以发送虚拟请求，模拟 web 请求调用过程</li>
</ol>
<p><strong>思考</strong></p>
<p>​		目前已经成功的发送了请求，但是还没有起到测试的效果，测试过程必须出现预计值与真实值的比对结果才能确认测试结果是否通过，虚拟请求中能对哪些请求结果进行比对呢？咱们下一节再讲。</p>
<p><strong>web 环境请求结果比对</strong></p>
<p>​		上一节已经在测试用例中成功的模拟出了 web 环境，并成功的发送了 web 请求，本节就来解决发送请求后如何比对发送结果的问题。其实发完请求得到的信息只有一种，就是响应对象。至于响应对象中包含什么，就可以比对什么。常见的比对内容如下：</p>
<ul>
<li>
<p>响应状态匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testStatus</span><span class="params">(<span class="meta">@Autowired</span> MockMvc mvc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(<span class="string">&quot;/books&quot;</span>);</span><br><span class="line">    ResultActions action = mvc.perform(builder);</span><br><span class="line">    <span class="comment">//设定预期值 与真实值进行比较，成功测试通过，失败测试失败</span></span><br><span class="line">    <span class="comment">//定义本次调用的预期值</span></span><br><span class="line">    StatusResultMatchers status = MockMvcResultMatchers.status();</span><br><span class="line">    <span class="comment">//预计本次调用时成功的：状态200</span></span><br><span class="line">    ResultMatcher ok = status.isOk();</span><br><span class="line">    <span class="comment">//添加预计值到本次调用过程中进行匹配</span></span><br><span class="line">    action.andExpect(ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>响应体匹配（非 json 数据格式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBody</span><span class="params">(<span class="meta">@Autowired</span> MockMvc mvc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(<span class="string">&quot;/books&quot;</span>);</span><br><span class="line">    ResultActions action = mvc.perform(builder);</span><br><span class="line">    <span class="comment">//设定预期值 与真实值进行比较，成功测试通过，失败测试失败</span></span><br><span class="line">    <span class="comment">//定义本次调用的预期值</span></span><br><span class="line">    ContentResultMatchers content = MockMvcResultMatchers.content();</span><br><span class="line">    ResultMatcher result = content.string(<span class="string">&quot;springboot2&quot;</span>);</span><br><span class="line">    <span class="comment">//添加预计值到本次调用过程中进行匹配</span></span><br><span class="line">    action.andExpect(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>响应体匹配（json 数据格式，开发中的主流使用方式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testJson</span><span class="params">(<span class="meta">@Autowired</span> MockMvc mvc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(<span class="string">&quot;/books&quot;</span>);</span><br><span class="line">    ResultActions action = mvc.perform(builder);</span><br><span class="line">    <span class="comment">//设定预期值 与真实值进行比较，成功测试通过，失败测试失败</span></span><br><span class="line">    <span class="comment">//定义本次调用的预期值</span></span><br><span class="line">    ContentResultMatchers content = MockMvcResultMatchers.content();</span><br><span class="line">    ResultMatcher result = content.json(<span class="string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;springboot2\&quot;,\&quot;type\&quot;:\&quot;springboot\&quot;&#125;&quot;</span>);</span><br><span class="line">    <span class="comment">//添加预计值到本次调用过程中进行匹配</span></span><br><span class="line">    action.andExpect(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>响应头信息匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testContentType</span><span class="params">(<span class="meta">@Autowired</span> MockMvc mvc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(<span class="string">&quot;/books&quot;</span>);</span><br><span class="line">    ResultActions action = mvc.perform(builder);</span><br><span class="line">    <span class="comment">//设定预期值 与真实值进行比较，成功测试通过，失败测试失败</span></span><br><span class="line">    <span class="comment">//定义本次调用的预期值</span></span><br><span class="line">    HeaderResultMatchers header = MockMvcResultMatchers.header();</span><br><span class="line">    ResultMatcher contentType = header.string(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    <span class="comment">//添加预计值到本次调用过程中进行匹配</span></span><br><span class="line">    action.andExpect(contentType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​		基本上齐了，头信息，正文信息，状态信息都有了，就可以组合出一个完美的响应结果比对结果了。以下范例就是三种信息同时进行匹配校验，也是一个完整的信息匹配过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGetById</span><span class="params">(<span class="meta">@Autowired</span> MockMvc mvc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(<span class="string">&quot;/books&quot;</span>);</span><br><span class="line">    ResultActions action = mvc.perform(builder);</span><br><span class="line"></span><br><span class="line">    StatusResultMatchers status = MockMvcResultMatchers.status();</span><br><span class="line">    ResultMatcher ok = status.isOk();</span><br><span class="line">    action.andExpect(ok);</span><br><span class="line"></span><br><span class="line">    HeaderResultMatchers header = MockMvcResultMatchers.header();</span><br><span class="line">    ResultMatcher contentType = header.string(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    action.andExpect(contentType);</span><br><span class="line"></span><br><span class="line">    ContentResultMatchers content = MockMvcResultMatchers.content();</span><br><span class="line">    ResultMatcher result = content.json(<span class="string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;springboot\&quot;,\&quot;type\&quot;:\&quot;springboot\&quot;&#125;&quot;</span>);</span><br><span class="line">    action.andExpect(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>web 虚拟调用可以对本地虚拟请求的返回响应信息进行比对，分为响应头信息比对、响应体信息比对、响应状态信息比对</li>
</ol>
<h3 id="kf-3-4数据层测试回滚"><a class="markdownIt-Anchor" href="#kf-3-4数据层测试回滚">#</a> KF-3-4. 数据层测试回滚</h3>
<p>​		当前我们的测试程序可以完美的进行表现层、业务层、数据层接口对应的功能测试了，但是测试用例开发完成后，在打包的阶段由于 test 生命周期属于必须被运行的生命周期，如果跳过会给系统带来极高的安全隐患，所以测试用例必须执行。但是新的问题就呈现了，测试用例如果测试时产生了事务提交就会在测试过程中对数据库数据产生影响，进而产生垃圾数据。这个过程不是我们希望发生的，作为开发者测试用例该运行运行，但是过程中产生的数据不要在我的系统中留痕，这样该如何处理呢？</p>
<p>​		springboot 早就为开发者想到了这个问题，并且针对此问题给出了最简解决方案，在原始测试用例中添加注解 @Transactional 即可实现当前测试用例的事务不提交。当程序运行后，只要注解 @Transactional 出现的位置存在注解 @SpringBootTest，springboot 就会认为这是一个测试程序，无需提交事务，所以也就可以避免事务的提交。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback(true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">&quot;springboot3&quot;</span>);</span><br><span class="line">        book.setType(<span class="string">&quot;springboot3&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;springboot3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		如果开发者想提交事务，也可以，再添加一个 @RollBack 的注解，设置回滚状态为 false 即可正常提交事务，是不是很方便？springboot 在辅助开发者日常工作这一块展现出了惊人的能力，实在太贴心了。</p>
<p><strong>总结</strong></p>
<ol>
<li>在 springboot 的测试类中通过添加注解 @Transactional 来阻止测试用例提交事务</li>
<li>通过注解 @Rollback 控制 springboot 测试类执行结果是否提交事务，需要配合注解 @Transactional 使用</li>
</ol>
<p><strong>思考</strong></p>
<p>​		当前测试程序已经近乎完美了，但是由于测试用例中书写的测试数据属于固定数据，往往失去了测试的意义，开发者可以针对测试用例进行针对性开发，这样就有可能出现测试用例不能完美呈现业务逻辑代码是否真实有效的达成业务目标的现象，解决方案其实很容易想，测试用例的数据只要随机产生就可以了，能实现吗？咱们下一节再讲。</p>
<h3 id="kf-3-5测试用例数据设定"><a class="markdownIt-Anchor" href="#kf-3-5测试用例数据设定">#</a> KF-3-5. 测试用例数据设定</h3>
<p>​		对于测试用例的数据固定书写肯定是不合理的，springboot 提供了在配置中使用随机值的机制，确保每次运行程序加载的数据都是随机的。具体如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">testcase:</span></span><br><span class="line">  <span class="attr">book:</span></span><br><span class="line">    <span class="attr">id:</span> <span class="string">$&#123;random.int&#125;</span></span><br><span class="line">    <span class="attr">id2:</span> <span class="string">$&#123;random.int(10)&#125;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">$&#123;random.int!5,10!&#125;</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">$&#123;random.value&#125;</span></span><br><span class="line">    <span class="attr">uuid:</span> <span class="string">$&#123;random.uuid&#125;</span></span><br><span class="line">    <span class="attr">publishTime:</span> <span class="string">$&#123;random.long&#125;</span></span><br></pre></td></tr></table></figure>
<p>​		当前配置就可以在每次运行程序时创建一组随机数据，避免每次运行时数据都是固定值的尴尬现象发生，有助于测试功能的进行。数据的加载按照之前加载数据的形式，使用 @ConfigurationProperties 注解即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;testcase.book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> publishTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		对于随机值的产生，还有一些小的限定规则，比如产生的数值性数据可以设置范围等，具体如下：</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220223135454862.png" alt="image-20220223135454862" style="zoom:80%;">
<ul>
<li>${random.int} 表示随机整数</li>
<li>${random.int (10)} 表示 10 以内的随机数</li>
<li>${random.int (10,20)} 表示 10 到 20 的随机数</li>
<li>其中 () 可以是任意字符，例如 []，!! 均可</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>使用随机数据可以替换测试用例中书写的固定数据，提高测试用例中的测试数据有效性</li>
</ol>
<h2 id="kf-4数据层解决方案"><a class="markdownIt-Anchor" href="#kf-4数据层解决方案">#</a> KF-4. 数据层解决方案</h2>
<p>​		开发实用篇前三章基本上是开胃菜，从第四章开始，开发实用篇进入到了噩梦难度了，从这里开始，不再是单纯的在 springboot 内部搞事情了，要涉及到很多相关知识。本章节主要内容都是和数据存储与读取相关，前期学习的知识与数据层有关的技术基本上都围绕在数据库这个层面上，所以本章要讲的第一个大的分支就是 SQL 解决方案相关的内容，除此之外，数据的来源还可以是非 SQL 技术相关的数据操作，因此第二部分围绕着 NOSQL 解决方案讲解。至于什么是 NOSQL 解决方案，讲到了再说吧。下面就从 SQL 解决方案说起。</p>
<h3 id="kf-4-1sql"><a class="markdownIt-Anchor" href="#kf-4-1sql">#</a> KF-4-1.SQL</h3>
<p>​		回忆一下之前做 SSMP 整合的时候数据层解决方案涉及到了哪些技术？MySQL 数据库与 MyBatisPlus 框架，后面又学了 Druid 数据源的配置，所以现在数据层解决方案可以说是 Mysql+Druid+MyBatisPlus。而三个技术分别对应了数据层操作的三个层面：</p>
<ul>
<li>数据源技术：Druid</li>
<li>持久化技术：MyBatisPlus</li>
<li>数据库技术：MySQL</li>
</ul>
<p>​		下面的研究就分为三个层面进行研究，对应上面列出的三个方面，咱们就从第一个数据源技术开始说起。</p>
<h4 id="数据源技术"><a class="markdownIt-Anchor" href="#数据源技术">#</a> 数据源技术</h4>
<p>​		目前我们使用的数据源技术是 Druid，运行时可以在日志中看到对应的数据源初始化信息，具体如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">INFO <span class="number">28600</span> --- [           main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSource</span><br><span class="line">INFO <span class="number">28600</span> --- [           main] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-<span class="number">1</span>&#125; inited</span><br></pre></td></tr></table></figure>
<p>​		如果不使用 Druid 数据源，程序运行后是什么样子呢？是独立的数据库连接对象还是有其他的连接池技术支持呢？将 Druid 技术对应的 starter 去掉再次运行程序可以在日志中找到如下初始化信息：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">INFO <span class="number">31820</span> --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Starting...</span><br><span class="line">INFO <span class="number">31820</span> --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - <span class="built_in">Start</span> completed.</span><br></pre></td></tr></table></figure>
<p>​		虽然没有 DruidDataSource 相关的信息了，但是我们发现日志中有 HikariDataSource 这个信息，就算不懂这是个什么技术，看名字也能看出来，以 DataSource 结尾的名称，这一定是一个数据源技术。我们又没有手工添加这个技术，这个技术哪里来的呢？这就是这一节要讲的知识，springboot 内嵌数据源。</p>
<p>​		数据层技术是每一个企业级应用程序都会用到的，而其中必定会进行数据库连接的管理。springboot 根据开发者的习惯出发，开发者提供了数据源技术，就用你提供的，开发者没有提供，那总不能手工管理一个一个的数据库连接对象啊，怎么办？我给你一个默认的就好了，这样省心又省事，大家都方便。</p>
<p>​		springboot 提供了 3 款内嵌数据源技术，分别如下：</p>
<ul>
<li>HikariCP</li>
<li>Tomcat 提供 DataSource</li>
<li>Commons DBCP</li>
</ul>
<p>​		第一种，HikartCP，这是 springboot 官方推荐的数据源技术，作为默认内置数据源使用。啥意思？你不配置数据源，那就用这个。</p>
<p>​		第二种，Tomcat 提供的 DataSource，如果不想用 HikartCP，并且使用 tomcat 作为 web 服务器进行 web 程序的开发，使用这个。为什么是 Tomcat，不是其他 web 服务器呢？因为 web 技术导入 starter 后，默认使用内嵌 tomcat，既然都是默认使用的技术了，那就一用到底，数据源也用它的。有人就提出怎么才能不使用 HikartCP 用 tomcat 提供的默认数据源对象呢？把 HikartCP 技术的坐标排除掉就 OK 了。</p>
<p>​		第三种，DBCP，这个使用的条件就更苛刻了，既不使用 HikartCP 也不使用 tomcat 的 DataSource 时，默认给你用这个。</p>
<p>​		springboot 这心操的，也是稀碎啊，就怕你自己管不好连接对象，给你一顿推荐，真是开发界的最强辅助。既然都给你奶上了，那就受用吧，怎么配置使用这些东西呢？之前我们配置 druid 时使用 druid 的 starter 对应的配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span>	</span><br><span class="line">   	  <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>​		换成是默认的数据源 HikariCP 后，直接吧 druid 删掉就行了，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>​		 当然，也可以写上是对 hikari 做的配置，但是 url 地址要单独配置，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>​		这就是配置 hikari 数据源的方式。如果想对 hikari 做进一步的配置，可以继续配置其独立的属性。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>​		如果不想使用 hikari 数据源，使用 tomcat 的数据源或者 DBCP 配置格式也是一样的。学习到这里，以后我们做数据层时，数据源对象的选择就不再是单一的使用 druid 数据源技术了，可以根据需要自行选择。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 技术提供了 3 种内置的数据源技术，分别是 Hikari、tomcat 内置数据源、DBCP</li>
</ol>
<h4 id="持久化技术"><a class="markdownIt-Anchor" href="#持久化技术">#</a> 持久化技术</h4>
<p>​		说完数据源解决方案，再来说一下持久化解决方案。springboot 充分发挥其最强辅助的特征，给开发者提供了一套现成的数据层技术，叫做 JdbcTemplate。其实这个技术不能说是 springboot 提供的，因为不使用 springboot 技术，一样能使用它，谁提供的呢？spring 技术提供的，所以在 springboot 技术范畴中，这个技术也是存在的，毕竟 springboot 技术是加速 spring 程序开发而创建的。</p>
<p>​		这个技术其实就是回归到 jdbc 最原始的编程形式来进行数据层的开发，下面直接上操作步骤：</p>
<p><strong>步骤①</strong>：导入 jdbc 对应的坐标，记得是 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&lt;/dependency</span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：自动装配 JdbcTemplate 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot15SqlApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> JdbcTemplate jdbcTemplate)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：使用 JdbcTemplate 实现查询操作（非实体类封装数据的查询操作）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> JdbcTemplate jdbcTemplate)</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;select * from tbl_book&quot;</span>;</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);</span><br><span class="line">    System.out.println(maps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤④</strong>：使用 JdbcTemplate 实现查询操作（实体类封装数据的查询操作）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> JdbcTemplate jdbcTemplate)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String sql = <span class="string">&quot;select * from tbl_book&quot;</span>;</span><br><span class="line">    RowMapper&lt;Book&gt; rm = <span class="keyword">new</span> RowMapper&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            Book temp = <span class="keyword">new</span> Book();</span><br><span class="line">            temp.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            temp.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            temp.setType(rs.getString(<span class="string">&quot;type&quot;</span>));</span><br><span class="line">            temp.setDescription(rs.getString(<span class="string">&quot;description&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    List&lt;Book&gt; list = jdbcTemplate.query(sql, rm);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤⑤</strong>：使用 JdbcTemplate 实现增删改操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testJdbcTemplateSave</span><span class="params">(<span class="meta">@Autowired</span> JdbcTemplate jdbcTemplate)</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;insert into tbl_book values(3,&#x27;springboot1&#x27;,&#x27;springboot2&#x27;,&#x27;springboot3&#x27;)&quot;</span>;</span><br><span class="line">    jdbcTemplate.update(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		如果想对 JdbcTemplate 对象进行相关配置，可以在 yml 文件中进行设定，具体如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jdbc:</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">query-timeout:</span> <span class="number">-1</span>   <span class="comment"># 查询超时时间</span></span><br><span class="line">      <span class="attr">max-rows:</span> <span class="number">500</span>       <span class="comment"># 最大行数</span></span><br><span class="line">      <span class="attr">fetch-size:</span> <span class="number">-1</span>      <span class="comment"># 缓存行数</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>SpringBoot 内置 JdbcTemplate 持久化解决方案</li>
<li>使用 JdbcTemplate 需要导入 spring-boot-starter-jdbc 的坐标</li>
</ol>
<h4 id="数据库技术"><a class="markdownIt-Anchor" href="#数据库技术">#</a> 数据库技术</h4>
<p>​		截止到目前，springboot 给开发者提供了内置的数据源解决方案和持久化解决方案，在数据层解决方案三件套中还剩下一个数据库，莫非 springboot 也提供有内置的解决方案？还真有，还不是一个，三个，这一节就来说说内置的数据库解决方案。</p>
<p>​		springboot 提供了 3 款内置的数据库，分别是</p>
<ul>
<li>H2</li>
<li>HSQL</li>
<li>Derby</li>
</ul>
<p>​		以上三款数据库除了可以独立安装之外，还可以像是 tomcat 服务器一样，采用内嵌的形式运行在 spirngboot 容器中。内嵌在容器中运行，那必须是 java 对象啊，对，这三款数据库底层都是使用 java 语言开发的。</p>
<p>​		我们一直使用 MySQL 数据库就挺好的，为什么有需求用这个呢？原因就在于这三个数据库都可以采用内嵌容器的形式运行，在应用程序运行后，如果我们进行测试工作，此时测试的数据无需存储在磁盘上，但是又要测试使用，内嵌数据库就方便了，运行在内存中，该测试测试，该运行运行，等服务器关闭后，一切烟消云散，多好，省得你维护外部数据库了。这也是内嵌数据库的最大优点，方便进行功能测试。</p>
<p>​		下面以 H2 数据库为例讲解如何使用这些内嵌数据库，操作步骤也非常简单，简单才好用嘛</p>
<p><strong>步骤①</strong>：导入 H2 数据库对应的坐标，一共 2 个</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：将工程设置为 web 工程，启动工程时启动 H2 数据库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：通过配置开启 H2 数据库控制台访问程序，也可以使用其他的数据库连接软件操作</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">h2:</span></span><br><span class="line">    <span class="attr">console:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/h2</span></span><br></pre></td></tr></table></figure>
<p>​		web 端访问路径 /h2，访问密码 123456，如果访问失败，先配置下列数据源，启动程序运行后再次访问 /h2 路径就可以正常访问了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:h2:~/test</span></span><br><span class="line">  <span class="attr">hikari:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤④</strong>：使用 JdbcTemplate 或 MyBatisPlus 技术操作数据库</p>
<p>（略）</p>
<p>​		其实我们只是换了一个数据库而已，其他的东西都不受影响。一个重要提醒，别忘了，上线时，把内存级数据库关闭，采用 MySQL 数据库作为数据持久化方案，关闭方式就是设置 enabled 属性为 false 即可。</p>
<p><strong>总结</strong></p>
<ol>
<li>H2 内嵌式数据库启动方式，添加坐标，添加配置</li>
<li>H2 数据库线上运行时请务必关闭</li>
</ol>
<p>​		到这里 SQL 相关的数据层解决方案就讲完了，现在的可选技术就丰富的多了。</p>
<ul>
<li>数据源技术：Druid、Hikari、tomcat DataSource、DBCP</li>
<li>持久化技术：MyBatisPlus、MyBatis、JdbcTemplate</li>
<li>数据库技术：MySQL、H2、HSQL、Derby</li>
</ul>
<p>​		现在开发程序时就可以在以上技术中任选一种组织成一套数据库解决方案了。</p>
<h3 id="kf-4-2nosql"><a class="markdownIt-Anchor" href="#kf-4-2nosql">#</a> KF-4-2.NoSQL</h3>
<p>​		SQL 数据层解决方案说完了，下面来说收 NoSQL 数据层解决方案。这个 NoSQL 是什么意思呢？从字面来看，No 表示否定，NoSQL 就是非关系型数据库解决方案，意思就是数据该存存该取取，只是这些数据不放在关系型数据库中了，那放在哪里？自然是一些能够存储数据的其他相关技术中了，比如 Redis 等。本节讲解的内容就是 springboot 如何整合这些技术，在 springboot 官方文档中提供了 10 种相关技术的整合方案，我们将讲解国内市场上最流行的几款 NoSQL 数据库整合方案，分别是 Redis、MongoDB、ES。</p>
<p>​		因为每个小伙伴学习这门课程的时候起点不同，为了便于各位学习者更好的学习，每种技术在讲解整合前都会先讲一下安装和基本使用，然后再讲整合。如果对某个技术比较熟悉的小伙伴可以直接跳过安装的学习过程，直接看整合方案即可。此外上述这些技术最佳使用方案都是在 Linux 服务器上部署，但是考虑到各位小伙伴的学习起点差异过大，所以下面的课程都是以 Windows 平台作为安装基础讲解，如果想看 Linux 版软件安装，可以再找到对应技术的学习文档查阅学习。</p>
<h4 id="springboot整合redis"><a class="markdownIt-Anchor" href="#springboot整合redis">#</a> SpringBoot 整合 Redis</h4>
<p>​		Redis 是一款采用 key-value 数据存储格式的内存级 NoSQL 数据库，重点关注数据存储格式，是 key-value 格式，也就是键值对的存储形式。与 MySQL 数据库不同，MySQL 数据库有表、有字段、有记录，Redis 没有这些东西，就是一个名称对应一个值，并且数据以存储在内存中使用为主。什么叫以存储在内存中为主？其实 Redis 有它的数据持久化方案，分别是 RDB 和 AOF，但是 Redis 自身并不是为了数据持久化而生的，主要是在内存中保存数据，加速数据访问的，所以说是一款内存级数据库。</p>
<p>​		Redis 支持多种数据存储格式，比如可以直接存字符串，也可以存一个 map 集合，list 集合，后面会涉及到一些不同格式的数据操作，这个需要先学习一下才能进行整合，所以在基本操作中会介绍一些相关操作。下面就先安装，再操作，最后说整合</p>
<h5 id="安装"><a class="markdownIt-Anchor" href="#安装">#</a> 安装</h5>
<p>​		windows 版安装包下载地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p>
<p>​		下载的安装包有两种形式，一种是一键安装的 msi 文件，还有一种是解压缩就能使用的 zip 文件，哪种形式都行，这里就不介绍安装过程了，本课程采用的是 msi 一键安装的 msi 文件进行安装的。</p>
<p>​		啥是 msi，其实就是一个文件安装包，不仅安装软件，还帮你把安装软件时需要的功能关联在一起，打包操作。比如如安装序列、创建和设置安装路径、设置系统依赖项、默认设定安装选项和控制安装过程的属性。说简单点就是一站式服务，安装过程一条龙操作一气呵成，就是为小白用户提供的软件安装程序。</p>
<p>​		安装完毕后会得到如下文件，其中有两个文件对应两个命令，是启动 Redis 的核心命令，需要再 CMD 命令行模式执行。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220224091709173.png" alt="image-20220224091709173" style="zoom: 80%;">
<p><strong>启动服务器</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure>
<p>​		初学者无需调整服务器对外服务端口，默认 6379。</p>
<p><strong>启动客户端</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">redis-cli.exe</span><br></pre></td></tr></table></figure>
<p>​		如果启动 redis 服务器失败，可以先启动客户端，然后执行 shutdown 操作后退出，此时 redis 服务器就可以正常执行了。</p>
<h5 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作">#</a> 基本操作</h5>
<p>​		服务器启动后，使用客户端就可以连接服务器，类似于启动完 MySQL 数据库，然后启动 SQL 命令行操作数据库。</p>
<p>​		放置一个字符串数据到 redis 中，先为数据定义一个名称，比如 name,age 等，然后使用命令 set 设置数据到 redis 服务器中即可</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> name itheima</span><br><span class="line"><span class="built_in">set</span> age <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>​		从 redis 中取出已经放入的数据，根据名称取，就可以得到对应数据。如果没有对应数据就会得到 (nil)</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">get name</span><br><span class="line">get age</span><br></pre></td></tr></table></figure>
<p>​		以上使用的数据存储是一个名称对应一个值，如果要维护的数据过多，可以使用别的数据存储结构。例如 hash，它是一种一个名称下可以存储多个数据的存储模型，并且每个数据也可以有自己的二级存储名称。向 hash 结构中存储数据格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset a a1 aa1		#对外key名称是a，在名称为a的存储模型中，a1这个key中保存了数据aa1</span><br><span class="line">hset a a2 aa2</span><br></pre></td></tr></table></figure>
<p>​		获取 hash 结构中的数据命令如下</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hget a a1			#得到aa1</span><br><span class="line">hget a a2			#得到aa2</span><br></pre></td></tr></table></figure>
<p>​		有关 redis 的基础操作就普及到这里，需要全面掌握 redis 技术，请参看相关教程学习。</p>
<h5 id="整合"><a class="markdownIt-Anchor" href="#整合">#</a> 整合</h5>
<p>​		在进行整合之前先梳理一下整合的思想，springboot 整合任何技术其实就是在 springboot 中使用对应技术的 API。如果两个技术没有交集，就不存在整合的概念了。所谓整合其实就是使用 springboot 技术去管理其他技术，几个问题是躲不掉的。</p>
<p>​		第一，需要先导入对应技术的坐标，而整合之后，这些坐标都有了一些变化</p>
<p>​		第二，任何技术通常都会有一些相关的设置信息，整合之后，这些信息如何写，写在哪是一个问题</p>
<p>​		第三，没有整合之前操作如果是模式 A 的话，整合之后如果没有给开发者带来一些便捷操作，那整合将毫无意义，所以整合后操作肯定要简化一些，那对应的操作方式自然也有所不同</p>
<p>​		按照上面的三个问题去思考 springboot 整合所有技术是一种通用思想，在整合的过程中会逐步摸索出整合的套路，而且适用性非常强，经过若干种技术的整合后基本上可以总结出一套固定思维。</p>
<p>​		下面就开始 springboot 整合 redis，操作步骤如下：</p>
<p><strong>步骤①</strong>：导入 springboot 整合 redis 的 starter 坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		上述坐标可以在创建模块的时候通过勾选的形式进行选择，归属 NoSQL 分类中</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220224101142220.png" alt="image-20220224101142220" style="zoom:50%;">
<p><strong>步骤②</strong>：进行基础配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<p>​		操作 redis，最基本的信息就是操作哪一台 redis 服务器，所以服务器地址属于基础配置信息，不可缺少。但是即便你不配置，目前也是可以用的。因为以上两组信息都有默认配置，刚好就是上述配置值。</p>
<p><strong>步骤③</strong>：使用 springboot 整合 redis 的专用客户端接口操作，此处使用的是 RedisTemplate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot16RedisApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ValueOperations ops = redisTemplate.opsForValue();</span><br><span class="line">        ops.set(<span class="string">&quot;age&quot;</span>,<span class="number">41</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ValueOperations ops = redisTemplate.opsForValue();</span><br><span class="line">        Object age = ops.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashOperations ops = redisTemplate.opsForHash();</span><br><span class="line">        ops.put(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashOperations ops = redisTemplate.opsForHash();</span><br><span class="line">        Object val = ops.get(<span class="string">&quot;info&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        System.out.println(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​		在操作 redis 时，需要先确认操作何种数据，根据数据种类得到操作接口。例如使用 opsForValue () 获取 string 类型的数据操作接口，使用 opsForHash () 获取 hash 类型的数据操作接口，剩下的就是调用对应 api 操作了。各种类型的数据操作接口如下：</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220224103104908.png" alt="image-20220224103104908" style="zoom:80%;">
<p><strong>总结</strong></p>
<ol>
<li>springboot 整合 redis 步骤
<ol>
<li>导入 springboot 整合 redis 的 starter 坐标</li>
<li>进行基础配置</li>
<li>使用 springboot 整合 redis 的专用客户端接口 RedisTemplate 操作</li>
</ol>
</li>
</ol>
<p><strong>StringRedisTemplate</strong></p>
<p>​		由于 redis 内部不提供 java 对象的存储格式，因此当操作的数据以对象的形式存在时，会进行转码，转换成字符串格式后进行操作。为了方便开发者使用基于字符串为数据的操作，springboot 整合 redis 时提供了专用的 API 接口 StringRedisTemplate，你可以理解为这是 RedisTemplate 的一种指定数据泛型的操作 API。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisTemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">        String name = ops.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>redis 客户端选择</strong></p>
<pre><code>	springboot整合redis技术提供了多种客户端兼容模式，默认提供的是lettucs客户端技术，也可以根据需要切换成指定客户端技术，例如jedis客户端技术，切换成jedis客户端技术操作步骤如下：
</code></pre>
<p><strong>步骤①</strong>：导入 jedis 坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		jedis 坐标受 springboot 管理，无需提供版本号</p>
<p><strong>步骤②</strong>：配置客户端技术类型，设置为 jedis</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">client-type:</span> <span class="string">jedis</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：根据需要设置对应的配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">client-type:</span> <span class="string">jedis</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">16</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p><strong>lettcus 与 jedis 区别</strong></p>
<ul>
<li>jedis 连接 Redis 服务器是直连模式，当多线程模式下使用 jedis 会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响</li>
<li>lettcus 基于 Netty 框架进行与 Redis 服务器连接，底层设计中采用 StatefulRedisConnection。 StatefulRedisConnection 自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然 lettcus 也支持多连接实例一起工作</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>springboot 整合 redis 提供了 StringRedisTemplate 对象，以字符串的数据格式操作 redis</li>
<li>如果需要切换 redis 客户端实现技术，可以通过配置的形式进行</li>
</ol>
<h4 id="springboot整合mongodb"><a class="markdownIt-Anchor" href="#springboot整合mongodb">#</a> SpringBoot 整合 MongoDB</h4>
<p>​		使用 Redis 技术可以有效的提高数据访问速度，但是由于 Redis 的数据格式单一性，无法操作结构化数据，当操作对象型的数据时，Redis 就显得捉襟见肘。在保障访问速度的情况下，如果想操作结构化数据，看来 Redis 无法满足要求了，此时需要使用全新的数据存储结束来解决此问题，本节讲解 springboot 如何整合 MongoDB 技术。</p>
<p>​		MongoDB 是一个开源、高性能、无模式的文档型数据库，它是 NoSQL 数据库产品中的一种，是最像关系型数据库的非关系型数据库。</p>
<p>​		上述描述中几个词，其中对于我们最陌生的词是无模式的。什么叫无模式呢？简单说就是作为一款数据库，没有固定的数据存储结构，第一条数据可能有 A、B、C 一共 3 个字段，第二条数据可能有 D、E、F 也是 3 个字段，第三条数据可能是 A、C、E3 个字段，也就是说数据的结构不固定，这就是无模式。有人会说这有什么用啊？灵活，随时变更，不受约束。基于上述特点，MongoDB 的应用面也会产生一些变化。以下列出了一些可以使用 MongoDB 作为数据存储的场景，但是并不是必须使用 MongoDB 的场景：</p>
<ul>
<li>淘宝用户数据
<ul>
<li>存储位置：数据库</li>
<li>特征：永久性存储，修改频度极低</li>
</ul>
</li>
<li>游戏装备数据、游戏道具数据
<ul>
<li>存储位置：数据库、Mongodb</li>
<li>特征：永久性存储与临时存储相结合、修改频度较高</li>
</ul>
</li>
<li>直播数据、打赏数据、粉丝数据
<ul>
<li>存储位置：数据库、Mongodb</li>
<li>特征：永久性存储与临时存储相结合，修改频度极高</li>
</ul>
</li>
<li>物联网数据
<ul>
<li>存储位置：Mongodb</li>
<li>特征：临时存储，修改频度飞速</li>
</ul>
</li>
</ul>
<p>​		快速了解一下 MongoDB，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合</p>
<h5 id="安装-2"><a class="markdownIt-Anchor" href="#安装-2">#</a> 安装</h5>
<p>​		windows 版安装包下载地址：<a href="https://www.mongodb.com/try/download">https://www.mongodb.com/try/download</a></p>
<p>​		下载的安装包也有两种形式，一种是一键安装的 msi 文件，还有一种是解压缩就能使用的 zip 文件，哪种形式都行，本课程采用解压缩 zip 文件进行安装。</p>
<p>​		解压缩完毕后会得到如下文件，其中 bin 目录包含了所有 mongodb 的可执行命令</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220224111306933.png" alt="image-20220224111306933"></p>
<p>​		mongodb 在运行时需要指定一个数据存储的目录，所以创建一个数据存储目录，通常放置在安装目录中，此处创建 data 的目录用来存储数据，具体如下</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220224111053408.png" alt="image-20220224111053408"></p>
<p>​		如果在安装的过程中出现了如下警告信息，就是告诉你，你当前的操作系统缺少了一些系统文件，这个不用担心。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220224113956882.png" alt="image-20220224113956882" style="zoom:50%;">
<p>​		根据下列方案即可解决，在浏览器中搜索提示缺少的名称对应的文件，并下载，将下载的文件拷贝到 windows 安装目录的 system32 目录下，然后在命令行中执行 regsvr32 命令注册此文件。根据下载的文件名不同，执行命令前更改对应名称。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">regsvr32 vcruntime140_1.dll</span><br></pre></td></tr></table></figure>
<p><strong>启动服务器</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mongod --dbpath=..\data\db</span><br></pre></td></tr></table></figure>
<p>​		启动服务器时需要指定数据存储位置，通过参数–dbpath 进行设置，可以根据需要自行设置数据存储路径。默认服务端口 27017。</p>
<p><strong>启动客户端</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mongo --host=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> --port=<span class="number">27017</span></span><br></pre></td></tr></table></figure>
<h5 id="基本操作-2"><a class="markdownIt-Anchor" href="#基本操作-2">#</a> 基本操作</h5>
<p>​		MongoDB 虽然是一款数据库，但是它的操作并不是使用 SQL 语句进行的，因此操作方式各位小伙伴可能比较陌生，好在有一些类似于 Navicat 的数据库客户端软件，能够便捷的操作 MongoDB，先安装一个客户端，再来操作 MongoDB。</p>
<p>​		同类型的软件较多，本次安装的软件时 Robo3t，Robot3t 是一款绿色软件，无需安装，解压缩即可。解压缩完毕后进入安装目录双击 robot3t.exe 即可使用。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220224114911573.png" alt="image-20220224114911573" style="zoom: 33%;">
<p>​		打开软件首先要连接 MongoDB 服务器，选择【File】菜单，选择【Connect…】</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220224115202422.png" alt="image-20220224115202422"></p>
<p>​		进入连接管理界面后，选择左上角的【Create】链接，创建新的连接设置</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220224115254200.png" alt="image-20220224115254200" style="zoom:80%;">
<p>​		如果输入设置值即可连接（默认不修改即可连接本机 27017 端口）</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220224115300266.png" alt="image-20220224115300266"></p>
<p>​		连接成功后在命令输入区域输入命令即可操作 MongoDB。</p>
<p>​		创建数据库：在左侧菜单中使用右键创建，输入数据库名称即可</p>
<p>​		创建集合：在 Collections 上使用右键创建，输入集合名称即可，集合等同于数据库中的表的作用</p>
<p>​		新增文档：（文档是一种类似 json 格式的数据，初学者可以先把数据理解为就是 json 数据）</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">db.集合名称.insert/save/insertOne(文档)</span><br></pre></td></tr></table></figure>
<p>​		删除文档：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">db.集合名称.remove(条件)</span><br></pre></td></tr></table></figure>
<p>​		修改文档：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">db.集合名称.update(条件，&#123;操作种类:&#123;文档&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>​		查询文档：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">基础查询</span><br><span class="line">查询全部：		   db.集合.<span class="built_in">find</span>();</span><br><span class="line">查第一条：		   db.集合.findOne()</span><br><span class="line">查询指定数量文档：	db.集合.<span class="built_in">find</span>().limit(<span class="number">10</span>)					//查<span class="number">10</span>条文档</span><br><span class="line">跳过指定数量文档：	db.集合.<span class="built_in">find</span>().skip(<span class="number">20</span>)					//跳过<span class="number">20</span>条文档</span><br><span class="line">统计：			  	db.集合.count()</span><br><span class="line">排序：				db.集合.<span class="built_in">sort</span>(&#123;age:<span class="number">1</span>&#125;)						//按age升序排序</span><br><span class="line">投影：				db.集合名称.<span class="built_in">find</span>(条件,&#123;name:<span class="number">1</span>,age:<span class="number">1</span>&#125;)		 //仅保留name与age域</span><br><span class="line"></span><br><span class="line">条件查询</span><br><span class="line">基本格式：			db.集合.<span class="built_in">find</span>(&#123;条件&#125;)</span><br><span class="line">模糊查询：			db.集合.<span class="built_in">find</span>(&#123;域名:/正则表达式/&#125;)		  //等同SQL中的like，比like强大，可以执行正则所有规则</span><br><span class="line">条件比较运算：		   db.集合.<span class="built_in">find</span>(&#123;域名:&#123;$gt:值&#125;&#125;)				//等同SQL中的数值比较操作，例如：name&gt;<span class="number">18</span></span><br><span class="line">包含查询：			db.集合.<span class="built_in">find</span>(&#123;域名:&#123;$<span class="keyword">in</span>:[值<span class="number">1</span>，值<span class="number">2</span>]&#125;&#125;)		//等同于SQL中的<span class="keyword">in</span></span><br><span class="line">条件连接查询：		   db.集合.<span class="built_in">find</span>(&#123;$and:[&#123;条件<span class="number">1</span>&#125;,&#123;条件<span class="number">2</span>&#125;]&#125;)	   //等同于SQL中的and、or</span><br></pre></td></tr></table></figure>
<p>​		有关 MongoDB 的基础操作就普及到这里，需要全面掌握 MongoDB 技术，请参看相关教程学习。</p>
<h5 id="整合-2"><a class="markdownIt-Anchor" href="#整合-2">#</a> 整合</h5>
<p>​		使用 springboot 整合 MongDB 该如何进行呢？其实 springboot 为什么使用的开发者这么多，就是因为他的套路几乎完全一样。导入坐标，做配置，使用 API 接口操作。整合 Redis 如此，整合 MongoDB 同样如此。</p>
<p>​		第一，先导入对应技术的整合 starter 坐标</p>
<p>​		第二，配置必要信息</p>
<p>​		第三，使用提供的 API 操作即可</p>
<p>​		下面就开始 springboot 整合 MongoDB，操作步骤如下：</p>
<p><strong>步骤①</strong>：导入 springboot 整合 MongoDB 的 starter 坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		上述坐标也可以在创建模块的时候通过勾选的形式进行选择，同样归属 NoSQL 分类中</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220224120721626.png" alt="image-20220224120721626" style="zoom: 67%;">
<p><strong>步骤②</strong>：进行基础配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">mongodb://localhost/itheima</span></span><br></pre></td></tr></table></figure>
<p>​		操作 MongoDB 需要的配置与操作 redis 一样，最基本的信息都是操作哪一台服务器，区别就是连接的服务器 IP 地址和端口不同，书写格式不同而已。</p>
<p><strong>步骤③</strong>：使用 springboot 整合 MongoDB 的专用客户端接口 MongoTemplate 来进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot17MongodbApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setId(<span class="number">2</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;springboot2&quot;</span>);</span><br><span class="line">        book.setType(<span class="string">&quot;springboot2&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;springboot2&quot;</span>);</span><br><span class="line">        mongoTemplate.save(book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Book&gt; all = mongoTemplate.findAll(Book.class);</span><br><span class="line">        System.out.println(all);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		整合工作到这里就做完了，感觉既熟悉也陌生。熟悉的是这个套路，三板斧，就这三招，导坐标做配置用 API 操作，陌生的是这个技术，里面具体的操作 API 可能会不熟悉，有关 springboot 整合 MongoDB 我们就讲到这里。有兴趣可以继续学习 MongoDB 的操作，然后再来这里通过编程的形式操作 MongoDB。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 整合 MongoDB 步骤
<ol>
<li>导入 springboot 整合 MongoDB 的 starter 坐标</li>
<li>进行基础配置</li>
<li>使用 springboot 整合 MongoDB 的专用客户端接口 MongoTemplate 操作</li>
</ol>
</li>
</ol>
<h4 id="springboot整合es"><a class="markdownIt-Anchor" href="#springboot整合es">#</a> SpringBoot 整合 ES</h4>
<p>​		NoSQL 解决方案已经讲完了两种技术的整合了，Redis 可以使用内存加载数据并实现数据快速访问，MongoDB 可以在内存中存储类似对象的数据并实现数据的快速访问，在企业级开发中对于速度的追求是永无止境的。下面要讲的内容也是一款 NoSQL 解决方案，只不过他的作用不是为了直接加速数据的读写，而是加速数据的查询的，叫做 ES 技术。</p>
<p>​		ES（Elasticsearch）是一个分布式全文搜索引擎，重点是全文搜索。</p>
<p>​		那什么是全文搜索呢？比如用户要买一本书，以 Java 为关键字进行搜索，不管是书名中还是书的介绍中，甚至是书的作者名字，只要包含 java 就作为查询结果返回给用户查看，上述过程就使用了全文搜索技术。搜索的条件不再是仅用于对某一个字段进行比对，而是在一条数据中使用搜索条件去比对更多的字段，只要能匹配上就列入查询结果，这就是全文搜索的目的。而 ES 技术就是一种可以实现上述效果的技术。</p>
<p>​		要实现全文搜索的效果，不可能使用数据库中 like 操作去进行比对，这种效率太低了。ES 设计了一种全新的思想，来实现全文搜索。具体操作过程如下：</p>
<ol>
<li>
<p>将被查询的字段的数据全部文本信息进行查分，分成若干个词</p>
<ul>
<li>例如 “中华人民共和国” 就会被拆分成三个词，分别是 “中华”、“人民”、“共和国”，此过程有专业术语叫做分词。分词的策略不同，分出的效果不一样，不同的分词策略称为分词器。</li>
</ul>
</li>
<li>
<p>将分词得到的结果存储起来，对应每条数据的 id</p>
<ul>
<li>
<p>例如 id 为 1 的数据中名称这一项的值是 “中华人民共和国”，那么分词结束后，就会出现 “中华” 对应 id 为 1，“人民” 对应 id 为 1，“共和国” 对应 id 为 1</p>
</li>
<li>
<p>例如 id 为 2 的数据中名称这一项的值是 “人民代表大会 “，那么分词结束后，就会出现 “人民” 对应 id 为 2，“代表” 对应 id 为 2，“大会” 对应 id 为 2</p>
</li>
<li>
<p>此时就会出现如下对应结果，按照上述形式可以对所有文档进行分词。需要注意分词的过程不是仅对一个字段进行，而是对每一个参与查询的字段都执行，最终结果汇总到一个表格中</p>
<table>
<thead>
<tr>
<th>分词结果关键字</th>
<th>对应 id</th>
</tr>
</thead>
<tbody>
<tr>
<td>中华</td>
<td>1</td>
</tr>
<tr>
<td>人民</td>
<td>1,2</td>
</tr>
<tr>
<td>共和国</td>
<td>1</td>
</tr>
<tr>
<td>代表</td>
<td>2</td>
</tr>
<tr>
<td>大会</td>
<td>2</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>当进行查询时，如果输入 “人民” 作为查询条件，可以通过上述表格数据进行比对，得到 id 值 1,2，然后根据 id 值就可以得到查询的结果数据了。</p>
</li>
</ol>
<p>​		上述过程中分词结果关键字内容每一个都不相同，作用有点类似于数据库中的索引，是用来加速数据查询的。但是数据库中的索引是对某一个字段进行添加索引，而这里的分词结果关键字不是一个完整的字段值，只是一个字段中的其中的一部分内容。并且索引使用时是根据索引内容查找整条数据，全文搜索中的分词结果关键字查询后得到的并不是整条的数据，而是数据的 id，要想获得具体数据还要再次查询，因此这里为这种分词结果关键字起了一个全新的名称，叫做<strong>倒排索引</strong>。</p>
<p>​		通过上述内容的学习，发现使用 ES 其实准备工作还是挺多的，必须先建立文档的倒排索引，然后才能继续使用。快速了解一下 ES 的工作原理，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合。</p>
<h5 id="安装-3"><a class="markdownIt-Anchor" href="#安装-3">#</a> 安装</h5>
<p>​		windows 版安装包下载地址：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://</a><a href="https://www.elastic.co/cn/downloads/elasticsearch">www.elastic.co/cn/downloads/elasticsearch</a></p>
<p>​		下载的安装包是解压缩就能使用的 zip 文件，解压缩完毕后会得到如下文件</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220225132756400.png" alt="image-20220225132756400"></p>
<ul>
<li>bin 目录：包含所有的可执行命令</li>
<li>config 目录：包含 ES 服务器使用的配置文件</li>
<li>jdk 目录：此目录中包含了一个完整的 jdk 工具包，版本 17，当 ES 升级时，使用最新版本的 jdk 确保不会出现版本支持性不足的问题</li>
<li>lib 目录：包含 ES 运行的依赖 jar 文件</li>
<li>logs 目录：包含 ES 运行后产生的所有日志文件</li>
<li>modules 目录：包含 ES 软件中所有的功能模块，也是一个一个的 jar 包。和 jar 目录不同，jar 目录是 ES 运行期间依赖的 jar 包，modules 是 ES 软件自己的功能 jar 包</li>
<li>plugins 目录：包含 ES 软件安装的插件，默认为空</li>
</ul>
<p><strong>启动服务器</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">elasticsearch.bat</span><br></pre></td></tr></table></figure>
<p>​		双击 elasticsearch.bat 文件即可启动 ES 服务器，默认服务端口 9200。通过浏览器访问 http://localhost:9200 看到如下信息视为 ES 服务器正常启动</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;CZBK-**********&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;j137DSswTPG8U4Yb-<span class="number">0</span>T1Mg&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;<span class="number">7</span>.<span class="number">16</span>.<span class="number">2</span>&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;zip&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;<span class="number">2</span>b937c44140b6559905130a8650c64dbd0879cfb&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;<span class="number">2021</span>-<span class="number">12</span>-<span class="number">18</span>T19:<span class="number">42</span>:<span class="number">46</span>.<span class="number">604893745</span>Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;<span class="number">8</span>.<span class="number">10</span>.<span class="number">1</span>&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;<span class="number">6</span>.<span class="number">8</span>.<span class="number">0</span>&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;<span class="number">6</span>.<span class="number">0</span>.<span class="number">0</span>-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, <span class="keyword">for</span> Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="基本操作-3"><a class="markdownIt-Anchor" href="#基本操作-3">#</a> 基本操作</h5>
<p>​		ES 中保存有我们要查询的数据，只不过格式和数据库存储数据格式不同而已。在 ES 中我们要先创建倒排索引，这个索引的功能又点类似于数据库的表，然后将数据添加到倒排索引中，添加的数据称为文档。所以要进行 ES 的操作要先创建索引，再添加文档，这样才能进行后续的查询操作。</p>
<p>​		要操作 ES 可以通过 Rest 风格的请求来进行，也就是说发送一个请求就可以执行一个操作。比如新建索引，删除索引这些操作都可以使用发送请求的形式来进行。</p>
<ul>
<li>
<p>创建索引，books 是索引名称，下同</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">PUT请求		http://localhost:<span class="number">9200</span>/books</span><br></pre></td></tr></table></figure>
<p>发送请求后，看到如下信息即索引创建成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;acknowledged&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;shards_acknowledged&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;books&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重复创建已经存在的索引会出现错误信息，reason 属性中描述错误原因</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;resource_already_exists_exception&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;index [books/VgC_XMVAQmedaiBNSgO2-w] already exists&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;VgC_XMVAQmedaiBNSgO2-w&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;books&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;resource_already_exists_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;index [books/VgC_XMVAQmedaiBNSgO2-w] already exists&quot;</span>,	# books索引已经存在</span><br><span class="line">        <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;VgC_XMVAQmedaiBNSgO2-w&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;book&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询索引</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">GET请求		http://localhost:<span class="number">9200</span>/books</span><br></pre></td></tr></table></figure>
<p>查询索引得到索引相关信息，如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;book&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;aliases&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">&quot;mappings&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;index&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;routing&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;allocation&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;include&quot;</span>: &#123;</span><br><span class="line">                            <span class="attr">&quot;_tier_preference&quot;</span>: <span class="string">&quot;data_content&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;number_of_shards&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;provided_name&quot;</span>: <span class="string">&quot;books&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;creation_date&quot;</span>: <span class="string">&quot;1645768584849&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;number_of_replicas&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;uuid&quot;</span>: <span class="string">&quot;VgC_XMVAQmedaiBNSgO2-w&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;version&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;created&quot;</span>: <span class="string">&quot;7160299&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果查询了不存在的索引，会返回错误信息，例如查询名称为 book 的索引后信息如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;index_not_found_exception&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;no such index [book]&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;resource.type&quot;</span>: <span class="string">&quot;index_or_alias&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;resource.id&quot;</span>: <span class="string">&quot;book&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;_na_&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;book&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;index_not_found_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;no such index [book]&quot;</span>,		# 没有book索引</span><br><span class="line">        <span class="attr">&quot;resource.type&quot;</span>: <span class="string">&quot;index_or_alias&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;resource.id&quot;</span>: <span class="string">&quot;book&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;_na_&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;book&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">404</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除索引</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">DELETE请求	http://localhost:<span class="number">9200</span>/books</span><br></pre></td></tr></table></figure>
<p>删除所有后，给出删除结果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;acknowledged&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果重复删除，会给出错误信息，同样在 reason 属性中描述具体的错误原因</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;index_not_found_exception&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;no such index [books]&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;resource.type&quot;</span>: <span class="string">&quot;index_or_alias&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;resource.id&quot;</span>: <span class="string">&quot;book&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;_na_&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;book&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;index_not_found_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;no such index [books]&quot;</span>,		# 没有books索引</span><br><span class="line">        <span class="attr">&quot;resource.type&quot;</span>: <span class="string">&quot;index_or_alias&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;resource.id&quot;</span>: <span class="string">&quot;book&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;_na_&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;book&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">404</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建索引并指定分词器</p>
<p>​		前面创建的索引是未指定分词器的，可以在创建索引时添加请求参数，设置分词器。目前国内较为流行的分词器是 IK 分词器，使用前先在下对应的分词器，然后使用。IK 分词器下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p>
<p>​		分词器下载后解压到 ES 安装目录的 plugins 目录中即可，安装分词器后需要重新启动 ES 服务器。使用 IK 分词器创建索引格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT请求		http:<span class="comment">//localhost:9200/books</span></span><br><span class="line"></span><br><span class="line">请求参数如下（注意是json格式的参数）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>:&#123;							#定义mappings属性，替换创建索引时对应的mappings属性		</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>:&#123;						#定义索引中包含的属性设置</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>:&#123;							#设置索引中包含id属性</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span>			#当前属性可以被直接搜索</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>:&#123;						#设置索引中包含name属性</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,              #当前属性是文本信息，参与分词  </span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;ik_max_word&quot;</span>,   #使用IK分词器进行分词             </span><br><span class="line">                <span class="attr">&quot;copy_to&quot;</span>:<span class="string">&quot;all&quot;</span>				#分词结果拷贝到all属性中</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;description&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,	                </span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;ik_max_word&quot;</span>,                </span><br><span class="line">                <span class="attr">&quot;copy_to&quot;</span>:<span class="string">&quot;all&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;all&quot;</span>:&#123;							#定义属性，用来描述多个字段的分词结果集合，当前属性可以参与查询</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,	                </span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		创建完毕后返回结果和不使用分词器创建索引的结果是一样的，此时可以通过查看索引信息观察到添加的请求参数 mappings 已经进入到了索引属性中</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;books&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;aliases&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">&quot;mappings&quot;</span>: &#123;						#mappings属性已经被替换</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;all&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;description&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;copy_to&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;all&quot;</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;copy_to&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;all&quot;</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;index&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;routing&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;allocation&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;include&quot;</span>: &#123;</span><br><span class="line">                            <span class="attr">&quot;_tier_preference&quot;</span>: <span class="string">&quot;data_content&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;number_of_shards&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;provided_name&quot;</span>: <span class="string">&quot;books&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;creation_date&quot;</span>: <span class="string">&quot;1645769809521&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;number_of_replicas&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;uuid&quot;</span>: <span class="string">&quot;DohYKvr_SZO4KRGmbZYmTQ&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;version&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;created&quot;</span>: <span class="string">&quot;7160299&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>目前我们已经有了索引了，但是索引中还没有数据，所以要先添加数据，ES 中称数据为文档，下面进行文档操作。</p>
<ul>
<li>
<p>添加文档，有三种方式</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST请求	http:<span class="comment">//localhost:9200/books/_doc		#使用系统生成id</span></span><br><span class="line">POST请求	http:<span class="comment">//localhost:9200/books/_create/1	#使用指定id</span></span><br><span class="line">POST请求	http:<span class="comment">//localhost:9200/books/_doc/1		#使用指定id，不存在创建，存在更新（版本递增）</span></span><br><span class="line"></span><br><span class="line">文档通过请求参数传递，数据格式json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;springboot&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;springboot&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>:<span class="string">&quot;springboot&quot;</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询文档</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET请求	http:<span class="comment">//localhost:9200/books/_doc/1		 #查询单个文档 		</span></span><br><span class="line">GET请求	http:<span class="comment">//localhost:9200/books/_search		 #查询全部文档</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>条件查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET请求	http:<span class="comment">//localhost:9200/books/_search?q=name:springboot	# q=查询属性名:查询属性值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除文档</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE请求	http:<span class="comment">//localhost:9200/books/_doc/1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改文档（全量更新）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT请求	http:<span class="comment">//localhost:9200/books/_doc/1</span></span><br><span class="line"></span><br><span class="line">文档通过请求参数传递，数据格式json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;springboot&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;springboot&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>:<span class="string">&quot;springboot&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改文档（部分更新）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST请求	http:<span class="comment">//localhost:9200/books/_update/1</span></span><br><span class="line"></span><br><span class="line">文档通过请求参数传递，数据格式json</span><br><span class="line">&#123;			</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>:&#123;						#部分更新并不是对原始文档进行更新，而是对原始文档对象中的doc属性中的指定属性更新</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;springboot&quot;</span>		#仅更新提供的属性值，未提供的属性值不参与更新操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="整合-3"><a class="markdownIt-Anchor" href="#整合-3">#</a> 整合</h5>
<p>​		使用 springboot 整合 ES 该如何进行呢？老规矩，导入坐标，做配置，使用 API 接口操作。整合 Redis 如此，整合 MongoDB 如此，整合 ES 依然如此。太没有新意了，其实不是没有新意，这就是 springboot 的强大之处，所有东西都做成相同规则，对开发者来说非常友好。</p>
<p>​		下面就开始 springboot 整合 ES，操作步骤如下：</p>
<p><strong>步骤①</strong>：导入 springboot 整合 ES 的 starter 坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：进行基础配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">rest:</span></span><br><span class="line">      <span class="attr">uris:</span> <span class="string">http://localhost:9200</span></span><br></pre></td></tr></table></figure>
<p>​		配置 ES 服务器地址，端口 9200</p>
<p><strong>步骤③</strong>：使用 springboot 整合 ES 的专用客户端接口 ElasticsearchRestTemplate 来进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot18EsApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchRestTemplate template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		上述操作形式是 ES 早期的操作方式，使用的客户端被称为 Low Level Client，这种客户端操作方式性能方面略显不足，于是 ES 开发了全新的客户端操作方式，称为 High Level Client。高级别客户端与 ES 版本同步更新，但是 springboot 最初整合 ES 的时候使用的是低级别客户端，所以企业开发需要更换成高级别的客户端模式。</p>
<p>​		下面使用高级别客户端方式进行 springboot 整合 ES，操作步骤如下：</p>
<p><strong>步骤①</strong>：导入 springboot 整合 ES 高级别客户端的坐标，此种形式目前没有对应的 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：使用编程的形式设置连接的 ES 服务器，并获取客户端对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot18EsApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line">      <span class="meta">@Test</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">testCreateClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          HttpHost host = HttpHost.create(<span class="string">&quot;http://localhost:9200&quot;</span>);</span><br><span class="line">          RestClientBuilder builder = RestClient.builder(host);</span><br><span class="line">          client = <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">  </span><br><span class="line">          client.close();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		配置 ES 服务器地址与端口 9200，记得客户端使用完毕需要手工关闭。由于当前客户端是手工维护的，因此不能通过自动装配的形式加载对象。</p>
<p><strong>步骤③</strong>：使用客户端对象操作 ES，例如创建索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot18EsApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line">      <span class="meta">@Test</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          HttpHost host = HttpHost.create(<span class="string">&quot;http://localhost:9200&quot;</span>);</span><br><span class="line">          RestClientBuilder builder = RestClient.builder(host);</span><br><span class="line">          client = <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">          </span><br><span class="line">          CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;books&quot;</span>);</span><br><span class="line">          client.indices().create(request, RequestOptions.DEFAULT); </span><br><span class="line">          </span><br><span class="line">          client.close();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		高级别客户端操作是通过发送请求的方式完成所有操作的，ES 针对各种不同的操作，设定了各式各样的请求对象，上例中创建索引的对象是 CreateIndexRequest，其他操作也会有自己专用的 Request 对象。</p>
<p>​		当前操作我们发现，无论进行 ES 何种操作，第一步永远是获取 RestHighLevelClient 对象，最后一步永远是关闭该对象的连接。在测试中可以使用测试类的特性去帮助开发者一次性的完成上述操作，但是在业务书写时，还需要自行管理。将上述代码格式转换成使用测试类的初始化方法和销毁方法进行客户端对象的维护。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot18EsApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BeforeEach</span>		<span class="comment">//在测试类中每个操作运行前运行的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpHost host = HttpHost.create(<span class="string">&quot;http://localhost:9200&quot;</span>);</span><br><span class="line">        RestClientBuilder builder = RestClient.builder(host);</span><br><span class="line">        client = <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span>		<span class="comment">//在测试类中每个操作运行后运行的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;books&quot;</span>);</span><br><span class="line">        client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		现在的书写简化了很多，也更合理。下面使用上述模式将所有的 ES 操作执行一遍，测试结果</p>
<p><strong>创建索引（IK 分词器）</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCreateIndexByIK</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;books&quot;</span>);</span><br><span class="line">    String json = <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    \&quot;mappings\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;properties\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            \&quot;id\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;                \&quot;type\&quot;:\&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            \&quot;name\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;                \&quot;type\&quot;:\&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;                \&quot;analyzer\&quot;:\&quot;ik_max_word\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;                \&quot;copy_to\&quot;:\&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            \&quot;type\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;                \&quot;type\&quot;:\&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            \&quot;description\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;                \&quot;type\&quot;:\&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;                \&quot;analyzer\&quot;:\&quot;ik_max_word\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;                \&quot;copy_to\&quot;:\&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            \&quot;all\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;                \&quot;type\&quot;:\&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;                \&quot;analyzer\&quot;:\&quot;ik_max_word\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="comment">//设置请求中的参数</span></span><br><span class="line">    request.source(json, XContentType.JSON);</span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		IK 分词器是通过请求参数的形式进行设置的，设置请求参数使用 request 对象中的 source 方法进行设置，至于参数是什么，取决于你的操作种类。当请求中需要参数时，均可使用当前形式进行参数设置。</p>
<p><strong>添加文档</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//添加文档</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCreateDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Book book = bookDao.selectById(<span class="number">1</span>);</span><br><span class="line">    IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;books&quot;</span>).id(book.getId().toString());</span><br><span class="line">    String json = JSON.toJSONString(book);</span><br><span class="line">    request.source(json,XContentType.JSON);</span><br><span class="line">    client.index(request,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		添加文档使用的请求对象是 IndexRequest，与创建索引使用的请求对象不同。</p>
<p><strong>批量添加文档</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//批量添加文档</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCreateDocAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    List&lt;Book&gt; bookList = bookDao.selectList(<span class="keyword">null</span>);</span><br><span class="line">    BulkRequest bulk = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    <span class="keyword">for</span> (Book book : bookList) &#123;</span><br><span class="line">        IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;books&quot;</span>).id(book.getId().toString());</span><br><span class="line">        String json = JSON.toJSONString(book);</span><br><span class="line">        request.source(json,XContentType.JSON);</span><br><span class="line">        bulk.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">    client.bulk(bulk,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		批量做时，先创建一个 BulkRequest 的对象，可以将该对象理解为是一个保存 request 对象的容器，将所有的请求都初始化好后，添加到 BulkRequest 对象中，再使用 BulkRequest 对象的 bulk 方法，一次性执行完毕。</p>
<p><strong>按 id 查询文档</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//按id查询</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    GetRequest request = <span class="keyword">new</span> GetRequest(<span class="string">&quot;books&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    GetResponse response = client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    String json = response.getSourceAsString();</span><br><span class="line">    System.out.println(json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		根据 id 查询文档使用的请求对象是 GetRequest。</p>
<p><strong>按条件查询文档</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//按条件查询</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;books&quot;</span>);</span><br><span class="line"></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.query(QueryBuilders.termQuery(<span class="string">&quot;all&quot;</span>,<span class="string">&quot;spring&quot;</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    SearchHits hits = response.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        String source = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">//System.out.println(source);</span></span><br><span class="line">        Book book = JSON.parseObject(source, Book.class);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		按条件查询文档使用的请求对象是 SearchRequest，查询时调用 SearchRequest 对象的 termQuery 方法，需要给出查询属性名，此处支持使用合并字段，也就是前面定义索引属性时添加的 all 属性。</p>
<p>​		springboot 整合 ES 的操作到这里就说完了，与前期进行 springboot 整合 redis 和 mongodb 的差别还是蛮大的，主要原始就是我们没有使用 springboot 整合 ES 的客户端对象。至于操作，由于 ES 操作种类过多，所以显得操作略微有点复杂。有关 springboot 整合 ES 就先学习到这里吧。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 整合 ES 步骤
<ol>
<li>导入 springboot 整合 ES 的 High Level Client 坐标</li>
<li>手工管理客户端对象，包括初始化和关闭操作</li>
<li>使用 High Level Client 根据操作的种类不同，选择不同的 Request 对象完成对应操作</li>
</ol>
</li>
</ol>
<h2 id="kf-5整合第三方技术"><a class="markdownIt-Anchor" href="#kf-5整合第三方技术">#</a> KF-5. 整合第三方技术</h2>
<p>​		通过第四章的学习，我们领略到了 springboot 在整合第三方技术时强大的一致性，在第五章中我们要使用 springboot 继续整合各种各样的第三方技术，通过本章的学习，可以将之前学习的 springboot 整合第三方技术的思想贯彻到底，还是那三板斧。导坐标、做配置、调 API。</p>
<p>​		springboot 能够整合的技术实在是太多了，可以说是万物皆可整。本章将从企业级开发中常用的一些技术作为出发点，对各种各样的技术进行整合。</p>
<h3 id="kf-5-1缓存"><a class="markdownIt-Anchor" href="#kf-5-1缓存">#</a> KF-5-1. 缓存</h3>
<p>​		企业级应用主要作用是信息处理，当需要读取数据时，由于受限于数据库的访问效率，导致整体系统性能偏低。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220226154148303.png" alt="image-20220226154148303" style="zoom:67%;">
<p>​															          应用程序直接与数据库打交道，访问效率低</p>
<p>​		为了改善上述现象，开发者通常会在应用程序与数据库之间建立一种临时的数据存储机制，该区域中的数据在内存中保存，读写速度较快，可以有效解决数据库访问效率低下的问题。这一块临时存储数据的区域就是缓存。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220226154233010.png" alt="image-20220226154233010" style="zoom:67%;">
<pre><code>										使用缓存后，应用程序与缓存打交道，缓存与数据库打交道，数据访问效率提高
</code></pre>
<p>​		缓存是什么？缓存是一种介于数据永久存储介质与应用程序之间的数据临时存储介质，使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘 IO），提高系统性能。此外缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间。而 springboot 提供了对市面上几乎所有的缓存技术进行整合的方案，下面就一起开启 springboot 整合缓存之旅。</p>
<h4 id="springboot内置缓存解决方案"><a class="markdownIt-Anchor" href="#springboot内置缓存解决方案">#</a> SpringBoot 内置缓存解决方案</h4>
<p>​		springboot 技术提供有内置的缓存解决方案，可以帮助开发者快速开启缓存技术，并使用缓存技术进行数据的快速操作，例如读取缓存数据和写入数据到缓存。</p>
<p><strong>步骤①</strong>：导入 springboot 提供的缓存技术对应的 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：启用缓存，在引导类上方标注注解 @EnableCaching 配置 springboot 程序中可以使用缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//开启缓存功能</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot19CacheApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springboot19CacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：设置操作的数据是否使用缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value=&quot;cacheSpace&quot;,key=&quot;#id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在业务方法上面使用注解 @Cacheable 声明当前方法的返回值放入缓存中，其中要指定缓存的存储位置，以及缓存中保存当前方法返回值对应的名称。上例中 value 属性描述缓存的存储位置，可以理解为是一个存储空间名，key 属性描述了缓存中保存数据的名称，使用 #id 读取形参中的 id 值作为缓存名称。</p>
<p>​		使用 @Cacheable 注解后，执行当前操作，如果发现对应名称在缓存中没有数据，就正常读取数据，然后放入缓存；如果对应名称在缓存中有数据，就终止当前业务方法执行，直接返回缓存中的数据。</p>
<h4 id="手机验证码案例"><a class="markdownIt-Anchor" href="#手机验证码案例">#</a> 手机验证码案例</h4>
<p>​		为了便于下面演示各种各样的缓存技术，我们创建一个手机验证码的案例环境，模拟使用缓存保存手机验证码的过程。</p>
<p>​		手机验证码案例需求如下：</p>
<ul>
<li>输入手机号获取验证码，组织文档以短信形式发送给用户（页面模拟）</li>
<li>输入手机号和验证码验证结果</li>
</ul>
<p>​		为了描述上述操作，我们制作两个表现层接口，一个用来模拟发送短信的过程，其实就是根据用户提供的手机号生成一个验证码，然后放入缓存，另一个用来模拟验证码校验的过程，其实就是使用传入的手机号和验证码进行匹配，并返回最终匹配结果。下面直接制作本案例的模拟代码，先以上例中 springboot 提供的内置缓存技术来完成当前案例的制作。</p>
<p><strong>步骤①</strong>：导入 springboot 提供的缓存技术对应的 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：启用缓存，在引导类上方标注注解 @EnableCaching 配置 springboot 程序中可以使用缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//开启缓存功能</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot19CacheApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springboot19CacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：定义验证码对应的实体类，封装手机号与验证码两个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String tele;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤④</strong>：定义验证码功能的业务层接口与实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SMSCodeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendCodeToSMS</span><span class="params">(String tele)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkCode</span><span class="params">(SMSCode smsCode)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSCodeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SMSCodeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CodeUtils codeUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(value = &quot;smsCode&quot;, key = &quot;#tele&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendCodeToSMS</span><span class="params">(String tele)</span> </span>&#123;</span><br><span class="line">        String code = codeUtils.generator(tele);</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkCode</span><span class="params">(SMSCode smsCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//取出内存中的验证码与传递过来的验证码比对，如果相同，返回true</span></span><br><span class="line">        String code = smsCode.getCode();</span><br><span class="line">        String cacheCode = codeUtils.get(smsCode.getTele());</span><br><span class="line">        <span class="keyword">return</span> code.equals(cacheCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		获取验证码后，当验证码失效时必须重新获取验证码，因此在获取验证码的功能上不能使用 @Cacheable 注解，@Cacheable 注解是缓存中没有值则放入值，缓存中有值则取值。此处的功能仅仅是生成验证码并放入缓存，并不具有从缓存中取值的功能，因此不能使用 @Cacheable 注解，应该使用仅具有向缓存中保存数据的功能，使用 @CachePut 注解即可。</p>
<p>​		对于校验验证码的功能建议放入工具类中进行。</p>
<p><strong>步骤⑤</strong>：定义验证码的生成策略与根据手机号读取验证码的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String [] patch = &#123;<span class="string">&quot;000000&quot;</span>,<span class="string">&quot;00000&quot;</span>,<span class="string">&quot;0000&quot;</span>,<span class="string">&quot;000&quot;</span>,<span class="string">&quot;00&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generator</span><span class="params">(String tele)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = tele.hashCode();</span><br><span class="line">        <span class="keyword">int</span> encryption = <span class="number">20206666</span>;</span><br><span class="line">        <span class="keyword">long</span> result = hash ^ encryption;</span><br><span class="line">        <span class="keyword">long</span> nowTime = System.currentTimeMillis();</span><br><span class="line">        result = result ^ nowTime;</span><br><span class="line">        <span class="keyword">long</span> code = result % <span class="number">1000000</span>;</span><br><span class="line">        code = code &lt; <span class="number">0</span> ? -code : code;</span><br><span class="line">        String codeStr = code + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> len = codeStr.length();</span><br><span class="line">        <span class="keyword">return</span> patch[len] + codeStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;smsCode&quot;,key=&quot;#tele&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String tele)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤⑥</strong>：定义验证码功能的 web 层接口，一个方法用于提供手机号获取验证码，一个方法用于提供手机号和验证码进行校验</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sms&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSCodeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SMSCodeService smsCodeService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">(String tele)</span></span>&#123;</span><br><span class="line">        String code = smsCodeService.sendCodeToSMS(tele);</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkCode</span><span class="params">(SMSCode smsCode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> smsCodeService.checkCode(smsCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="springboot整合ehcache缓存"><a class="markdownIt-Anchor" href="#springboot整合ehcache缓存">#</a> SpringBoot 整合 Ehcache 缓存</h4>
<p>​		手机验证码的案例已经完成了，下面就开始 springboot 整合各种各样的缓存技术，第一个整合 Ehcache 技术。Ehcache 是一种缓存技术，使用 springboot 整合 Ehcache 其实就是变更一下缓存技术的实现方式，话不多说，直接开整</p>
<p><strong>步骤①</strong>：导入 Ehcache 的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		此处为什么不是导入 Ehcache 的 starter，而是导入技术坐标呢？其实 springboot 整合缓存技术做的是通用格式，不管你整合哪种缓存技术，只是实现变化了，操作方式一样。这也体现出 springboot 技术的优点，统一同类技术的整合方式。</p>
<p><strong>步骤②</strong>：配置缓存技术实现使用 Ehcache</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ehcache</span></span><br><span class="line">    <span class="attr">ehcache:</span></span><br><span class="line">      <span class="attr">config:</span> <span class="string">ehcache.xml</span></span><br></pre></td></tr></table></figure>
<p>​		配置缓存的类型 type 为 ehcache，此处需要说明一下，当前 springboot 可以整合的缓存技术中包含有 ehcach，所以可以这样书写。其实这个 type 不可以随便写的，不是随便写一个名称就可以整合的。</p>
<p>​		由于 ehcache 的配置有独立的配置文件格式，因此还需要指定 ehcache 的配置文件，以便于读取相应配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">updateCheck</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\ehcache&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--默认缓存策略 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- external：是否永久存在，设置为true则不会被清除，此时与timeout冲突，通常设置为false--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- diskPersistent：是否启用磁盘持久化--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- maxElementsInMemory：最大缓存数量--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- overflowToDisk：超过最大缓存数量是否持久化到磁盘--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- timeToIdleSeconds：最大不活动间隔，设置过长缓存容易溢出，设置过短无效果，可用于记录时效性数据，例如验证码--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- timeToLiveSeconds：最大存活时间--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- memoryStoreEvictionPolicy：缓存清除策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;60&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;60&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;smsCode&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		注意前面的案例中，设置了数据保存的位置是 smsCode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CachePut(value = &quot;smsCode&quot;, key = &quot;#tele&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sendCodeToSMS</span><span class="params">(String tele)</span> </span>&#123;</span><br><span class="line">    String code = codeUtils.generator(tele);</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>​		这个设定需要保障 ehcache 中有一个缓存空间名称叫做 smsCode 的配置，前后要统一。在企业开发过程中，通过设置不同名称的 cache 来设定不同的缓存策略，应用于不同的缓存数据。</p>
<p>​		到这里 springboot 整合 Ehcache 就做完了，可以发现一点，原始代码没有任何修改，仅仅是加了一组配置就可以变更缓存供应商了，这也是 springboot 提供了统一的缓存操作接口的优势，变更实现并不影响原始代码的书写。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 使用 Ehcache 作为缓存实现需要导入 Ehcache 的坐标</li>
<li>修改设置，配置缓存供应商为 ehcache，并提供对应的缓存配置文件</li>
</ol>
<p>​</p>
<h4 id="springboot整合redis缓存"><a class="markdownIt-Anchor" href="#springboot整合redis缓存">#</a> SpringBoot 整合 Redis 缓存</h4>
<p>​		上节使用 Ehcache 替换了 springboot 内置的缓存技术，其实 springboot 支持的缓存技术还很多，下面使用 redis 技术作为缓存解决方案来实现手机验证码案例。</p>
<p>​		比对使用 Ehcache 的过程，加坐标，改缓存实现类型为 ehcache，做 Ehcache 的配置。如果还成 redis 做缓存呢？一模一样，加坐标，改缓存实现类型为 redis，做 redis 的配置。差别之处只有一点，redis 的配置可以在 yml 文件中直接进行配置，无需制作独立的配置文件。</p>
<p><strong>步骤①</strong>：导入 redis 的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：配置缓存技术实现使用 redis</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>
<p>​		如果需要对 redis 作为缓存进行配置，注意不是对原始的 redis 进行配置，而是配置 redis 作为缓存使用相关的配置，隶属于 spring.cache.redis 节点下，注意不要写错位置了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">use-key-prefix:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">key-prefix:</span> <span class="string">sms_</span></span><br><span class="line">      <span class="attr">cache-null-values:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>springboot 使用 redis 作为缓存实现需要导入 redis 的坐标</li>
<li>修改设置，配置缓存供应商为 redis，并提供对应的缓存配置</li>
</ol>
<h4 id="springboot整合memcached缓存"><a class="markdownIt-Anchor" href="#springboot整合memcached缓存">#</a> SpringBoot 整合 Memcached 缓存</h4>
<p>​		目前我们已经掌握了 3 种缓存解决方案的配置形式，分别是 springboot 内置缓存，ehcache 和 redis，本节研究一下国内比较流行的一款缓存 memcached。</p>
<p>​		按照之前的套路，其实变更缓存并不繁琐，但是 springboot 并没有支持使用 memcached 作为其缓存解决方案，也就是说在 type 属性中没有 memcached 的配置选项，这里就需要更变一下处理方式了。在整合之前先安装 memcached。</p>
<p><strong>安装</strong></p>
<p>​		windows 版安装包下载地址：<a href="https://www.runoob.com/memcached/window-install-memcached.html">https://www.runoob.com/memcached/window-install-memcached.html</a></p>
<p>​		下载的安装包是解压缩就能使用的 zip 文件，解压缩完毕后会得到如下文件</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220226174957040.png" alt="image-20220226174957040"></p>
<p>​		可执行文件只有一个 memcached.exe，使用该文件可以将 memcached 作为系统服务启动，执行此文件时会出现报错信息，如下：</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220226175141986.png" alt="image-20220226175141986" style="zoom:80%;">
<p>​		此处出现问题的原因是注册系统服务时需要使用管理员权限，当前账号权限不足导致安装服务失败，切换管理员账号权限启动命令行</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220226175302903.png" alt="image-20220226175302903" style="zoom:80%;">
<p>​		然后再次执行安装服务的命令即可，如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">memcached.exe -d install</span><br></pre></td></tr></table></figure>
<p>​		服务安装完毕后可以使用命令启动和停止服务，如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">memcached.exe -d <span class="built_in">start</span>		# 启动服务</span><br><span class="line">memcached.exe -d stop		# 停止服务</span><br></pre></td></tr></table></figure>
<p>​		也可以在任务管理器中进行服务状态的切换</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220226175441675.png" alt="image-20220226175441675" style="zoom:67%;">
<p><strong>变更缓存为 Memcached</strong></p>
<p>​		由于 memcached 未被 springboot 收录为缓存解决方案，因此使用 memcached 需要通过手工硬编码的方式来使用，于是前面的套路都不适用了，需要自己写了。</p>
<p>​		memcached 目前提供有三种客户端技术，分别是 Memcached Client for Java、SpyMemcached 和 Xmemcached，其中性能指标各方面最好的客户端是 Xmemcached，本次整合就使用这个作为客户端实现技术了。下面开始使用 Xmemcached</p>
<p><strong>步骤①</strong>：导入 xmemcached 的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.googlecode.xmemcached<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xmemcached<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：配置 memcached，制作 memcached 的配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMemcachedConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MemcachedClient <span class="title">getMemcachedClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        MemcachedClientBuilder memcachedClientBuilder = <span class="keyword">new</span> XMemcachedClientBuilder(<span class="string">&quot;localhost:11211&quot;</span>);</span><br><span class="line">        MemcachedClient memcachedClient = memcachedClientBuilder.build();</span><br><span class="line">        <span class="keyword">return</span> memcachedClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		memcached 默认对外服务端口 11211。</p>
<p><strong>步骤③</strong>：使用 xmemcached 客户端操作缓存，注入 MemcachedClient 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSCodeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SMSCodeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CodeUtils codeUtils;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MemcachedClient memcachedClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendCodeToSMS</span><span class="params">(String tele)</span> </span>&#123;</span><br><span class="line">        String code = codeUtils.generator(tele);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            memcachedClient.set(tele,<span class="number">10</span>,code);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkCode</span><span class="params">(SMSCode smsCode)</span> </span>&#123;</span><br><span class="line">        String code = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            code = memcachedClient.get(smsCode.getTele()).toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> smsCode.getCode().equals(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		设置值到缓存中使用 set 操作，取值使用 get 操作，其实更符合我们开发者的习惯。</p>
<p>​		上述代码中对于服务器的配置使用硬编码写死到了代码中，将此数据提取出来，做成独立的配置属性。</p>
<p><strong>定义配置属性</strong></p>
<p>​		以下过程采用前期学习的属性配置方式进行，当前操作有助于理解原理篇中的很多知识。</p>
<ul>
<li>
<p>定义配置类，加载必要的配置属性，读取配置文件中 memcached 节点信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;memcached&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMemcachedProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String servers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> poolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> opTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义 memcached 节点信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">memcached:</span></span><br><span class="line">  <span class="attr">servers:</span> <span class="string">localhost:11211</span></span><br><span class="line">  <span class="attr">poolSize:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">opTimeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 memcached 配置类中加载信息</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMemcachedConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> XMemcachedProperties props;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MemcachedClient <span class="title">getMemcachedClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        MemcachedClientBuilder memcachedClientBuilder = <span class="keyword">new</span> XMemcachedClientBuilder(props.getServers());</span><br><span class="line">        memcachedClientBuilder.setConnectionPoolSize(props.getPoolSize());</span><br><span class="line">        memcachedClientBuilder.setOpTimeout(props.getOpTimeout());</span><br><span class="line">        MemcachedClient memcachedClient = memcachedClientBuilder.build();</span><br><span class="line">        <span class="keyword">return</span> memcachedClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>memcached 安装后需要启动对应服务才可以对外提供缓存功能，安装 memcached 服务需要基于 windows 系统管理员权限</li>
<li>由于 springboot 没有提供对 memcached 的缓存整合方案，需要采用手工编码的形式创建 xmemcached 客户端操作缓存</li>
<li>导入 xmemcached 坐标后，创建 memcached 配置类，注册 MemcachedClient 对应的 bean，用于操作缓存</li>
<li>初始化 MemcachedClient 对象所需要使用的属性可以通过自定义配置属性类的形式加载</li>
</ol>
<p><strong>思考</strong></p>
<p>​		到这里已经完成了三种缓存的整合，其中 redis 和 mongodb 需要安装独立的服务器，连接时需要输入对应的服务器地址，这种是远程缓存，Ehcache 是一个典型的内存级缓存，因为它什么也不用安装，启动后导入 jar 包就有缓存功能了。这个时候就要问了，能不能这两种缓存一起用呢？咱们下节再说。</p>
<h4 id="springboot整合jetcache缓存"><a class="markdownIt-Anchor" href="#springboot整合jetcache缓存">#</a> SpringBoot 整合 jetcache 缓存</h4>
<p>​		目前我们使用的缓存都是要么 A 要么 B，能不能 AB 一起用呢？这一节就解决这个问题。springboot 针对缓存的整合仅仅停留在用缓存上面，如果缓存自身不支持同时支持 AB 一起用，springboot 也没办法，所以要想解决 AB 缓存一起用的问题，就必须找一款缓存能够支持 AB 两种缓存一起用，有这种缓存吗？还真有，阿里出品，jetcache。</p>
<p>​		jetcache 严格意义上来说，并不是一个缓存解决方案，只能说他算是一个缓存框架，然后把别的缓存放到 jetcache 中管理，这样就可以支持 AB 缓存一起用了。并且 jetcache 参考了 springboot 整合缓存的思想，整体技术使用方式和 springboot 的缓存解决方案思想非常类似。下面咱们就先把 jetcache 用起来，然后再说它里面的一些小的功能。</p>
<p>​		做之前要先明确一下，jetcache 并不是随便拿两个缓存都能拼到一起去的。目前 jetcache 支持的缓存方案本地缓存支持两种，远程缓存支持两种，分别如下：</p>
<ul>
<li>本地缓存（Local）
<ul>
<li>LinkedHashMap</li>
<li>Caffeine</li>
</ul>
</li>
<li>远程缓存（Remote）
<ul>
<li>Redis</li>
<li>Tair</li>
</ul>
</li>
</ul>
<p>​		其实也有人问我，为什么 jetcache 只支持 2+2 这么 4 款缓存呢？阿里研发这个技术其实主要是为了满足自身的使用需要。最初肯定只有 1+1 种，逐步变化成 2+2 种。下面就以 LinkedHashMap+Redis 的方案实现本地与远程缓存方案同时使用。</p>
<h5 id="纯远程方案"><a class="markdownIt-Anchor" href="#纯远程方案">#</a> 纯远程方案</h5>
<p><strong>步骤①</strong>：导入 springboot 整合 jetcache 对应的坐标 starter，当前坐标默认使用的远程方案是 redis</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alicp.jetcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetcache-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：远程方案基本配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">remote:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">poolConfig:</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>​		其中 poolConfig 是必配项，否则会报错</p>
<p><strong>步骤③</strong>：启用缓存，在引导类上方标注注解 @EnableCreateCacheAnnotation 配置 springboot 程序中可以使用注解的形式创建缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//jetcache启用缓存的主开关</span></span><br><span class="line"><span class="meta">@EnableCreateCacheAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot20JetCacheApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springboot20JetCacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤④</strong>：创建缓存对象 Cache，并使用注解 @CreateCache 标记当前缓存的信息，然后使用 Cache 对象的 API 操作缓存，put 写缓存，get 读缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSCodeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SMSCodeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CodeUtils codeUtils;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CreateCache(name=&quot;jetCache_&quot;,expire = 10,timeUnit = TimeUnit.SECONDS)</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String ,String&gt; jetCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendCodeToSMS</span><span class="params">(String tele)</span> </span>&#123;</span><br><span class="line">        String code = codeUtils.generator(tele);</span><br><span class="line">        jetCache.put(tele,code);</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkCode</span><span class="params">(SMSCode smsCode)</span> </span>&#123;</span><br><span class="line">        String code = jetCache.get(smsCode.getTele());</span><br><span class="line">        <span class="keyword">return</span> smsCode.getCode().equals(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		通过上述 jetcache 使用远程方案连接 redis 可以看出，jetcache 操作缓存时的接口操作更符合开发者习惯，使用缓存就先获取缓存对象 Cache，放数据进去就是 put，取数据出来就是 get，更加简单易懂。并且 jetcache 操作缓存时，可以为某个缓存对象设置过期时间，将同类型的数据放入缓存中，方便有效周期的管理。</p>
<p>​		上述方案中使用的是配置中定义的 default 缓存，其实这个 default 是个名字，可以随便写，也可以随便加。例如再添加一种缓存解决方案，参照如下配置进行：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">remote:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">poolConfig:</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">sms:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">poolConfig:</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>​		如果想使用名称是 sms 的缓存，需要再创建缓存时指定参数 area，声明使用对应缓存即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSCodeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SMSCodeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CodeUtils codeUtils;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CreateCache(area=&quot;sms&quot;,name=&quot;jetCache_&quot;,expire = 10,timeUnit = TimeUnit.SECONDS)</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String ,String&gt; jetCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendCodeToSMS</span><span class="params">(String tele)</span> </span>&#123;</span><br><span class="line">        String code = codeUtils.generator(tele);</span><br><span class="line">        jetCache.put(tele,code);</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkCode</span><span class="params">(SMSCode smsCode)</span> </span>&#123;</span><br><span class="line">        String code = jetCache.get(smsCode.getTele());</span><br><span class="line">        <span class="keyword">return</span> smsCode.getCode().equals(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="纯本地方案"><a class="markdownIt-Anchor" href="#纯本地方案">#</a> 纯本地方案</h5>
<p>​		远程方案中，配置中使用 remote 表示远程，换成 local 就是本地，只不过类型不一样而已。</p>
<p><strong>步骤①</strong>：导入 springboot 整合 jetcache 对应的坐标 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alicp.jetcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetcache-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：本地缓存基本配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">linkedhashmap</span></span><br><span class="line">      <span class="attr">keyConvertor:</span> <span class="string">fastjson</span></span><br></pre></td></tr></table></figure>
<p>​		为了加速数据获取时 key 的匹配速度，jetcache 要求指定 key 的类型转换器。简单说就是，如果你给了一个 Object 作为 key 的话，我先用 key 的类型转换器给转换成字符串，然后再保存。等到获取数据时，仍然是先使用给定的 Object 转换成字符串，然后根据字符串匹配。由于 jetcache 是阿里的技术，这里推荐 key 的类型转换器使用阿里的 fastjson。</p>
<p><strong>步骤③</strong>：启用缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//jetcache启用缓存的主开关</span></span><br><span class="line"><span class="meta">@EnableCreateCacheAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot20JetCacheApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springboot20JetCacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤④</strong>：创建缓存对象 Cache 时，标注当前使用本地缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSCodeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SMSCodeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@CreateCache(name=&quot;jetCache_&quot;,expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.LOCAL)</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String ,String&gt; jetCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendCodeToSMS</span><span class="params">(String tele)</span> </span>&#123;</span><br><span class="line">        String code = codeUtils.generator(tele);</span><br><span class="line">        jetCache.put(tele,code);</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkCode</span><span class="params">(SMSCode smsCode)</span> </span>&#123;</span><br><span class="line">        String code = jetCache.get(smsCode.getTele());</span><br><span class="line">        <span class="keyword">return</span> smsCode.getCode().equals(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		cacheType 控制当前缓存使用本地缓存还是远程缓存，配置 cacheType=CacheType.LOCAL 即使用本地缓存。</p>
<h5 id="本地远程方案"><a class="markdownIt-Anchor" href="#本地远程方案">#</a> 本地 + 远程方案</h5>
<p>​		本地和远程方法都有了，两种方案一起使用如何配置呢？其实就是将两种配置合并到一起就可以了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">linkedhashmap</span></span><br><span class="line">      <span class="attr">keyConvertor:</span> <span class="string">fastjson</span></span><br><span class="line">  <span class="attr">remote:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">poolConfig:</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">sms:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">poolConfig:</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>​		在创建缓存的时候，配置 cacheType 为 BOTH 即则本地缓存与远程缓存同时使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSCodeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SMSCodeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@CreateCache(name=&quot;jetCache_&quot;,expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.BOTH)</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String ,String&gt; jetCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		cacheType 如果不进行配置，默认值是 REMOTE，即仅使用远程缓存方案。关于 jetcache 的配置，参考以下信息</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>jetcache.statIntervalMinutes</td>
<td>0</td>
<td>统计间隔，0 表示不统计</td>
</tr>
<tr>
<td>jetcache.hiddenPackages</td>
<td>无</td>
<td>自动生成 name 时，隐藏指定的包名前缀</td>
</tr>
<tr>
<td>jetcache.[local|remote].${area}.type</td>
<td>无</td>
<td>缓存类型，本地支持 linkedhashmap、caffeine，远程支持 redis、tair</td>
</tr>
<tr>
<td>jetcache.[local|remote].${area}.keyConvertor</td>
<td>无</td>
<td>key 转换器，当前仅支持 fastjson</td>
</tr>
<tr>
<td>jetcache.[local|remote].${area}.valueEncoder</td>
<td>java</td>
<td>仅 remote 类型的缓存需要指定，可选 java 和 kryo</td>
</tr>
<tr>
<td>jetcache.[local|remote].${area}.valueDecoder</td>
<td>java</td>
<td>仅 remote 类型的缓存需要指定，可选 java 和 kryo</td>
</tr>
<tr>
<td>jetcache.[local|remote].${area}.limit</td>
<td>100</td>
<td>仅 local 类型的缓存需要指定，缓存实例最大元素数</td>
</tr>
<tr>
<td>jetcache.[local|remote].${area}.expireAfterWriteInMillis</td>
<td>无穷大</td>
<td>默认过期时间，毫秒单位</td>
</tr>
<tr>
<td>jetcache.local.${area}.expireAfterAccessInMillis</td>
<td>0</td>
<td>仅 local 类型的缓存有效，毫秒单位，最大不活动间隔</td>
</tr>
</tbody>
</table>
<p>​		以上方案仅支持手工控制缓存，但是 springcache 方案中的方法缓存特别好用，给一个方法添加一个注解，方法就会自动使用缓存。jetcache 也提供了对应的功能，即方法缓存。</p>
<p><strong>方法缓存</strong></p>
<p>​		jetcache 提供了方法缓存方案，只不过名称变更了而已。在对应的操作接口上方使用注解 @Cached 即可</p>
<p><strong>步骤①</strong>：导入 springboot 整合 jetcache 对应的坐标 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alicp.jetcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetcache-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：配置缓存</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">linkedhashmap</span></span><br><span class="line">      <span class="attr">keyConvertor:</span> <span class="string">fastjson</span></span><br><span class="line">  <span class="attr">remote:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">keyConvertor:</span> <span class="string">fastjson</span></span><br><span class="line">      <span class="attr">valueEncode:</span> <span class="string">java</span></span><br><span class="line">      <span class="attr">valueDecode:</span> <span class="string">java</span></span><br><span class="line">      <span class="attr">poolConfig:</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">sms:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">poolConfig:</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>​		由于 redis 缓存中不支持保存对象，因此需要对 redis 设置当 Object 类型数据进入到 redis 中时如何进行类型转换。需要配置 keyConvertor 表示 key 的类型转换方式，同时标注 value 的转换类型方式，值进入 redis 时是 java 类型，标注 valueEncode 为 java，值从 redis 中读取时转换成 java，标注 valueDecode 为 java。</p>
<p>​		注意，为了实现 Object 类型的值进出 redis，需要保障进出 redis 的 Object 类型的数据必须实现序列化接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：启用缓存时开启方法缓存功能，并配置 basePackages，说明在哪些包中开启方法缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//jetcache启用缓存的主开关</span></span><br><span class="line"><span class="meta">@EnableCreateCacheAnnotation</span></span><br><span class="line"><span class="comment">//开启方法注解缓存</span></span><br><span class="line"><span class="meta">@EnableMethodCache(basePackages = &quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot20JetCacheApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springboot20JetCacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤④</strong>：使用注解 @Cached 标注当前方法使用缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cached(name=&quot;book_&quot;,key=&quot;#id&quot;,expire = 3600,cacheType = CacheType.REMOTE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="远程方案的数据同步"><a class="markdownIt-Anchor" href="#远程方案的数据同步">#</a> 远程方案的数据同步</h5>
<p>​		由于远程方案中 redis 保存的数据可以被多个客户端共享，这就存在了数据同步问题。jetcache 提供了 3 个注解解决此问题，分别在更新、删除操作时同步缓存数据，和读取缓存时定时刷新数据</p>
<p><strong>更新缓存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheUpdate(name=&quot;book_&quot;,key=&quot;#book.id&quot;,value=&quot;#book&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bookDao.updateById(book) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>删除缓存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheInvalidate(name=&quot;book_&quot;,key = &quot;#id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bookDao.deleteById(id) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定时刷新缓存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cached(name=&quot;book_&quot;,key=&quot;#id&quot;,expire = 3600,cacheType = CacheType.REMOTE)</span></span><br><span class="line"><span class="meta">@CacheRefresh(refresh = 5)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">getById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bookDao.selectById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数据报表"><a class="markdownIt-Anchor" href="#数据报表">#</a> 数据报表</h5>
<p>​		jetcache 还提供有简单的数据报表功能，帮助开发者快速查看缓存命中信息，只需要添加一个配置即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">statIntervalMinutes:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>​		设置后，每 1 分钟在控制台输出缓存数据命中信息</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">[DefaultExecutor] c.alicp.jetcache.support.StatInfoLogger  : jetcache stat from <span class="number">2022</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">09</span>:<span class="number">32</span>:<span class="number">15</span>,<span class="number">892</span> to <span class="number">2022</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">09</span>:<span class="number">33</span>:<span class="number">00</span>,<span class="number">003</span></span><br><span class="line">cache    |    qps|   rate|   get|    hit|   fail|   expire|   avgLoadTime|   maxLoadTime</span><br><span class="line">---------+-------+-------+------+-------+-------+---------+--------------+--------------</span><br><span class="line">book_    |   <span class="number">0</span>.<span class="number">66</span>| <span class="number">75</span>.<span class="number">86</span>%|    <span class="number">29</span>|     <span class="number">22</span>|      <span class="number">0</span>|        <span class="number">0</span>|          <span class="number">28</span>.<span class="number">0</span>|           <span class="number">188</span></span><br><span class="line">---------+-------+-------+------+-------+-------+---------+--------------+--------------</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>jetcache 是一个类似于 springcache 的缓存解决方案，自身不具有缓存功能，它提供有本地缓存与远程缓存多级共同使用的缓存解决方案</li>
<li>jetcache 提供的缓存解决方案受限于目前支持的方案，本地缓存支持两种，远程缓存支持两种</li>
<li>注意数据进入远程缓存时的类型转换问题</li>
<li>jetcache 提供方法缓存，并提供了对应的缓存更新与刷新功能</li>
<li>jetcache 提供有简单的缓存信息命中报表方便开发者即时监控缓存数据命中情况</li>
</ol>
<p><strong>思考</strong></p>
<p>​		jetcache 解决了前期使用缓存方案单一的问题，但是仍然不能灵活的选择缓存进行搭配使用，是否存在一种技术可以灵活的搭配各种各样的缓存使用呢？有，咱们下一节再讲。</p>
<h4 id="springboot整合j2cache缓存"><a class="markdownIt-Anchor" href="#springboot整合j2cache缓存">#</a> SpringBoot 整合 j2cache 缓存</h4>
<p>​		jetcache 可以在限定范围内构建多级缓存，但是灵活性不足，不能随意搭配缓存，本节介绍一种可以随意搭配缓存解决方案的缓存整合框架，j2cache。下面就来讲解如何使用这种缓存框架，以 Ehcache 与 redis 整合为例：</p>
<p><strong>步骤①</strong>：导入 j2cache、redis、ehcache 坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.oschina.j2cache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>j2cache-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.4-release<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.oschina.j2cache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>j2cache-spring-boot2-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0-release<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		j2cache 的 starter 中默认包含了 redis 坐标，官方推荐使用 redis 作为二级缓存，因此此处无需导入 redis 坐标</p>
<p><strong>步骤②</strong>：配置一级与二级缓存，并配置一二级缓存间数据传递方式，配置书写在名称为 j2cache.properties 的文件中。如果使用 ehcache 还需要单独添加 ehcache 的配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1级缓存</span></span><br><span class="line"><span class="string">j2cache.L1.provider_class</span> <span class="string">=</span> <span class="string">ehcache</span></span><br><span class="line"><span class="string">ehcache.configXml</span> <span class="string">=</span> <span class="string">ehcache.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2级缓存</span></span><br><span class="line"><span class="string">j2cache.L2.provider_class</span> <span class="string">=</span> <span class="string">net.oschina.j2cache.cache.support.redis.SpringRedisProvider</span></span><br><span class="line"><span class="string">j2cache.L2.config_section</span> <span class="string">=</span> <span class="string">redis</span></span><br><span class="line"><span class="string">redis.hosts</span> <span class="string">=</span> <span class="string">localhost:6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1级缓存中的数据如何到达二级缓存</span></span><br><span class="line"><span class="string">j2cache.broadcast</span> <span class="string">=</span> <span class="string">net.oschina.j2cache.cache.support.redis.SpringRedisPubSubPolicy</span></span><br></pre></td></tr></table></figure>
<p>​		此处配置不能乱配置，需要参照官方给出的配置说明进行。例如 1 级供应商选择 ehcache，供应商名称仅仅是一个 ehcache，但是 2 级供应商选择 redis 时要写专用的 Spring 整合 Redis 的供应商类名 SpringRedisProvider，而且这个名称并不是所有的 redis 包中能提供的，也不是 spring 包中提供的。因此配置 j2cache 必须参照官方文档配置，而且还要去找专用的整合包，导入对应坐标才可以使用。</p>
<p>​		一级与二级缓存最重要的一个配置就是两者之间的数据沟通方式，此类配置也不是随意配置的，并且不同的缓存解决方案提供的数据沟通方式差异化很大，需要查询官方文档进行设置。</p>
<p><strong>步骤③</strong>：使用缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSCodeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SMSCodeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CodeUtils codeUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CacheChannel cacheChannel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendCodeToSMS</span><span class="params">(String tele)</span> </span>&#123;</span><br><span class="line">        String code = codeUtils.generator(tele);</span><br><span class="line">        cacheChannel.set(<span class="string">&quot;sms&quot;</span>,tele,code);</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkCode</span><span class="params">(SMSCode smsCode)</span> </span>&#123;</span><br><span class="line">        String code = cacheChannel.get(<span class="string">&quot;sms&quot;</span>,smsCode.getTele()).asString();</span><br><span class="line">        <span class="keyword">return</span> smsCode.getCode().equals(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		j2cache 的使用和 jetcache 比较类似，但是无需开启使用的开关，直接定义缓存对象即可使用，缓存对象名 CacheChannel。</p>
<p>​		j2cache 的使用不复杂，配置是 j2cache 的核心，毕竟是一个整合型的缓存框架。缓存相关的配置过多，可以查阅 j2cache-core 核心包中的 j2cache.properties 文件中的说明。如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#J2Cache configuration</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># Cache Broadcast Method</span></span><br><span class="line"><span class="comment"># values:</span></span><br><span class="line"><span class="comment"># jgroups -&gt; use jgroups&#x27;s multicast</span></span><br><span class="line"><span class="comment"># redis -&gt; use redis publish/subscribe mechanism (using jedis)</span></span><br><span class="line"><span class="comment"># lettuce -&gt; use redis publish/subscribe mechanism (using lettuce, Recommend)</span></span><br><span class="line"><span class="comment"># rabbitmq -&gt; use RabbitMQ publisher/consumer mechanism</span></span><br><span class="line"><span class="comment"># rocketmq -&gt; use RocketMQ publisher/consumer mechanism</span></span><br><span class="line"><span class="comment"># none -&gt; don&#x27;t notify the other nodes in cluster</span></span><br><span class="line"><span class="comment"># xx.xxxx.xxxx.Xxxxx your own cache broadcast policy classname that implement net.oschina.j2cache.cluster.ClusterPolicy</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="meta">j2cache.broadcast</span> = <span class="string">redis</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># jgroups properties</span></span><br><span class="line"><span class="meta">jgroups.channel.name</span> = <span class="string">j2cache</span></span><br><span class="line"><span class="meta">jgroups.configXml</span> = <span class="string">/network.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RabbitMQ properties</span></span><br><span class="line"><span class="meta">rabbitmq.exchange</span> = <span class="string">j2cache</span></span><br><span class="line"><span class="meta">rabbitmq.host</span> = <span class="string">localhost</span></span><br><span class="line"><span class="meta">rabbitmq.port</span> = <span class="string">5672</span></span><br><span class="line"><span class="meta">rabbitmq.username</span> = <span class="string">guest</span></span><br><span class="line"><span class="meta">rabbitmq.password</span> = <span class="string">guest</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RocketMQ properties</span></span><br><span class="line"><span class="meta">rocketmq.name</span> = <span class="string">j2cache</span></span><br><span class="line"><span class="meta">rocketmq.topic</span> = <span class="string">j2cache</span></span><br><span class="line"><span class="comment"># use ; to split multi hosts</span></span><br><span class="line"><span class="meta">rocketmq.hosts</span> = <span class="string">127.0.0.1:9876</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># Level 1&amp;2 provider</span></span><br><span class="line"><span class="comment"># values:</span></span><br><span class="line"><span class="comment"># none -&gt; disable this level cache</span></span><br><span class="line"><span class="comment"># ehcache -&gt; use ehcache2 as level 1 cache</span></span><br><span class="line"><span class="comment"># ehcache3 -&gt; use ehcache3 as level 1 cache</span></span><br><span class="line"><span class="comment"># caffeine -&gt; use caffeine as level 1 cache(only in memory)</span></span><br><span class="line"><span class="comment"># redis -&gt; use redis as level 2 cache (using jedis)</span></span><br><span class="line"><span class="comment"># lettuce -&gt; use redis as level 2 cache (using lettuce)</span></span><br><span class="line"><span class="comment"># readonly-redis -&gt; use redis as level 2 cache ,but never write data to it. if use this provider, you must uncomment `j2cache.L2.config_section` to make the redis configurations available.</span></span><br><span class="line"><span class="comment"># memcached -&gt; use memcached as level 2 cache (xmemcached),</span></span><br><span class="line"><span class="comment"># [classname] -&gt; use custom provider</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">j2cache.L1.provider_class</span> = <span class="string">caffeine</span></span><br><span class="line"><span class="meta">j2cache.L2.provider_class</span> = <span class="string">redis</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># When L2 provider isn&#x27;t `redis`, using `L2.config_section = redis` to read redis configurations</span></span><br><span class="line"><span class="comment"># j2cache.L2.config_section = redis</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Enable/Disable ttl in redis cache data (if disabled, the object in redis will never expire, default:true)</span></span><br><span class="line"><span class="comment"># NOTICE: redis hash mode (redis.storage = hash) do not support this feature)</span></span><br><span class="line"><span class="meta">j2cache.sync_ttl_to_redis</span> = <span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Whether to cache null objects by default (default false)</span></span><br><span class="line"><span class="meta">j2cache.default_cache_null_object</span> = <span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># Cache Serialization Provider</span></span><br><span class="line"><span class="comment"># values:</span></span><br><span class="line"><span class="comment"># fst -&gt; using fast-serialization (recommend)</span></span><br><span class="line"><span class="comment"># kryo -&gt; using kryo serialization</span></span><br><span class="line"><span class="comment"># json -&gt; using fst&#x27;s json serialization (testing)</span></span><br><span class="line"><span class="comment"># fastjson -&gt; using fastjson serialization (embed non-static class not support)</span></span><br><span class="line"><span class="comment"># java -&gt; java standard</span></span><br><span class="line"><span class="comment"># fse -&gt; using fse serialization</span></span><br><span class="line"><span class="comment"># [classname implements Serializer]</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">j2cache.serialization</span> = <span class="string">json</span></span><br><span class="line"><span class="comment">#json.map.person = net.oschina.j2cache.demo.Person</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># Ehcache configuration</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># ehcache.configXml = /ehcache.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># ehcache3.configXml = /ehcache3.xml</span></span><br><span class="line"><span class="comment"># ehcache3.defaultHeapSize = 1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># Caffeine configuration</span></span><br><span class="line"><span class="comment"># caffeine.region.[name] = size, xxxx[s|m|h|d]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="meta">caffeine.properties</span> = <span class="string">/caffeine.properties</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># Redis connection configuration</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># Redis Cluster Mode</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># single -&gt; single redis server</span></span><br><span class="line"><span class="comment"># sentinel -&gt; master-slaves servers</span></span><br><span class="line"><span class="comment"># cluster -&gt; cluster servers (数据库配置无效，使用 database = 0）</span></span><br><span class="line"><span class="comment"># sharded -&gt; sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">redis.mode</span> = <span class="string">single</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#redis storage mode (generic|hash)</span></span><br><span class="line"><span class="meta">redis.storage</span> = <span class="string">generic</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## redis pub/sub channel name</span></span><br><span class="line"><span class="meta">redis.channel</span> = <span class="string">j2cache</span></span><br><span class="line"><span class="comment">## redis pub/sub server (using redis.hosts when empty)</span></span><br><span class="line"><span class="meta">redis.channel.host</span> =<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#cluster name just for sharded</span></span><br><span class="line"><span class="meta">redis.cluster_name</span> = <span class="string">j2cache</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## redis cache namespace optional, default[empty]</span></span><br><span class="line"><span class="meta">redis.namespace</span> =<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## redis command scan parameter count, default[1000]</span></span><br><span class="line"><span class="comment">#redis.scanCount = 1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## connection</span></span><br><span class="line"><span class="comment"># Separate multiple redis nodes with commas, such as 192.168.0.10:6379,192.168.0.11:6379,192.168.0.12:6379</span></span><br><span class="line"></span><br><span class="line"><span class="meta">redis.hosts</span> = <span class="string">127.0.0.1:6379</span></span><br><span class="line"><span class="meta">redis.timeout</span> = <span class="string">2000</span></span><br><span class="line"><span class="meta">redis.password</span> =<span class="string"></span></span><br><span class="line"><span class="meta">redis.database</span> = <span class="string">0</span></span><br><span class="line"><span class="meta">redis.ssl</span> = <span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## redis pool properties</span></span><br><span class="line"><span class="meta">redis.maxTotal</span> = <span class="string">100</span></span><br><span class="line"><span class="meta">redis.maxIdle</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">redis.maxWaitMillis</span> = <span class="string">5000</span></span><br><span class="line"><span class="meta">redis.minEvictableIdleTimeMillis</span> = <span class="string">60000</span></span><br><span class="line"><span class="meta">redis.minIdle</span> = <span class="string">1</span></span><br><span class="line"><span class="meta">redis.numTestsPerEvictionRun</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">redis.lifo</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">redis.softMinEvictableIdleTimeMillis</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">redis.testOnBorrow</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">redis.testOnReturn</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">redis.testWhileIdle</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">redis.timeBetweenEvictionRunsMillis</span> = <span class="string">300000</span></span><br><span class="line"><span class="meta">redis.blockWhenExhausted</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">redis.jmxEnabled</span> = <span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># Lettuce scheme</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># redis -&gt; single redis server</span></span><br><span class="line"><span class="comment"># rediss -&gt; single redis server with ssl</span></span><br><span class="line"><span class="comment"># redis-sentinel -&gt; redis sentinel</span></span><br><span class="line"><span class="comment"># redis-cluster -&gt; cluster servers</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># Lettuce Mode</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># single -&gt; single redis server</span></span><br><span class="line"><span class="comment"># sentinel -&gt; master-slaves servers</span></span><br><span class="line"><span class="comment"># cluster -&gt; cluster servers (数据库配置无效，使用 database = 0）</span></span><br><span class="line"><span class="comment"># sharded -&gt; sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## redis command scan parameter count, default[1000]</span></span><br><span class="line"><span class="comment">#lettuce.scanCount = 1000</span></span><br><span class="line"><span class="meta">lettuce.mode</span> = <span class="string">single</span></span><br><span class="line"><span class="meta">lettuce.namespace</span> =<span class="string"></span></span><br><span class="line"><span class="meta">lettuce.storage</span> = <span class="string">hash</span></span><br><span class="line"><span class="meta">lettuce.channel</span> = <span class="string">j2cache</span></span><br><span class="line"><span class="meta">lettuce.scheme</span> = <span class="string">redis</span></span><br><span class="line"><span class="meta">lettuce.hosts</span> = <span class="string">127.0.0.1:6379</span></span><br><span class="line"><span class="meta">lettuce.password</span> =<span class="string"></span></span><br><span class="line"><span class="meta">lettuce.database</span> = <span class="string">0</span></span><br><span class="line"><span class="meta">lettuce.sentinelMasterId</span> =<span class="string"></span></span><br><span class="line"><span class="meta">lettuce.maxTotal</span> = <span class="string">100</span></span><br><span class="line"><span class="meta">lettuce.maxIdle</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">lettuce.minIdle</span> = <span class="string">10</span></span><br><span class="line"><span class="comment"># timeout in milliseconds</span></span><br><span class="line"><span class="meta">lettuce.timeout</span> = <span class="string">10000</span></span><br><span class="line"><span class="comment"># redis cluster topology refresh interval in milliseconds</span></span><br><span class="line"><span class="meta">lettuce.clusterTopologyRefresh</span> = <span class="string">3000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># memcached server configurations</span></span><br><span class="line"><span class="comment"># refer to https://gitee.com/mirrors/XMemcached</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">memcached.servers</span> = <span class="string">127.0.0.1:11211</span></span><br><span class="line"><span class="meta">memcached.username</span> =<span class="string"></span></span><br><span class="line"><span class="meta">memcached.password</span> =<span class="string"></span></span><br><span class="line"><span class="meta">memcached.connectionPoolSize</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">memcached.connectTimeout</span> = <span class="string">1000</span></span><br><span class="line"><span class="meta">memcached.failureMode</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">memcached.healSessionInterval</span> = <span class="string">1000</span></span><br><span class="line"><span class="meta">memcached.maxQueuedNoReplyOperations</span> = <span class="string">100</span></span><br><span class="line"><span class="meta">memcached.opTimeout</span> = <span class="string">100</span></span><br><span class="line"><span class="meta">memcached.sanitizeKeys</span> = <span class="string">false</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>j2cache 是一个缓存框架，自身不具有缓存功能，它提供多种缓存整合在一起使用的方案</li>
<li>j2cache 需要通过复杂的配置设置各级缓存，以及缓存之间数据交换的方式</li>
<li>j2cache 操作接口通过 CacheChannel 实现</li>
</ol>
<h3 id="kf-5-2任务"><a class="markdownIt-Anchor" href="#kf-5-2任务">#</a> KF-5-2. 任务</h3>
<p>​		springboot 整合第三方技术第二部分我们来说说任务系统，其实这里说的任务系统指的是定时任务。定时任务是企业级开发中必不可少的组成部分，诸如长周期业务数据的计算，例如年度报表，诸如系统脏数据的处理，再比如系统性能监控报告，还有抢购类活动的商品上架，这些都离不开定时任务。本节将介绍两种不同的定时任务技术。</p>
<h4 id="quartz"><a class="markdownIt-Anchor" href="#quartz">#</a> Quartz</h4>
<p>​		Quartz 技术是一个比较成熟的定时任务框架，怎么说呢？有点繁琐，用过的都知道，配置略微复杂。springboot 对其进行整合后，简化了一系列的配置，将很多配置采用默认设置，这样开发阶段就简化了很多。再学习 springboot 整合 Quartz 前先普及几个 Quartz 的概念。</p>
<ul>
<li>工作（Job）：用于定义具体执行的工作</li>
<li>工作明细（JobDetail）：用于描述定时工作相关的信息</li>
<li>触发器（Trigger）：描述了工作明细与调度器的对应关系</li>
<li>调度器（Scheduler）：用于描述触发工作的执行规则，通常使用 cron 表达式定义规则</li>
</ul>
<p>​		简单说就是你定时干什么事情，这就是工作，工作不可能就是一个简单的方法，还要设置一些明细信息。工作啥时候执行，设置一个调度器，可以简单理解成设置一个工作执行的时间。工作和调度都是独立定义的，它们两个怎么配合到一起呢？用触发器。完了，就这么多。下面开始 springboot 整合 Quartz。</p>
<p><strong>步骤①</strong>：导入 springboot 整合 Quartz 的 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：定义任务 Bean，按照 Quartz 的开发规范制作，继承 QuartzJobBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQuartz</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quartz task run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：创建 Quartz 配置类，定义工作明细（JobDetail）与触发器的（Trigger）bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">printJobDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//绑定具体的工作</span></span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(MyQuartz.class).storeDurably().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">printJobTrigger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ScheduleBuilder schedBuilder = CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/5 * * * * ?&quot;</span>);</span><br><span class="line">        <span class="comment">//绑定对应的工作明细</span></span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger().forJob(printJobDetail()).withSchedule(schedBuilder).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		工作明细中要设置对应的具体工作，使用 newJob () 操作传入对应的工作任务类型即可。</p>
<p>​		触发器需要绑定任务，使用 forJob () 操作传入绑定的工作明细对象。此处可以为工作明细设置名称然后使用名称绑定，也可以直接调用对应方法绑定。触发器中最核心的规则是执行时间，此处使用调度器定义执行时间，执行时间描述方式使用的是 cron 表达式。有关 cron 表达式的规则，各位小伙伴可以去参看相关课程学习，略微复杂，而且格式不能乱设置，不是写个格式就能用的，写不好就会出现冲突问题。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 整合 Quartz 就是将 Quartz 对应的核心对象交给 spring 容器管理，包含两个对象，JobDetail 和 Trigger 对象</li>
<li>JobDetail 对象描述的是工作的执行信息，需要绑定一个 QuartzJobBean 类型的对象</li>
<li>Trigger 对象定义了一个触发器，需要为其指定绑定的 JobDetail 是哪个，同时要设置执行周期调度器</li>
</ol>
<p><strong>思考</strong></p>
<p>​		上面的操作看上去不多，但是 Quartz 将其中的对象划分粒度过细，导致开发的时候有点繁琐，spring 针对上述规则进行了简化，开发了自己的任务管理组件 ——Task，如何用呢？咱们下节再说。</p>
<h4 id="task"><a class="markdownIt-Anchor" href="#task">#</a> Task</h4>
<p>​		spring 根据定时任务的特征，将定时任务的开发简化到了极致。怎么说呢？要做定时任务总要告诉容器有这功能吧，然后定时执行什么任务直接告诉对应的 bean 什么时间执行就行了，就这么简单，一起来看怎么做</p>
<p><strong>步骤①</strong>：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解 @EnableScheduling</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//开启定时任务功能</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot22TaskApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springboot22TaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：定义 Bean，在对应要定时执行的操作上方，使用注解 @Scheduled 定义执行的时间，执行时间的描述方式还是 cron 表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; :spring task run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		完事，这就完成了定时任务的配置。总体感觉其实什么东西都没少，只不过没有将所有的信息都抽取成 bean，而是直接使用注解绑定定时执行任务的事情而已。</p>
<p>​		如何想对定时任务进行相关配置，可以通过配置文件进行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">task:</span></span><br><span class="line">   	<span class="attr">scheduling:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">       	<span class="attr">size:</span> <span class="number">1</span>							<span class="comment"># 任务调度线程池大小 默认 1</span></span><br><span class="line">      <span class="attr">thread-name-prefix:</span> <span class="string">ssm_</span>      	<span class="comment"># 调度线程名称前缀 默认 scheduling-      </span></span><br><span class="line">        <span class="attr">shutdown:</span></span><br><span class="line">          <span class="attr">await-termination:</span> <span class="literal">false</span>		<span class="comment"># 线程池关闭时等待所有任务完成</span></span><br><span class="line">          <span class="attr">await-termination-period:</span> <span class="string">10s</span>	<span class="comment"># 调度线程关闭前最大等待时间，确保最后一定关闭</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>
<p>spring task 需要使用注解 @EnableScheduling 开启定时任务功能</p>
</li>
<li>
<p>为定时执行的的任务设置执行周期，描述方式 cron 表达式</p>
</li>
</ol>
<h3 id="kf-5-3邮件"><a class="markdownIt-Anchor" href="#kf-5-3邮件">#</a> KF-5-3. 邮件</h3>
<p>​		springboot 整合第三方技术第三部分我们来说说邮件系统，发邮件是 java 程序的基本操作，springboot 整合 javamail 其实就是简化开发。不熟悉邮件的小伙伴可以先学习完 javamail 的基础操作，再来看这一部分内容才能感触到 springboot 整合 javamail 究竟简化了哪些操作。简化的多码？其实不多，差别不大，只是还个格式而已。</p>
<p>​		学习邮件发送之前先了解 3 个概念，这些概念规范了邮件操作过程中的标准。</p>
<ul>
<li>SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于<strong>发送</strong>电子邮件的传输协议</li>
<li>POP3（Post Office Protocol - Version 3）：用于<strong>接收</strong>电子邮件的标准协议</li>
<li>IMAP（Internet Mail Access Protocol）：互联网消息协议，是 POP3 的替代协议</li>
</ul>
<p>​		简单说就是 SMPT 是发邮件的标准，POP3 是收邮件的标准，IMAP 是对 POP3 的升级。我们制作程序中操作邮件，通常是发邮件，所以 SMTP 是使用的重点，收邮件大部分都是通过邮件客户端完成，所以开发收邮件的代码极少。除非你要读取邮件内容，然后解析，做邮件功能的统一处理。例如 HR 的邮箱收到求职者的简历，可以读取后统一处理。但是为什么不制作独立的投递简历的系统呢？所以说，好奇怪的需求，因为要想收邮件就要规范发邮件的人的书写格式，这个未免有点强人所难，并且极易收到外部攻击，你不可能使用白名单来收邮件。如果能使用白名单来收邮件然后解析邮件，还不如开发个系统给白名单中的人专用呢，更安全，总之就是鸡肋了。下面就开始学习 springboot 如何整合 javamail 发送邮件。</p>
<h4 id="发送简单邮件"><a class="markdownIt-Anchor" href="#发送简单邮件">#</a> 发送简单邮件</h4>
<p><strong>步骤①</strong>：导入 springboot 整合 javamail 的 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：配置邮箱的登录信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.126.com</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test@126.com</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>
<p>​		java 程序仅用于发送邮件，邮件的功能还是邮件供应商提供的，所以这里是用别人的邮件服务，要配置对应信息。</p>
<p>​		host 配置的是提供邮件服务的主机协议，当前程序仅用于发送邮件，因此配置的是 smtp 的协议。</p>
<p>​		password 并不是邮箱账号的登录密码，是邮件供应商提供的一个加密后的密码，也是为了保障系统安全性。不然外部人员通过地址访问下载了配置文件，直接获取到了邮件密码就会有极大的安全隐患。有关该密码的获取每个邮件供应商提供的方式都不一样，此处略过。可以到邮件供应商的设置页面找 POP3 或 IMAP 这些关键词找到对应的获取位置。下例仅供参考：</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228111251036.png" alt="image-20220228111251036"></p>
<p><strong>步骤③</strong>：使用 JavaMailSender 接口发送邮件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailServiceImpl</span> <span class="keyword">implements</span> <span class="title">SendMailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender javaMailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送人</span></span><br><span class="line">    <span class="keyword">private</span> String from = <span class="string">&quot;test@qq.com&quot;</span>;</span><br><span class="line">    <span class="comment">//接收人</span></span><br><span class="line">    <span class="keyword">private</span> String to = <span class="string">&quot;test@126.com&quot;</span>;</span><br><span class="line">    <span class="comment">//标题</span></span><br><span class="line">    <span class="keyword">private</span> String subject = <span class="string">&quot;测试邮件&quot;</span>;</span><br><span class="line">    <span class="comment">//正文</span></span><br><span class="line">    <span class="keyword">private</span> String context = <span class="string">&quot;测试邮件正文内容&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">        message.setFrom(from+<span class="string">&quot;(小甜甜)&quot;</span>);</span><br><span class="line">        message.setTo(to);</span><br><span class="line">        message.setSubject(subject);</span><br><span class="line">        message.setText(context);</span><br><span class="line">        javaMailSender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		将发送邮件的必要信息（发件人、收件人、标题、正文）封装到 SimpleMailMessage 对象中，可以根据规则设置发送人昵称等。</p>
<h4 id="发送多组件邮件附件-复杂正文"><a class="markdownIt-Anchor" href="#发送多组件邮件附件-复杂正文">#</a> 发送多组件邮件（附件、复杂正文）</h4>
<p>​		发送简单邮件仅需要提供对应的 4 个基本信息就可以了，如果想发送复杂的邮件，需要更换邮件对象。使用 MimeMessage 可以发送特殊的邮件。</p>
<p><strong>发送网页正文邮件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailServiceImpl2</span> <span class="keyword">implements</span> <span class="title">SendMailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender javaMailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送人</span></span><br><span class="line">    <span class="keyword">private</span> String from = <span class="string">&quot;test@qq.com&quot;</span>;</span><br><span class="line">    <span class="comment">//接收人</span></span><br><span class="line">    <span class="keyword">private</span> String to = <span class="string">&quot;test@126.com&quot;</span>;</span><br><span class="line">    <span class="comment">//标题</span></span><br><span class="line">    <span class="keyword">private</span> String subject = <span class="string">&quot;测试邮件&quot;</span>;</span><br><span class="line">    <span class="comment">//正文</span></span><br><span class="line">    <span class="keyword">private</span> String context = <span class="string">&quot;&lt;img src=&#x27;ABC.JPG&#x27;/&gt;&lt;a href=&#x27;https://www.itcast.cn&#x27;&gt;点开有惊喜&lt;/a&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MimeMessage message = javaMailSender.createMimeMessage();</span><br><span class="line">            MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(message);</span><br><span class="line">            helper.setFrom(to+<span class="string">&quot;(小甜甜)&quot;</span>);</span><br><span class="line">            helper.setTo(from);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(context,<span class="keyword">true</span>);		<span class="comment">//此处设置正文支持html解析</span></span><br><span class="line"></span><br><span class="line">            javaMailSender.send(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发送带有附件的邮件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailServiceImpl2</span> <span class="keyword">implements</span> <span class="title">SendMailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender javaMailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送人</span></span><br><span class="line">    <span class="keyword">private</span> String from = <span class="string">&quot;test@qq.com&quot;</span>;</span><br><span class="line">    <span class="comment">//接收人</span></span><br><span class="line">    <span class="keyword">private</span> String to = <span class="string">&quot;test@126.com&quot;</span>;</span><br><span class="line">    <span class="comment">//标题</span></span><br><span class="line">    <span class="keyword">private</span> String subject = <span class="string">&quot;测试邮件&quot;</span>;</span><br><span class="line">    <span class="comment">//正文</span></span><br><span class="line">    <span class="keyword">private</span> String context = <span class="string">&quot;测试邮件正文&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MimeMessage message = javaMailSender.createMimeMessage();</span><br><span class="line">            MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(message,<span class="keyword">true</span>);		<span class="comment">//此处设置支持附件</span></span><br><span class="line">            helper.setFrom(to+<span class="string">&quot;(小甜甜)&quot;</span>);</span><br><span class="line">            helper.setTo(from);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(context);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加附件</span></span><br><span class="line">            File f1 = <span class="keyword">new</span> File(<span class="string">&quot;springboot_23_mail-0.0.1-SNAPSHOT.jar&quot;</span>);</span><br><span class="line">            File f2 = <span class="keyword">new</span> File(<span class="string">&quot;resources\\logo.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">            helper.addAttachment(f1.getName(),f1);</span><br><span class="line">            helper.addAttachment(<span class="string">&quot;最靠谱的培训结构.png&quot;</span>,f2);</span><br><span class="line"></span><br><span class="line">            javaMailSender.send(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>springboot 整合 javamail 其实就是简化了发送邮件的客户端对象 JavaMailSender 的初始化过程，通过配置的形式加载信息简化开发过程</li>
</ol>
<h3 id="kf-5-4消息"><a class="markdownIt-Anchor" href="#kf-5-4消息">#</a> KF-5-4. 消息</h3>
<p>​		springboot 整合第三方技术最后一部分我们来说说消息中间件，首先先介绍一下消息的应用。</p>
<h4 id="消息的概念"><a class="markdownIt-Anchor" href="#消息的概念">#</a> 消息的概念</h4>
<p>​		从广义角度来说，消息其实就是信息，但是和信息又有所不同。信息通常被定义为一组数据，而消息除了具有数据的特征之外，还有消息的来源与接收的概念。通常发送消息的一方称为消息的生产者，接收消息的一方称为消息的消费者。这样比较后，发现其实消息和信息差别还是很大的。</p>
<p>​		为什么要设置生产者和消费者呢？这就是要说到消息的意义了。信息通常就是一组数据，但是消息由于有了生产者和消费者，就出现了消息中所包含的信息可以被二次解读，生产者发送消息，可以理解为生产者发送了一个信息，也可以理解为生产者发送了一个命令；消费者接收消息，可以理解为消费者得到了一个信息，也可以理解为消费者得到了一个命令。对比一下我们会发现信息是一个基本数据，而命令则可以关联下一个行为动作，这样就可以理解为基于接收的消息相当于得到了一个行为动作，使用这些行为动作就可以组织成一个业务逻辑，进行进一步的操作。总的来说，消息其实也是一组信息，只是为其赋予了全新的含义，因为有了消息的流动，并且是有方向性的流动，带来了基于流动的行为产生的全新解读。开发者就可以基于消息的这种特殊解，将其换成代码中的指令。</p>
<p>​		对于消息的理解，初学者总认为消息内部的数据非常复杂，这是一个误区。比如我发送了一个消息，要求接受者翻译发送过去的内容。初学者会认为消息中会包含被翻译的文字，已经本次操作要执行翻译操作而不是打印操作。其实这种现象有点过度解读了，发送的消息中仅仅包含被翻译的文字，但是可以通过控制不同的人接收此消息来确认要做的事情。例如发送被翻译的文字仅到 A 程序，而 A 程序只能进行翻译操作，这样就可以发送简单的信息完成复杂的业务了，是通过接收消息的主体不同，进而执行不同的操作，而不会在消息内部定义数据的操作行为，当然如果开发者希望消息中包含操作种类信息也是可以的，只是提出消息的内容可以更简单，更单一。</p>
<p>​		对于消息的生产者与消费者的工作模式，还可以将消息划分成两种模式，同步消费与异步消息。</p>
<p>​		所谓同步消息就是生产者发送完消息，等待消费者处理，消费者处理完将结果告知生产者，然后生产者继续向下执行业务。这种模式过于卡生产者的业务执行连续性，在现在的企业级开发中，上述这种业务场景通常不会采用消息的形式进行处理。</p>
<p>​		所谓异步消息就是生产者发送完消息，无需等待消费者处理完毕，生产者继续向下执行其他动作。比如生产者发送了一个日志信息给日志系统，发送过去以后生产者就向下做其他事情了，无需关注日志系统的执行结果。日志系统根据接收到的日志信息继续进行业务执行，是单纯的记录日志，还是记录日志并报警，这些和生产者无关，这样生产者的业务执行效率就会大幅度提升。并且可以通过添加多个消费者来处理同一个生产者发送的消息来提高系统的高并发性，改善系统工作效率，提高用户体验。一旦某一个消费者由于各种问题宕机了，也不会对业务产生影响，提高了系统的高可用性。</p>
<p>​		以上简单的介绍了一下消息这种工作模式存在的意义，希望对各位学习者有所帮助。</p>
<h4 id="java处理消息的标准规范"><a class="markdownIt-Anchor" href="#java处理消息的标准规范">#</a> Java 处理消息的标准规范</h4>
<p>​		目前企业级开发中广泛使用的消息处理技术共三大类，具体如下：</p>
<ul>
<li>JMS</li>
<li>AMQP</li>
<li>MQTT</li>
</ul>
<p>​		为什么是三大类，而不是三个技术呢？因为这些都是规范，就想 JDBC 技术，是个规范，开发针对规范开发，运行还要靠实现类，例如 MySQL 提供了 JDBC 的实现，最终运行靠的还是实现。并且这三类规范都是针对异步消息进行处理的，也符合消息的设计本质，处理异步的业务。对以上三种消息规范做一下普及</p>
<h5 id="jms"><a class="markdownIt-Anchor" href="#jms">#</a> JMS</h5>
<p>​		JMS（Java Message Service）, 这是一个规范，作用等同于 JDBC 规范，提供了与消息服务相关的 API 接口。</p>
<p><strong>JMS 消息模型</strong></p>
<p>​		JMS 规范中规范了消息有两种模型。分别是<strong>点对点模型</strong>和<strong>发布订阅模型</strong>。</p>
<p>​		<strong>点对点模型</strong>：peer-2-peer，生产者会将消息发送到一个保存消息的容器中，通常使用队列模型，使用队列保存消息。一个队列的消息只能被一个消费者消费，或未被及时消费导致超时。这种模型下，生产者和消费者是一对一绑定的。</p>
<p>​		<strong>发布订阅模型</strong>：publish-subscribe，生产者将消息发送到一个保存消息的容器中，也是使用队列模型来保存。但是消息可以被多个消费者消费，生产者和消费者完全独立，相互不需要感知对方的存在。</p>
<p>​		以上这种分类是从消息的生产和消费过程来进行区分，针对消息所包含的信息不同，还可以进行不同类别的划分。</p>
<p><strong>JMS 消息种类</strong></p>
<p>​		根据消息中包含的数据种类划分，可以将消息划分成 6 种消息。</p>
<ul>
<li>TextMessage</li>
<li>MapMessage</li>
<li>BytesMessage</li>
<li>StreamMessage</li>
<li>ObjectMessage</li>
<li>Message （只有消息头和属性）</li>
</ul>
<p>​		JMS 主张不同种类的消息，消费方式不同，可以根据使用需要选择不同种类的消息。但是这一点也成为其诟病之处，后面再说。整体上来说，JMS 就是典型的保守派，什么都按照 J2EE 的规范来，做一套规范，定义若干个标准，每个标准下又提供一大批 API。目前对 JMS 规范实现的消息中间件技术还是挺多的，毕竟是皇家御用，肯定有人舔，例如 ActiveMQ、Redis、HornetMQ。但是也有一些不太规范的实现，参考 JMS 的标准设计，但是又不完全满足其规范，例如：RabbitMQ、RocketMQ。</p>
<h5 id="amqp"><a class="markdownIt-Anchor" href="#amqp">#</a> AMQP</h5>
<p>​		JMS 的问世为消息中间件提供了很强大的规范性支撑，但是使用的过程中就开始被人诟病，比如 JMS 设置的极其复杂的多种类消息处理机制。本来分门别类处理挺好的，为什么会被诟病呢？原因就在于 JMS 的设计是 J2EE 规范，站在 Java 开发的角度思考问题。但是现实往往是复杂度很高的。比如我有一个.NET 开发的系统 A，有一个 Java 开发的系统 B，现在要从 A 系统给 B 系统发业务消息，结果两边数据格式不统一，没法操作。JMS 不是可以统一数据格式吗？提供了 6 种数据种类，总有一款适合你啊。NO，一个都不能用。因为 A 系统的底层语言不是 Java 语言开发的，根本不支持那些对象。这就意味着如果想使用现有的业务系统 A 继续开发已经不可能了，必须推翻重新做使用 Java 语言开发的 A 系统。</p>
<p>​		这时候有人就提出说，你搞那么复杂，整那么多种类干什么？找一种大家都支持的消息数据类型不就解决这个跨平台的问题了吗？大家一想，对啊，于是 AMQP 孕育而生。</p>
<p>​		单从上面的说明中其实可以明确感知到，AMQP 的出现解决的是消息传递时使用的消息种类的问题，化繁为简，但是其并没有完全推翻 JMS 的操作 API，所以说 AMQP 仅仅是一种协议，规范了数据传输的格式而已。</p>
<p>​		AMQP（advanced message queuing protocol）：一种协议（高级消息队列协议，也是消息代理规范），规范了网络交换的数据格式，兼容 JMS 操作。<br>
<strong>优点</strong></p>
<p>​		具有跨平台性，服务器供应商，生产者，消费者可以使用不同的语言来实现</p>
<p><strong>JMS 消息种类</strong></p>
<p>​		AMQP 消息种类：byte []</p>
<p>​		AMQP 在 JMS 的消息模型基础上又进行了进一步的扩展，除了点对点和发布订阅的模型，开发了几种全新的消息模型，适应各种各样的消息发送。</p>
<p><strong>AMQP 消息模型</strong></p>
<ul>
<li>direct exchange</li>
<li>fanout exchange</li>
<li>topic exchange</li>
<li>headers exchange</li>
<li>system exchange</li>
</ul>
<p>​		目前实现了 AMQP 协议的消息中间件技术也很多，而且都是较为流行的技术，例如：RabbitMQ、StormMQ、RocketMQ</p>
<h5 id="mqtt"><a class="markdownIt-Anchor" href="#mqtt">#</a> MQTT</h5>
<p>​		MQTT（Message Queueing Telemetry Transport）消息队列遥测传输，专为小设备设计，是物联网（IOT）生态系统中主要成分之一。由于与 JavaEE 企业级开发没有交集，此处不作过多的说明。</p>
<p>​		除了上述 3 种 J2EE 企业级应用中广泛使用的三种异步消息传递技术，还有一种技术也不能忽略，Kafka。</p>
<h5 id="kafka"><a class="markdownIt-Anchor" href="#kafka">#</a> KafKa</h5>
<p>​		Kafka，一种高吞吐量的分布式发布订阅消息系统，提供实时消息功能。Kafka 技术并不是作为消息中间件为主要功能的产品，但是其拥有发布订阅的工作模式，也可以充当消息中间件来使用，而且目前企业级开发中其身影也不少见。</p>
<p>​		本节内容讲围绕着上述内容中的几种实现方案讲解 springboot 整合各种各样的消息中间件。由于各种消息中间件必须先安装再使用，下面的内容采用 Windows 系统安装，降低各位学习者的学习难度，基本套路和之前学习 NoSQL 解决方案一样，先安装再整合。</p>
<h4 id="购物订单发送手机短信案例"><a class="markdownIt-Anchor" href="#购物订单发送手机短信案例">#</a> 购物订单发送手机短信案例</h4>
<p>​		为了便于下面演示各种各样的消息中间件技术，我们创建一个购物过程生成订单时为用户发送短信的案例环境，模拟使用消息中间件实现发送手机短信的过程。</p>
<p>​		手机验证码案例需求如下：</p>
<ul>
<li>
<p>执行下单业务时（模拟此过程），调用消息服务，将要发送短信的订单 id 传递给消息中间件</p>
</li>
<li>
<p>消息处理服务接收到要发送的订单 id 后输出订单 id（模拟发短信）</p>
<p>由于不涉及数据读写，仅开发业务层与表现层，其中短信处理的业务代码独立开发，代码如下：</p>
</li>
</ul>
<p><strong>订单业务</strong></p>
<p>​		<strong>业务层接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">order</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		模拟传入订单 id，执行下订单业务，参数为虚拟设定，实际应为订单对应的实体类</p>
<p>​		<strong>业务层实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一系列操作，包含各种服务调用，处理各种业务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;订单处理开始&quot;</span>);</span><br><span class="line">        <span class="comment">//短信消息处理</span></span><br><span class="line">        messageService.sendMessage(id);</span><br><span class="line">        System.out.println(<span class="string">&quot;订单处理结束&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		业务层转调短信处理的服务 MessageService</p>
<p>​		<strong>表现层服务</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/orders&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span></span>&#123;</span><br><span class="line">        orderService.order(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		表现层对外开发接口，传入订单 id 即可（模拟）</p>
<p><strong>短信处理业务</strong></p>
<p>​		<strong>业务层接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String id)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">doMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		短信处理业务层接口提供两个操作，发送要处理的订单 id 到消息中间件，另一个操作目前暂且设计成处理消息，实际消息的处理过程不应该是手动执行，应该是自动执行，到具体实现时再进行设计</p>
<p>​		<strong>业务层实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; msgList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;待发送短信的订单已纳入处理队列，id：&quot;</span>+id);</span><br><span class="line">        msgList.add(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = msgList.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;已完成短信发送业务，id：&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		短信处理业务层实现中使用集合先模拟消息队列，观察效果</p>
<p>​		<strong>表现层服务</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/msgs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String id = messageService.doMessage();</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		短信处理表现层接口暂且开发出一个处理消息的入口，但是此业务是对应业务层中设计的模拟接口，实际业务不需要设计此接口。</p>
<p>​		下面开启 springboot 整合各种各样的消息中间件，从严格满足 JMS 规范的 ActiveMQ 开始</p>
<h4 id="springboot整合activemq"><a class="markdownIt-Anchor" href="#springboot整合activemq">#</a> SpringBoot 整合 ActiveMQ</h4>
<p>​		ActiveMQ 是 MQ 产品中的元老级产品，早期标准 MQ 产品之一，在 AMQP 协议没有出现之前，占据了消息中间件市场的绝大部分份额，后期因为 AMQP 系列产品的出现，迅速走弱，目前仅在一些线上运行的产品中出现，新产品开发较少采用。</p>
<h5 id="安装-4"><a class="markdownIt-Anchor" href="#安装-4">#</a> 安装</h5>
<p>​		windows 版安装包下载地址：<a href="https://activemq.apache.org/components/classic/download/">https://activemq.apache.org/components/classic/download</a><a href="https://activemq.apache.org/components/classic/download/">/</a></p>
<p>​		下载的安装包是解压缩就能使用的 zip 文件，解压缩完毕后会得到如下文件</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228160001620.png" alt="image-20220228160001620"></p>
<p><strong>启动服务器</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">activemq.bat</span><br></pre></td></tr></table></figure>
<p>​		运行 bin 目录下的 win32 或 win64 目录下的 activemq.bat 命令即可，根据自己的操作系统选择即可，默认对外服务端口 61616。</p>
<p><strong>访问 web 管理服务</strong></p>
<p>​		ActiveMQ 启动后会启动一个 Web 控制台服务，可以通过该服务管理 ActiveMQ。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">http://127.0.0.1:8161/</span></span><br></pre></td></tr></table></figure>
<p>​		web 管理服务默认端口 8161，访问后可以打开 ActiveMQ 的管理界面，如下：</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228160844972.png" alt="image-20220228160844972" style="zoom:67%;">
<p>​		首先输入访问用户名和密码，初始化用户名和密码相同，均为：admin，成功登录后进入管理后台界面，如下：</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228161010401.png" alt="image-20220228161010401"></p>
<p>​		看到上述界面视为启动 ActiveMQ 服务成功。</p>
<p><strong>启动失败</strong></p>
<p>​		在 ActiveMQ 启动时要占用多个端口，以下为正常启动信息：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wrapper  | --&gt; Wrapper Started as Console</span><br><span class="line">wrapper  | Launching a JVM...</span><br><span class="line">jvm <span class="number">1</span>    | Wrapper (Version <span class="number">3</span>.<span class="number">2</span>.<span class="number">3</span>) http://wrapper.tanukisoftware.org</span><br><span class="line">jvm <span class="number">1</span>    |   Copyright <span class="number">1999</span>-<span class="number">2006</span> Tanuki Software, Inc.  All Rights Reserved.</span><br><span class="line">jvm <span class="number">1</span>    |</span><br><span class="line">jvm <span class="number">1</span>    | Java Runtime: Oracle Corporation <span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span>_172 D:\soft\jdk1.<span class="number">8</span>.<span class="number">0</span>_172\jre</span><br><span class="line">jvm <span class="number">1</span>    |   Heap sizes: current=<span class="number">249344</span>k  free=<span class="number">235037</span>k  max=<span class="number">932352</span>k</span><br><span class="line">jvm <span class="number">1</span>    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.<span class="built_in">net</span>.ssl.keyStorePassword=password -Djavax.<span class="built_in">net</span>.ssl.trustStorePassword=password -Djavax.<span class="built_in">net</span>.ssl.keyStore=../../conf/broker.ks -Djavax.<span class="built_in">net</span>.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.<span class="built_in">path</span>=../../bin/win64 -Dwrapper.key=<span class="number">7</span>ySrCD75XhLCpLjd -Dwrapper.port=<span class="number">32000</span> -Dwrapper.jvm.port.min=<span class="number">31000</span> -Dwrapper.jvm.port.max=<span class="number">31999</span> -Dwrapper.pid=<span class="number">9364</span> -Dwrapper.version=<span class="number">3</span>.<span class="number">2</span>.<span class="number">3</span> -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=<span class="number">10</span> -Dwrapper.jvmid=<span class="number">1</span></span><br><span class="line">jvm <span class="number">1</span>    | Extensions classpath:</span><br><span class="line">jvm <span class="number">1</span>    |   [..\..\lib,..\..\lib\camel,..\..\lib\optional,..\..\lib\web,..\..\lib\extra]</span><br><span class="line">jvm <span class="number">1</span>    | ACTIVEMQ_HOME: ..\..</span><br><span class="line">jvm <span class="number">1</span>    | ACTIVEMQ_BASE: ..\..</span><br><span class="line">jvm <span class="number">1</span>    | ACTIVEMQ_CONF: ..\..\conf</span><br><span class="line">jvm <span class="number">1</span>    | ACTIVEMQ_DATA: ..\..\data</span><br><span class="line">jvm <span class="number">1</span>    | Loading message broker from: xbean:activemq.xml</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$<span class="number">1</span>@<span class="number">5</span>f3ebfe0: startup <span class="built_in">date</span> [Mon Feb <span class="number">28</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">48</span> CST <span class="number">2022</span>]; root of context hierarchy</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\soft\activemq\bin\win64\..\..\data\kahadb]</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | KahaDB is version <span class="number">7</span></span><br><span class="line">jvm <span class="number">1</span>    |  INFO | PListStore:[D:\soft\activemq\bin\win64\..\..\data\localhost\tmp_storage] started</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Apache ActiveMQ <span class="number">5</span>.<span class="number">16</span>.<span class="number">3</span> (localhost, ID:CZBK-<span class="number">20210302</span>VL-<span class="number">10434</span>-<span class="number">1646035669595</span>-<span class="number">0</span>:<span class="number">1</span>) is starting</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Listening <span class="keyword">for</span> connections <span class="built_in">at</span>: tcp://CZBK-<span class="number">20210302</span>VL:<span class="number">61616</span>?maximumConnections=<span class="number">1000</span>&amp;wireFormat.maxFrameSize=<span class="number">104857600</span></span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Connector openwire started</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Listening <span class="keyword">for</span> connections <span class="built_in">at</span>: amqp://CZBK-<span class="number">20210302</span>VL:<span class="number">5672</span>?maximumConnections=<span class="number">1000</span>&amp;wireFormat.maxFrameSize=<span class="number">104857600</span></span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Connector amqp started</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Listening <span class="keyword">for</span> connections <span class="built_in">at</span>: stomp://CZBK-<span class="number">20210302</span>VL:<span class="number">61613</span>?maximumConnections=<span class="number">1000</span>&amp;wireFormat.maxFrameSize=<span class="number">104857600</span></span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Connector stomp started</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Listening <span class="keyword">for</span> connections <span class="built_in">at</span>: mqtt://CZBK-<span class="number">20210302</span>VL:<span class="number">1883</span>?maximumConnections=<span class="number">1000</span>&amp;wireFormat.maxFrameSize=<span class="number">104857600</span></span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Connector mqtt started</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Starting Jetty server</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Creating Jetty connector</span><br><span class="line">jvm <span class="number">1</span>    |  WARN | ServletContext@o.e.j.s.ServletContextHandler@<span class="number">7350746</span>f&#123;/,null,STARTING&#125; has uncovered http methods <span class="keyword">for</span> <span class="built_in">path</span>: /</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Listening <span class="keyword">for</span> connections <span class="built_in">at</span> ws://CZBK-<span class="number">20210302</span>VL:<span class="number">61614</span>?maximumConnections=<span class="number">1000</span>&amp;wireFormat.maxFrameSize=<span class="number">104857600</span></span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Connector ws started</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Apache ActiveMQ <span class="number">5</span>.<span class="number">16</span>.<span class="number">3</span> (localhost, ID:CZBK-<span class="number">20210302</span>VL-<span class="number">10434</span>-<span class="number">1646035669595</span>-<span class="number">0</span>:<span class="number">1</span>) started</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | <span class="keyword">For</span> <span class="built_in">help</span> or <span class="built_in">more</span> information please see: http://activemq.apache.org</span><br><span class="line">jvm <span class="number">1</span>    |  WARN | Store limit is <span class="number">102400</span> mb (current store usage is <span class="number">0</span> mb). The data directory: D:\soft\activemq\bin\win64\..\..\data\kahadb only has <span class="number">68936</span> mb of usable space. - resetting to maximum available disk space: <span class="number">68936</span> mb</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | ActiveMQ WebConsole available <span class="built_in">at</span> http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8161</span>/</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | ActiveMQ Jolokia REST API available <span class="built_in">at</span> http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8161</span>/api/jolokia/</span><br></pre></td></tr></table></figure>
<p>​		其中占用的端口有：61616、5672、61613、1883、61614，如果启动失败，请先管理对应端口即可。以下就是某个端口占用的报错信息，可以从抛出异常的位置看出，启动 5672 端口时端口被占用，显示 java.net.BindException: Address already in use: JVM_Bind。Windows 系统中终止端口运行的操作参看<a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">【命令行启动常见问题及解决方案】</a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wrapper  | --&gt; Wrapper Started as Console</span><br><span class="line">wrapper  | Launching a JVM...</span><br><span class="line">jvm <span class="number">1</span>    | Wrapper (Version <span class="number">3</span>.<span class="number">2</span>.<span class="number">3</span>) http://wrapper.tanukisoftware.org</span><br><span class="line">jvm <span class="number">1</span>    |   Copyright <span class="number">1999</span>-<span class="number">2006</span> Tanuki Software, Inc.  All Rights Reserved.</span><br><span class="line">jvm <span class="number">1</span>    |</span><br><span class="line">jvm <span class="number">1</span>    | Java Runtime: Oracle Corporation <span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span>_172 D:\soft\jdk1.<span class="number">8</span>.<span class="number">0</span>_172\jre</span><br><span class="line">jvm <span class="number">1</span>    |   Heap sizes: current=<span class="number">249344</span>k  free=<span class="number">235038</span>k  max=<span class="number">932352</span>k</span><br><span class="line">jvm <span class="number">1</span>    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.<span class="built_in">net</span>.ssl.keyStorePassword=password -Djavax.<span class="built_in">net</span>.ssl.trustStorePassword=password -Djavax.<span class="built_in">net</span>.ssl.keyStore=../../conf/broker.ks -Djavax.<span class="built_in">net</span>.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.<span class="built_in">path</span>=../../bin/win64 -Dwrapper.key=QPJoy9ZoXeWmmwTS -Dwrapper.port=<span class="number">32000</span> -Dwrapper.jvm.port.min=<span class="number">31000</span> -Dwrapper.jvm.port.max=<span class="number">31999</span> -Dwrapper.pid=<span class="number">14836</span> -Dwrapper.version=<span class="number">3</span>.<span class="number">2</span>.<span class="number">3</span> -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=<span class="number">10</span> -Dwrapper.jvmid=<span class="number">1</span></span><br><span class="line">jvm <span class="number">1</span>    | Extensions classpath:</span><br><span class="line">jvm <span class="number">1</span>    |   [..\..\lib,..\..\lib\camel,..\..\lib\optional,..\..\lib\web,..\..\lib\extra]</span><br><span class="line">jvm <span class="number">1</span>    | ACTIVEMQ_HOME: ..\..</span><br><span class="line">jvm <span class="number">1</span>    | ACTIVEMQ_BASE: ..\..</span><br><span class="line">jvm <span class="number">1</span>    | ACTIVEMQ_CONF: ..\..\conf</span><br><span class="line">jvm <span class="number">1</span>    | ACTIVEMQ_DATA: ..\..\data</span><br><span class="line">jvm <span class="number">1</span>    | Loading message broker from: xbean:activemq.xml</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$<span class="number">1</span>@<span class="number">2</span>c9392f5: startup <span class="built_in">date</span> [Mon Feb <span class="number">28</span> <span class="number">16</span>:<span class="number">06</span>:<span class="number">16</span> CST <span class="number">2022</span>]; root of context hierarchy</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\soft\activemq\bin\win64\..\..\data\kahadb]</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | KahaDB is version <span class="number">7</span></span><br><span class="line">jvm <span class="number">1</span>    |  INFO | PListStore:[D:\soft\activemq\bin\win64\..\..\data\localhost\tmp_storage] started</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Apache ActiveMQ <span class="number">5</span>.<span class="number">16</span>.<span class="number">3</span> (localhost, ID:CZBK-<span class="number">20210302</span>VL-<span class="number">10257</span>-<span class="number">1646035577620</span>-<span class="number">0</span>:<span class="number">1</span>) is starting</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Listening <span class="keyword">for</span> connections <span class="built_in">at</span>: tcp://CZBK-<span class="number">20210302</span>VL:<span class="number">61616</span>?maximumConnections=<span class="number">1000</span>&amp;wireFormat.maxFrameSize=<span class="number">104857600</span></span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Connector openwire started</span><br><span class="line">jvm <span class="number">1</span>    | ERROR | Failed to <span class="built_in">start</span> Apache ActiveMQ (localhost, ID:CZBK-<span class="number">20210302</span>VL-<span class="number">10257</span>-<span class="number">1646035577620</span>-<span class="number">0</span>:<span class="number">1</span>)</span><br><span class="line">jvm <span class="number">1</span>    | java.io.IOException: Transport Connector could <span class="keyword">not</span> be registered <span class="keyword">in</span> JMX: java.io.IOException: Failed to bind to server socket: amqp://<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:<span class="number">5672</span>?maximumConnections=<span class="number">1000</span>&amp;wireFormat.maxFrameSize=<span class="number">104857600</span> due to: java.<span class="built_in">net</span>.BindException: Address already <span class="keyword">in</span> use: JVM_Bind</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:<span class="number">28</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:<span class="number">2288</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerService.startTransportConnector(BrokerService.java:<span class="number">2769</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerService.startAllConnectors(BrokerService.java:<span class="number">2665</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerService.doStartBroker(BrokerService.java:<span class="number">780</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerService.startBroker(BrokerService.java:<span class="number">742</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerService.<span class="built_in">start</span>(BrokerService.java:<span class="number">645</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:<span class="number">73</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:<span class="number">1748</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:<span class="number">1685</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:<span class="number">1615</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:<span class="number">553</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:<span class="number">481</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.beans.factory.support.AbstractBeanFactory$<span class="number">1</span>.getObject(AbstractBeanFactory.java:<span class="number">312</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">230</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">308</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">197</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:<span class="number">756</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:<span class="number">867</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">542</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:<span class="number">64</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:<span class="number">52</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.xbean.XBeanBrokerFactory$<span class="number">1</span>.&lt;init&gt;(XBeanBrokerFactory.java:<span class="number">104</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:<span class="number">104</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:<span class="number">67</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:<span class="number">71</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:<span class="number">54</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:<span class="number">87</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:<span class="number">63</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:<span class="number">154</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:<span class="number">63</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:<span class="number">104</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.Main.runTaskClass(Main.java:<span class="number">262</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.Main.main(Main.java:<span class="number">115</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:<span class="number">240</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">jvm <span class="number">1</span>    | Caused by: java.io.IOException: Failed to bind to server socket: amqp://<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:<span class="number">5672</span>?maximumConnections=<span class="number">1000</span>&amp;wireFormat.maxFrameSize=<span class="number">104857600</span> due to: java.<span class="built_in">net</span>.BindException: Address already <span class="keyword">in</span> use: JVM_Bind</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:<span class="number">34</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:<span class="number">146</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.transport.tcp.TcpTransportFactory.doBind(TcpTransportFactory.java:<span class="number">62</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.transport.TransportFactorySupport.bind(TransportFactorySupport.java:<span class="number">40</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.TransportConnector.createTransportServer(TransportConnector.java:<span class="number">335</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.TransportConnector.getServer(TransportConnector.java:<span class="number">145</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.TransportConnector.asManagedConnector(TransportConnector.java:<span class="number">110</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:<span class="number">2283</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      ... <span class="number">46</span> <span class="built_in">more</span></span><br><span class="line">jvm <span class="number">1</span>    | Caused by: java.<span class="built_in">net</span>.BindException: Address already <span class="keyword">in</span> use: JVM_Bind</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.<span class="built_in">net</span>.DualStackPlainSocketImpl.bind0(Native Method)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.<span class="built_in">net</span>.DualStackPlainSocketImpl.socketBind(DualStackPlainSocketImpl.java:<span class="number">106</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.<span class="built_in">net</span>.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:<span class="number">387</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.<span class="built_in">net</span>.PlainSocketImpl.bind(PlainSocketImpl.java:<span class="number">190</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.<span class="built_in">net</span>.ServerSocket.bind(ServerSocket.java:<span class="number">375</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.<span class="built_in">net</span>.ServerSocket.&lt;init&gt;(ServerSocket.java:<span class="number">237</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> javax.<span class="built_in">net</span>.DefaultServerSocketFactory.createServerSocket(ServerSocketFactory.java:<span class="number">231</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:<span class="number">143</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      ... <span class="number">52</span> <span class="built_in">more</span></span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Apache ActiveMQ <span class="number">5</span>.<span class="number">16</span>.<span class="number">3</span> (localhost, ID:CZBK-<span class="number">20210302</span>VL-<span class="number">10257</span>-<span class="number">1646035577620</span>-<span class="number">0</span>:<span class="number">1</span>) is shutting down</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | socketQueue interrupted - stopping</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Connector openwire stopped</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Could <span class="keyword">not</span> accept connection during shutdown  : null (null)</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Connector amqp stopped</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Connector stomp stopped</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Connector mqtt stopped</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Connector ws stopped</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | PListStore:[D:\soft\activemq\bin\win64\..\..\data\localhost\tmp_storage] stopped</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Stopping async queue tasks</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Stopping async topic tasks</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Stopped KahaDB</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Apache ActiveMQ <span class="number">5</span>.<span class="number">16</span>.<span class="number">3</span> (localhost, ID:CZBK-<span class="number">20210302</span>VL-<span class="number">10257</span>-<span class="number">1646035577620</span>-<span class="number">0</span>:<span class="number">1</span>) uptime <span class="number">0</span>.<span class="number">426</span> seconds</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Apache ActiveMQ <span class="number">5</span>.<span class="number">16</span>.<span class="number">3</span> (localhost, ID:CZBK-<span class="number">20210302</span>VL-<span class="number">10257</span>-<span class="number">1646035577620</span>-<span class="number">0</span>:<span class="number">1</span>) is shutdown</span><br><span class="line">jvm <span class="number">1</span>    |  INFO | Closing org.apache.activemq.xbean.XBeanBrokerFactory$<span class="number">1</span>@<span class="number">2</span>c9392f5: startup <span class="built_in">date</span> [Mon Feb <span class="number">28</span> <span class="number">16</span>:<span class="number">06</span>:<span class="number">16</span> CST <span class="number">2022</span>]; root of context hierarchy</span><br><span class="line">jvm <span class="number">1</span>    |  WARN | Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;org.apache.activemq.xbean.XBeanBrokerService#<span class="number">0</span>&#x27; <span class="keyword">defined</span> <span class="keyword">in</span> class <span class="built_in">path</span> resource [activemq.xml]: Invocation of init method failed; nested exception is java.io.IOException: Transport Connector could <span class="keyword">not</span> be registered <span class="keyword">in</span> JMX: java.io.IOException: Failed to bind to server socket: amqp://<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:<span class="number">5672</span>?maximumConnections=<span class="number">1000</span>&amp;wireFormat.maxFrameSize=<span class="number">104857600</span> due to: java.<span class="built_in">net</span>.BindException: Address already <span class="keyword">in</span> use: JVM_Bind</span><br><span class="line">jvm <span class="number">1</span>    | ERROR: java.lang.RuntimeException: Failed to execute <span class="built_in">start</span> task. Reason: java.lang.IllegalStateException: BeanFactory <span class="keyword">not</span> initialized or already closed - <span class="keyword">call</span> &#x27;refresh&#x27; before accessing beans via the ApplicationContext</span><br><span class="line">jvm <span class="number">1</span>    | java.lang.RuntimeException: Failed to execute <span class="built_in">start</span> task. Reason: java.lang.IllegalStateException: BeanFactory <span class="keyword">not</span> initialized or already closed - <span class="keyword">call</span> &#x27;refresh&#x27; before accessing beans via the ApplicationContext</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:<span class="number">91</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:<span class="number">63</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:<span class="number">154</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:<span class="number">63</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:<span class="number">104</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.Main.runTaskClass(Main.java:<span class="number">262</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.Main.main(Main.java:<span class="number">115</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:<span class="number">240</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">jvm <span class="number">1</span>    | Caused by: java.lang.IllegalStateException: BeanFactory <span class="keyword">not</span> initialized or already closed - <span class="keyword">call</span> &#x27;refresh&#x27; before accessing beans via the ApplicationContext</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:<span class="number">164</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:<span class="number">1034</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">555</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:<span class="number">64</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:<span class="number">52</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.xbean.XBeanBrokerFactory$<span class="number">1</span>.&lt;init&gt;(XBeanBrokerFactory.java:<span class="number">104</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:<span class="number">104</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:<span class="number">67</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:<span class="number">71</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:<span class="number">54</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:<span class="number">87</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      ... <span class="number">16</span> <span class="built_in">more</span></span><br><span class="line">jvm <span class="number">1</span>    | ERROR: java.lang.IllegalStateException: BeanFactory <span class="keyword">not</span> initialized or already closed - <span class="keyword">call</span> &#x27;refresh&#x27; before accessing beans via the ApplicationContext</span><br><span class="line">jvm <span class="number">1</span>    | java.lang.IllegalStateException: BeanFactory <span class="keyword">not</span> initialized or already closed - <span class="keyword">call</span> &#x27;refresh&#x27; before accessing beans via the ApplicationContext</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:<span class="number">164</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:<span class="number">1034</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">555</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:<span class="number">64</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:<span class="number">52</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.xbean.XBeanBrokerFactory$<span class="number">1</span>.&lt;init&gt;(XBeanBrokerFactory.java:<span class="number">104</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:<span class="number">104</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:<span class="number">67</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:<span class="number">71</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:<span class="number">54</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:<span class="number">87</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:<span class="number">63</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:<span class="number">154</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:<span class="number">63</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:<span class="number">104</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.Main.runTaskClass(Main.java:<span class="number">262</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.apache.activemq.console.Main.main(Main.java:<span class="number">115</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:<span class="number">240</span>)</span><br><span class="line">jvm <span class="number">1</span>    |      <span class="built_in">at</span> java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">wrapper  | &lt;-- Wrapper Stopped</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>
<h5 id="整合-4"><a class="markdownIt-Anchor" href="#整合-4">#</a> 整合</h5>
<p>​		做了这么多 springboot 整合第三方技术，已经摸到门路了，加坐标，做配置，调接口，直接开工</p>
<p><strong>步骤①</strong>：导入 springboot 整合 ActiveMQ 的 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：配置 ActiveMQ 的服务器地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">activemq:</span></span><br><span class="line">    <span class="attr">broker-url:</span> <span class="string">tcp://localhost:61616</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：使用 JmsMessagingTemplate 操作 ActiveMQ</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceActivemqImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;待发送短信的订单已纳入处理队列，id：&quot;</span>+id);</span><br><span class="line">        messagingTemplate.convertAndSend(<span class="string">&quot;order.queue.id&quot;</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = messagingTemplate.receiveAndConvert(<span class="string">&quot;order.queue.id&quot;</span>,String.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;已完成短信发送业务，id：&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		发送消息需要先将消息的类型转换成字符串，然后再发送，所以是 convertAndSend，定义消息发送的位置，和具体的消息内容，此处使用 id 作为消息内容。</p>
<p>​		接收消息需要先将消息接收到，然后再转换成指定的数据类型，所以是 receiveAndConvert，接收消息除了提供读取的位置，还要给出转换后的数据的具体类型。</p>
<p><strong>步骤④</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;order.queue.id&quot;)</span></span><br><span class="line">    <span class="meta">@SendTo(&quot;order.other.queue.id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">receive</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已完成短信发送业务，id：&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;new:&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		使用注解 @JmsListener 定义当前方法监听 ActiveMQ 中指定名称的消息队列。</p>
<p>​		如果当前消息队列处理完还需要继续向下传递当前消息到另一个队列中使用注解 @SendTo 即可，这样即可构造连续执行的顺序消息队列。</p>
<p><strong>步骤⑤</strong>：切换消息模型由点对点模型到发布订阅模型，修改 jms 配置即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">activemq:</span></span><br><span class="line">    <span class="attr">broker-url:</span> <span class="string">tcp://localhost:61616</span></span><br><span class="line">  <span class="attr">jms:</span></span><br><span class="line">    <span class="attr">pub-sub-domain:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>​		pub-sub-domain 默认值为 false，即点对点模型，修改为 true 后就是发布订阅模型。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 整合 ActiveMQ 提供了 JmsMessagingTemplate 对象作为客户端操作消息队列</li>
<li>操作 ActiveMQ 需要配置 ActiveMQ 服务器地址，默认端口 61616</li>
<li>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解 @JmsListener</li>
<li>配置 jms 的 pub-sub-domain 属性可以在点对点模型和发布订阅模型间切换消息模型</li>
</ol>
<h4 id="springboot整合rabbitmq"><a class="markdownIt-Anchor" href="#springboot整合rabbitmq">#</a> SpringBoot 整合 RabbitMQ</h4>
<p>​		RabbitMQ 是 MQ 产品中的目前较为流行的产品之一，它遵从 AMQP 协议。RabbitMQ 的底层实现语言使用的是 Erlang，所以安装 RabbitMQ 需要先安装 Erlang。</p>
<p><strong>Erlang 安装</strong></p>
<p>​		windows 版安装包下载地址：<a href="https://www.erlang.org/downloads">https</a><a href="https://www.erlang.org/downloads">😕/www.erlang.org/downloads</a></p>
<p>​		下载完毕后得到 exe 安装文件，一键傻瓜式安装，安装完毕需要重启，需要重启，需要重启。</p>
<p>​		安装的过程中可能会出现依赖 Windows 组件的提示，根据提示下载安装即可，都是自动执行的，如下：</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228164851551.png" alt="image-20220228164851551"></p>
<p>​		Erlang 安装后需要配置环境变量，否则 RabbitMQ 将无法找到安装的 Erlang。需要配置项如下，作用等同 JDK 配置环境变量的作用。</p>
<ul>
<li>ERLANG_HOME</li>
<li>PATH</li>
</ul>
<h5 id="安装-5"><a class="markdownIt-Anchor" href="#安装-5">#</a> 安装</h5>
<p>​		windows 版安装包下载地址：<a href="https://rabbitmq.com/install-windows.html">https://</a><a href="https://rabbitmq.com/install-windows.html">rabbitmq.com/install-windows.html</a></p>
<p>​		下载完毕后得到 exe 安装文件，一键傻瓜式安装，安装完毕后会得到如下文件</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228165151524.png" alt="image-20220228165151524" style="zoom:67%;">
<p><strong>启动服务器</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">rabbitmq-service.bat <span class="built_in">start</span>		# 启动服务</span><br><span class="line">rabbitmq-service.bat stop		# 停止服务</span><br><span class="line">rabbitmqctl status				# 查看服务状态</span><br></pre></td></tr></table></figure>
<p>​		运行 sbin 目录下的 rabbitmq-service.bat 命令即可，start 参数表示启动，stop 参数表示退出，默认对外服务端口 5672。</p>
<p>​		注意：启动 rabbitmq 的过程实际上是开启 rabbitmq 对应的系统服务，需要管理员权限方可执行。</p>
<p>​		说明：有没有感觉 5672 的服务端口很熟悉？activemq 与 rabbitmq 有一个端口冲突问题，学习阶段无论操作哪一个？请确保另一个处于关闭状态。</p>
<p>​		说明：不喜欢命令行的小伙伴可以使用任务管理器中的服务页，找到 RabbitMQ 服务，使用鼠标右键菜单控制服务的启停。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228170147193.png" alt="image-20220228170147193" style="zoom:67%;">
<p><strong>访问 web 管理服务</strong></p>
<p>​		RabbitMQ 也提供有 web 控制台服务，但是此功能是一个插件，需要先启用才可以使用。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins.bat list							# 查看当前所有插件的运行状态</span><br><span class="line">rabbitmq-plugins.bat enable rabbitmq_management		# 启动rabbitmq_management插件</span><br></pre></td></tr></table></figure>
<p>​		启动插件后可以在插件运行状态中查看是否运行，运行后通过浏览器即可打开服务后台管理界面</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">http://<span class="title">localhost</span>:15672</span></span><br></pre></td></tr></table></figure>
<p>​		web 管理服务默认端口 15672，访问后可以打开 RabbitMQ 的管理界面，如下：</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228170504793.png" alt="image-20220228170504793"></p>
<p>​		首先输入访问用户名和密码，初始化用户名和密码相同，均为：guest，成功登录后进入管理后台界面，如下：</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228170535261.png" alt="image-20220228170535261"></p>
<h5 id="整合direct模型"><a class="markdownIt-Anchor" href="#整合direct模型">#</a> 整合 (direct 模型)</h5>
<p>​		RabbitMQ 满足 AMQP 协议，因此不同的消息模型对应的制作不同，先使用最简单的 direct 模型开发。</p>
<p><strong>步骤①</strong>：导入 springboot 整合 amqp 的 starter，amqp 协议默认实现为 rabbitmq 方案</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：配置 RabbitMQ 的服务器地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：初始化直连模式系统设置</p>
<p>​		由于 RabbitMQ 不同模型要使用不同的交换机，因此需要先初始化 RabbitMQ 相关的对象，例如队列，交换机等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfigDirect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">directQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;direct_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">directQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;direct_queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">directExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;directExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue()).to(directExchange()).with(<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2()).to(directExchange()).with(<span class="string">&quot;direct2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		队列 Queue 与直连交换机 DirectExchange 创建后，还需要绑定他们之间的关系 Binding，这样就可以通过交换机操作对应队列。</p>
<p><strong>步骤④</strong>：使用 AmqpTemplate 操作 RabbitMQ</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceRabbitmqDirectImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;待发送短信的订单已纳入处理队列（rabbitmq direct），id：&quot;</span>+id);</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;directExchange&quot;</span>,<span class="string">&quot;direct&quot;</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		amqp 协议中的操作 API 接口名称看上去和 jms 规范的操作 API 接口很相似，但是传递参数差异很大。</p>
<p><strong>步骤⑤</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;direct_queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已完成短信发送业务(rabbitmq direct)，id：&quot;</span>+id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		使用注解 @RabbitListener 定义当前方法监听 RabbitMQ 中指定名称的消息队列。</p>
<h5 id="整合topic模型"><a class="markdownIt-Anchor" href="#整合topic模型">#</a> 整合 (topic 模型)</h5>
<p><strong>步骤①</strong>：同上</p>
<p><strong>步骤②</strong>：同上</p>
<p><strong>步骤③</strong>：初始化主题模式系统设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfigTopic</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topic_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topic_queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topicExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">&quot;topicExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingTopic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue()).to(topicExchange()).with(<span class="string">&quot;topic.*.id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingTopic2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(<span class="string">&quot;topic.orders.*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		主题模式支持 routingKey 匹配模式，* 表示匹配一个单词，# 表示匹配任意内容，这样就可以通过主题交换机将消息分发到不同的队列中，详细内容请参看 RabbitMQ 系列课程。</p>
<table>
<thead>
<tr>
<th><strong>匹配键</strong></th>
<th><strong>topic.*.*</strong></th>
<th><strong>topic.#</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://topic.order.id">topic.order.id</a></td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td><a href="http://order.topic.id">order.topic.id</a></td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td><a href="http://topic.sm.order.id">topic.sm.order.id</a></td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td><a href="http://topic.sm.id">topic.sm.id</a></td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>topic.id.order</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td><a href="http://topic.id">topic.id</a></td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>topic.order</td>
<td>false</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><strong>步骤④</strong>：使用 AmqpTemplate 操作 RabbitMQ</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceRabbitmqTopicImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;待发送短信的订单已纳入处理队列（rabbitmq topic），id：&quot;</span>+id);</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;topicExchange&quot;</span>,<span class="string">&quot;topic.orders.id&quot;</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		发送消息后，根据当前提供的 routingKey 与绑定交换机时设定的 routingKey 进行匹配，规则匹配成功消息才会进入到对应的队列中。</p>
<p><strong>步骤⑤</strong>：使用消息监听器在服务器启动后，监听指定队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;topic_queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已完成短信发送业务(rabbitmq topic 1)，id：&quot;</span>+id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;topic_queue2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已完成短信发送业务(rabbitmq topic 22222222)，id：&quot;</span>+id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		使用注解 @RabbitListener 定义当前方法监听 RabbitMQ 中指定名称的消息队列。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 整合 RabbitMQ 提供了 AmqpTemplate 对象作为客户端操作消息队列</li>
<li>操作 ActiveMQ 需要配置 ActiveMQ 服务器地址，默认端口 5672</li>
<li>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解 @RabbitListener</li>
<li>RabbitMQ 有 5 种消息模型，使用的队列相同，但是交换机不同。交换机不同，对应的消息进入的策略也不同</li>
</ol>
<h4 id="springboot整合rocketmq"><a class="markdownIt-Anchor" href="#springboot整合rocketmq">#</a> SpringBoot 整合 RocketMQ</h4>
<p>​		RocketMQ 由阿里研发，后捐赠给 apache 基金会，目前是 apache 基金会顶级项目之一，也是目前市面上的 MQ 产品中较为流行的产品之一，它遵从 AMQP 协议。</p>
<h5 id="安装-6"><a class="markdownIt-Anchor" href="#安装-6">#</a> 安装</h5>
<p>​		windows 版安装包下载地址：<a href="https://rocketmq.apache.org/">https://rocketmq.apache.org</a><a href="https://rocketmq.apache.org/">/</a></p>
<p>​		下载完毕后得到 zip 压缩文件，解压缩即可使用，解压后得到如下文件</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228174453471.png" alt="image-20220228174453471"></p>
<p>​		RocketMQ 安装后需要配置环境变量，具体如下：</p>
<ul>
<li>ROCKETMQ_HOME</li>
<li>PATH</li>
<li>NAMESRV_ADDR （建议）： 127.0.0.1:9876</li>
</ul>
<p>​		关于 NAMESRV_ADDR 对于初学者来说建议配置此项，也可以通过命令设置对应值，操作略显繁琐，建议配置。系统学习 RocketMQ 知识后即可灵活控制该项。</p>
<p><strong>RocketMQ 工作模式</strong></p>
<p>​		在 RocketMQ 中，处理业务的服务器称为 broker，生产者与消费者不是直接与 broker 联系的，而是通过命名服务器进行通信。broker 启动后会通知命名服务器自己已经上线，这样命名服务器中就保存有所有的 broker 信息。当生产者与消费者需要连接 broker 时，通过命名服务器找到对应的处理业务的 broker，因此命名服务器在整套结构中起到一个信息中心的作用。并且 broker 启动前必须保障命名服务器先启动。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228175123790.png" alt="image-20220228175123790" style="zoom:80%;">
<p><strong>启动服务器</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mqnamesrv		# 启动命名服务器</span><br><span class="line">mqbroker		# 启动broker</span><br></pre></td></tr></table></figure>
<p>​		运行 bin 目录下的 mqnamesrv 命令即可启动命名服务器，默认对外服务端口 9876。</p>
<p>​		运行 bin 目录下的 mqbroker 命令即可启动 broker 服务器，如果环境变量中没有设置 NAMESRV_ADDR 则需要在运行 mqbroker 指令前通过 set 指令设置 NAMESRV_ADDR 的值，并且每次开启均需要设置此项。</p>
<p><strong>测试服务器启动状态</strong></p>
<p>​		RocketMQ 提供有一套测试服务器功能的测试程序，运行 bin 目录下的 tools 命令即可使用。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">tools org.apache.rocketmq.example.quickstart.Producer		# 生产消息</span><br><span class="line">tools org.apache.rocketmq.example.quickstart.Consumer		# 消费消息</span><br></pre></td></tr></table></figure>
<h5 id="整合异步消息"><a class="markdownIt-Anchor" href="#整合异步消息">#</a> 整合（异步消息）</h5>
<p><strong>步骤①</strong>：导入 springboot 整合 RocketMQ 的 starter，此坐标不由 springboot 维护版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：配置 RocketMQ 的服务器地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="string">localhost:9876</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">group_rocketmq</span></span><br></pre></td></tr></table></figure>
<p>​		设置默认的生产者消费者所属组 group。</p>
<p><strong>步骤③</strong>：使用 RocketMQTemplate 操作 RocketMQ</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceRocketmqImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;待发送短信的订单已纳入处理队列（rocketmq），id：&quot;</span>+id);</span><br><span class="line">        SendCallback callback = <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送失败！！！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;order_id&quot;</span>,id,callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​		使用 asyncSend 方法发送异步消息。</p>
<p><strong>步骤④</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;order_id&quot;,consumerGroup = &quot;group_rocketmq&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListener</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已完成短信发送业务(rocketmq)，id：&quot;</span>+id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		RocketMQ 的监听器必须按照标准格式开发，实现 RocketMQListener 接口，泛型为消息类型。</p>
<p>​		使用注解 @RocketMQMessageListener 定义当前类监听 RabbitMQ 中指定组、指定名称的消息队列。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 整合 RocketMQ 使用 RocketMQTemplate 对象作为客户端操作消息队列</li>
<li>操作 RocketMQ 需要配置 RocketMQ 服务器地址，默认端口 9876</li>
<li>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解 @RocketMQMessageListener</li>
</ol>
<h4 id="springboot整合kafka"><a class="markdownIt-Anchor" href="#springboot整合kafka">#</a> SpringBoot 整合 Kafka</h4>
<h5 id="安装-7"><a class="markdownIt-Anchor" href="#安装-7">#</a> 安装</h5>
<p>​		windows 版安装包下载地址：<a href="https://kafka.apache.org/downloads">https://</a><a href="https://kafka.apache.org/downloads">kafka.apache.org/downloads</a></p>
<p>​		下载完毕后得到 tgz 压缩文件，使用解压缩软件解压缩即可使用，解压后得到如下文件</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220228181442155.png" alt="image-20220228181442155"></p>
<p>​		建议使用 windows 版 2.8.1 版本。</p>
<p><strong>启动服务器</strong></p>
<p>​		kafka 服务器的功能相当于 RocketMQ 中的 broker，kafka 运行还需要一个类似于命名服务器的服务。在 kafka 安装目录中自带一个类似于命名服务器的工具，叫做 zookeeper，它的作用是注册中心，相关知识请到对应课程中学习。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zookeeper-server-<span class="built_in">start</span>.bat ..\..\config\zookeeper.properties		# 启动zookeeper</span><br><span class="line">kafka-server-<span class="built_in">start</span>.bat ..\..\config\server.properties				# 启动kafka</span><br></pre></td></tr></table></figure>
<p>​		运行 bin 目录下的 windows 目录下的 zookeeper-server-start 命令即可启动注册中心，默认对外服务端口 2181。</p>
<p>​		运行 bin 目录下的 windows 目录下的 kafka-server-start 命令即可启动 kafka 服务器，默认对外服务端口 9092。</p>
<p><strong>创建主题</strong></p>
<p>​		和之前操作其他 MQ 产品相似，kakfa 也是基于主题操作，操作之前需要先初始化 topic。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 创建topic</span><br><span class="line">kafka-topics.bat --create --zookeeper localhost:<span class="number">2181</span> --replication-factor <span class="number">1</span> --partitions <span class="number">1</span> --topic itheima</span><br><span class="line"># 查询topic</span><br><span class="line">kafka-topics.bat --zookeeper <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">2181</span> --list					</span><br><span class="line"># 删除topic</span><br><span class="line">kafka-topics.bat --delete --zookeeper localhost:<span class="number">2181</span> --topic itheima</span><br></pre></td></tr></table></figure>
<p><strong>测试服务器启动状态</strong></p>
<p>​		Kafka 提供有一套测试服务器功能的测试程序，运行 bin 目录下的 windows 目录下的命令即可使用。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">kafka-console-producer.bat --broker-list localhost:<span class="number">9092</span> --topic itheima							# 测试生产消息</span><br><span class="line">kafka-console-consumer.bat --bootstrap-server localhost:<span class="number">9092</span> --topic itheima --from-beginning	# 测试消息消费</span><br></pre></td></tr></table></figure>
<h5 id="整合-5"><a class="markdownIt-Anchor" href="#整合-5">#</a> 整合</h5>
<p><strong>步骤①</strong>：导入 springboot 整合 Kafka 的 starter，此坐标由 springboot 维护版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：配置 Kafka 的服务器地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="string">localhost:9092</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">group-id:</span> <span class="string">order</span></span><br></pre></td></tr></table></figure>
<p>​		设置默认的生产者消费者所属组 id。</p>
<p><strong>步骤③</strong>：使用 KafkaTemplate 操作 Kafka</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceKafkaImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String,String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;待发送短信的订单已纳入处理队列（kafka），id：&quot;</span>+id);</span><br><span class="line">        kafkaTemplate.send(<span class="string">&quot;itheima2022&quot;</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		使用 send 方法发送消息，需要传入 topic 名称。</p>
<p><strong>步骤④</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;itheima2022&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(ConsumerRecord&lt;String,String&gt; record)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已完成短信发送业务(kafka)，id：&quot;</span>+record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		使用注解 @KafkaListener 定义当前方法监听 Kafka 中指定 topic 的消息，接收到的消息封装在对象 ConsumerRecord 中，获取数据从 ConsumerRecord 对象中获取即可。</p>
<p><strong>总结</strong></p>
<ol>
<li>
<p>springboot 整合 Kafka 使用 KafkaTemplate 对象作为客户端操作消息队列</p>
</li>
<li>
<p>操作 Kafka 需要配置 Kafka 服务器地址，默认端口 9092</p>
</li>
<li>
<p>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解 @KafkaListener。接收消息保存在形参 ConsumerRecord 对象中</p>
</li>
</ol>
<h2 id="kf-6监控"><a class="markdownIt-Anchor" href="#kf-6监控">#</a> KF-6. 监控</h2>
<p>​		在说监控之前，需要回顾一下软件业的发展史。最早的软件完成一些非常简单的功能，代码不多，错误也少。随着软件功能的逐步完善，软件的功能变得越来越复杂，功能不能得到有效的保障，这个阶段出现了针对软件功能的检测，也就是软件测试。伴随着计算机操作系统的逐步升级，软件的运行状态也变得开始让人捉摸不透，出现了不稳定的状况。伴随着计算机网络的发展，程序也从单机状态切换成基于计算机网络的程序，应用于网络的程序开始出现，由于网络的不稳定性，程序的运行状态让使用者更加堪忧。互联网的出现彻底打破了软件的思维模式，随之而来的互联网软件就更加凸显出应对各种各样复杂的网络情况之下的弱小。计算机软件的运行状况已经成为了软件运行的一个大话题，针对软件的运行状况就出现了全新的思维，建立起了初代的软件运行状态监控。</p>
<p>​		什么是监控？就是通过软件的方式展示另一个软件的运行情况，运行的情况则通过各种各样的指标数据反馈给监控人员。例如网络是否顺畅、服务器是否在运行、程序的功能是否能够整百分百运行成功，内存是否够用，等等等等。</p>
<p>​		本章要讲解的监控就是对软件的运行情况进行监督，但是 springboot 程序与非 springboot 程序的差异还是很大的，为了方便监控软件的开发，springboot 提供了一套功能接口，为开发者加速开发过程。</p>
<h3 id="kf-6-1监控的意义"><a class="markdownIt-Anchor" href="#kf-6-1监控的意义">#</a> KF-6-1. 监控的意义</h3>
<p>​		对于现代的互联网程序来说，规模越来越大，功能越来越复杂，还要追求更好的客户体验，因此要监控的信息量也就比较大了。由于现在的互联网程序大部分都是基于微服务的程序，一个程序的运行需要若干个服务来保障，因此第一个要监控的指标就是服务是否正常运行，也就是<strong>监控服务状态是否处理宕机状态</strong>。一旦发现某个服务宕机了，必须马上给出对应的解决方案，避免整体应用功能受影响。其次，由于互联网程序服务的客户量是巨大的，当客户的请求在短时间内集中达到服务器后，就会出现各种程序运行指标的波动。比如内存占用严重，请求无法及时响应处理等，这就是第二个要监控的重要指标，<strong>监控服务运行指标</strong>。虽然软件是对外提供用户的访问需求，完成对应功能的，但是后台的运行是否平稳，是否出现了不影响客户使用的功能隐患，这些也是要密切监控的，此时就需要在不停机的情况下，监控系统运行情况，日志是一个不错的手段。如果在众多日志中找到开发者或运维人员所关注的日志信息，简单快速有效的过滤出要看的日志也是监控系统需要考虑的问题，这就是第三个要监控的指标，<strong>监控程序运行日志</strong>。虽然我们期望程序一直平稳运行，但是由于突发情况的出现，例如服务器被攻击、服务器内存溢出等情况造成了服务器宕机，此时当前服务不能满足使用需要，就要将其重启甚至关闭，如果快速控制服务器的启停也是程序运行过程中不可回避的问题，这就是第四个监控项，<strong>管理服务状态</strong>。以上这些仅仅是从大的方面来思考监控这个问题，还有很多的细节点，例如上线了一个新功能，定时提醒用户续费，这种功能不是上线后马上就运行的，但是当前功能是否真的启动，如果快速的查询到这个功能已经开启，这也是监控中要解决的问题，等等。看来监控真的是一项非常重要的工作。</p>
<p>​		通过上述描述，可以看出监控很重要。那具体的监控要如何开展呢？还要从实际的程序运行角度出发。比如现在有 3 个服务支撑着一个程序的运行，每个服务都有自己的运行状态。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301093704396.png" alt="image-20220301093704396" style="zoom:50%;">
<p>​		此时被监控的信息就要在三个不同的程序中去查询并展示，但是三个服务是服务于一个程序的运行的，如果不能合并到一个平台上展示，监控工作量巨大，而且信息对称性差，要不停的在三个监控端查看数据。如果将业务放大成 30 个，300 个，3000 个呢？看来必须有一个单独的平台，将多个被监控的服务对应的监控指标信息汇总在一起，这样更利于监控工作的开展。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301094001896.png" alt="image-20220301094001896" style="zoom:50%;">
<p>​		新的程序专门用来监控，新的问题就出现了，是被监控程序主动上报信息还是监控程序主动获取信息？如果监控程序不能主动获取信息，这就意味着监控程序有可能看到的是很久之前被监控程序上报的信息，万一被监控程序宕机了，监控程序就无法区分究竟是好久没法信息了，还是已经下线了。所以监控程序必须具有主动发起请求获取被监控服务信息的能力。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301094259844.png" alt="image-20220301094259844" style="zoom:50%;">
<p>​		如果监控程序要监控服务时，主动获取对方的信息。那监控程序如何知道哪些程序被自己监控呢？不可能在监控程序中设置我监控谁，这样互联网上的所有程序岂不是都可以被监控到，这样的话信息安全将无法得到保障。合理的做法只能是在被监控程序启动时上报监控程序，告诉监控程序你可以监控我了。看来需要在被监控程序端做主动上报的操作，这就要求被监控程序中配置对应的监控程序是谁。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301094547748.png" alt="image-20220301094547748" style="zoom:50%;">
<p>​		被监控程序可以提供各种各样的指标数据给监控程序看，但是每一个指标都代表着公司的机密信息，并不是所有的指标都可以给任何人看的，乃至运维人员，所以对被监控指标的是否开放出来给监控系统看，也需要做详细的设定。</p>
<p>​		以上描述的整个过程就是一个监控系统的基本流程。</p>
<p><strong>总结</strong></p>
<ol>
<li>监控是一个非常重要的工作，是保障程序正常运行的基础手段</li>
<li>监控的过程通过一个监控程序进行，它汇总所有被监控的程序的信息集中统一展示</li>
<li>被监控程序需要主动上报自己被监控，同时要设置哪些指标被监控</li>
</ol>
<p><strong>思考</strong></p>
<p>​		下面就要开始做监控了，新的问题就来了，监控程序怎么做呢？难道要自己写吗？肯定是不现实的，如何进行监控，咱们下节再讲。</p>
<h3 id="kf-6-2可视化监控平台"><a class="markdownIt-Anchor" href="#kf-6-2可视化监控平台">#</a> KF-6-2. 可视化监控平台</h3>
<p>​		springboot 抽取了大部分监控系统的常用指标，提出了监控的总思想。然后就有好心的同志根据监控的总思想，制作了一个通用性很强的监控系统，因为是基于 springboot 监控的核心思想制作的，所以这个程序被命名为<strong> Spring Boot Admin</strong>。</p>
<p>​		Spring Boot Admin，这是一个开源社区项目，用于管理和监控 SpringBoot 应用程序。这个项目中包含有客户端和服务端两部分，而监控平台指的就是服务端。我们做的程序如果需要被监控，将我们做的程序制作成客户端，然后配置服务端地址后，服务端就可以通过 HTTP 请求的方式从客户端获取对应的信息，并通过 UI 界面展示对应信息。</p>
<p>​		下面就来开发这套监控程序，先制作服务端，其实服务端可以理解为是一个 web 程序，收到一些信息后展示这些信息。</p>
<p><strong>服务端开发</strong></p>
<p><strong>步骤①</strong>：导入 springboot admin 对应的 starter，版本与当前使用的 springboot 版本保持一致，并将其配置成 web 工程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		上述过程可以通过创建项目时使用勾选的形式完成。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301102432817.png" alt="image-20220301102432817" style="zoom:50%;">
<p><strong>步骤②</strong>：在引导类上添加注解 @EnableAdminServer，声明当前应用启动后作为 SpringBootAdmin 的服务器使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot25AdminServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springboot25AdminServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		做到这里，这个服务器就开发好了，启动后就可以访问当前程序了，界面如下。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301103028468.png" alt="image-20220301103028468" style="zoom: 50%;">
<p>​		由于目前没有启动任何被监控的程序，所以里面什么信息都没有。下面制作一个被监控的客户端程序。</p>
<p><strong>客户端开发</strong></p>
<p>​		客户端程序开发其实和服务端开发思路基本相似，多了一些配置而已。</p>
<p><strong>步骤①</strong>：导入 springboot admin 对应的 starter，版本与当前使用的 springboot 版本保持一致，并将其配置成 web 工程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		上述过程也可以通过创建项目时使用勾选的形式完成，不过一定要小心，端口配置成不一样的，否则会冲突。</p>
<p><strong>步骤②</strong>：设置当前客户端将信息上传到哪个服务器上，通过 yml 文件配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://localhost:8080</span></span><br></pre></td></tr></table></figure>
<p>​		做到这里，这个客户端就可以启动了。启动后再次访问服务端程序，界面如下。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301103838079.png" alt="image-20220301103838079" style="zoom: 50%;">
<p>​		可以看到，当前监控了 1 个程序，点击进去查看详细信息。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301103936386.png" alt="image-20220301103936386" style="zoom: 50%;">
<p>​		由于当前没有设置开放哪些信息给监控服务器，所以目前看不到什么有效的信息。下面需要做两组配置就可以看到信息了。</p>
<ol>
<li>
<p>开放指定信息给服务器看</p>
</li>
<li>
<p>允许服务器以 HTTP 请求的方式获取对应的信息</p>
<p>配置如下：</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://localhost:8080</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
<p>​		上述配置对于初学者来说比较容易混淆。简单解释一下，到下一节再做具体的讲解。springbootadmin 的客户端默认开放了 13 组信息给服务器，但是这些信息除了一个之外，其他的信息都不让通过 HTTP 请求查看。所以你看到的信息基本上就没什么内容了，只能看到一个内容，就是下面的健康信息。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301104742563.png" alt="image-20220301104742563" style="zoom: 50%;">
<p>​		但是即便如此我们看到健康信息中也没什么内容，原因在于健康信息中有一些信息描述了你当前应用使用了什么技术等信息，如果无脑的对外暴露功能会有安全隐患。通过配置就可以开放所有的健康信息明细查看了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>
<p>​		健康明细信息如下：</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301105116554.png" alt="image-20220301105116554" style="zoom: 50%;">
<p>​		目前除了健康信息，其他信息都查阅不了。原因在于其他 12 种信息是默认不提供给服务器通过 HTTP 请求查阅的，所以需要开启查阅的内容项，使用 * 表示查阅全部。记得带引号。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">endpoints:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">exposure:</span></span><br><span class="line">      <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
<p>​		配置后再刷新服务器页面，就可以看到所有的信息了。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301105554494.png" alt="image-20220301105554494" style="zoom: 50%;">
<p>​		以上界面中展示的信息量就非常大了，包含了 13 组信息，有性能指标监控，加载的 bean 列表，加载的系统属性，日志的显示控制等等。</p>
<p><strong>配置多个客户端</strong></p>
<p>​		可以通过配置客户端的方式在其他的 springboot 程序中添加客户端坐标，这样当前服务器就可以监控多个客户端程序了。每个客户端展示不同的监控信息。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301110352170.png" alt="image-20220301110352170" style="zoom: 50%;">
<p>​		进入监控面板，如果你加载的应用具有功能，在监控面板中可以看到 3 组信息展示的与之前加载的空工程不一样。</p>
<ul>
<li>类加载面板中可以查阅到开发者自定义的类，如左图</li>
</ul>
<p>​                        <img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301161246835.png" alt="image-20220301161246835" style="zoom:33%;"><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301161949431.png" alt="image-20220301161949431" style="zoom:33%;"></p>
<ul>
<li>映射中可以查阅到当前应用配置的所有请求</li>
</ul>
<p>​                        <img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301161418791.png" alt="image-20220301161418791" style="zoom: 33%;"><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301162008737.png" alt="image-20220301162008737" style="zoom:33%;"></p>
<ul>
<li>性能指标中可以查阅当前应用独有的请求路径统计数据</li>
</ul>
<p>​                        <img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301161906949.png" alt="image-20220301161906949" style="zoom: 33%;"><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301162040670.png" alt="image-20220301162040670" style="zoom: 33%;"></p>
<p><strong>总结</strong></p>
<ol>
<li>开发监控服务端需要导入坐标，然后在引导类上添加注解 @EnableAdminServer，并将其配置成 web 程序即可</li>
<li>开发被监控的客户端需要导入坐标，然后配置服务端服务器地址，并做开放指标的设定即可</li>
<li>在监控平台中可以查阅到各种各样被监控的指标，前提是客户端开放了被监控的指标</li>
</ol>
<p><strong>思考</strong></p>
<p>​		之前说过，服务端要想监控客户端，需要主动的获取到对应信息并展示出来。但是目前我们并没有在客户端开发任何新的功能，但是服务端确可以获取监控信息，谁帮我们做的这些功能呢？咱们下一节再讲。</p>
<h3 id="kf-6-3监控原理"><a class="markdownIt-Anchor" href="#kf-6-3监控原理">#</a> KF-6-3. 监控原理</h3>
<p>​		通过查阅监控中的映射指标，可以看到当前系统中可以运行的所有请求路径，其中大部分路径以 /actuator 开头</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301170214076.png" alt="image-20220301170214076" style="zoom: 50%;">
<p>​		首先这些请求路径不是开发者自己编写的，其次这个路径代表什么含义呢？既然这个路径可以访问，就可以通过浏览器发送该请求看看究竟可以得到什么信息。</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301170723057.png" alt="image-20220301170723057"></p>
<p>​		通过发送请求，可以得到一组 json 信息，如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_links&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;self&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;beans&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/beans&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;caches-cache&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/caches/&#123;cache&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;caches&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/caches&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;health&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/health&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;health-path&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/health/&#123;*path&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;info&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/info&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;conditions&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/conditions&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;shutdown&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/shutdown&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;configprops&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/configprops&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;configprops-prefix&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/configprops/&#123;prefix&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;env&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/env&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;env-toMatch&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/env/&#123;toMatch&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;loggers&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/loggers&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;loggers-name&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/loggers/&#123;name&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;heapdump&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/heapdump&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;threaddump&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/threaddump&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;metrics-requiredMetricName&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/metrics/&#123;requiredMetricName&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;metrics&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/metrics&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;scheduledtasks&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/scheduledtasks&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;href&quot;</span>: <span class="string">&quot;http://localhost:81/actuator/mappings&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;templated&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其中每一组数据都有一个请求路径，而在这里请求路径中有之前看到过的 health，发送此请求又得到了一组信息</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;components&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;diskSpace&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;details&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;total&quot;</span>: <span class="number">297042808832</span>,</span><br><span class="line">                <span class="attr">&quot;free&quot;</span>: <span class="number">72284409856</span>,</span><br><span class="line">                <span class="attr">&quot;threshold&quot;</span>: <span class="number">10485760</span>,</span><br><span class="line">                <span class="attr">&quot;exists&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;ping&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		当前信息与监控面板中的数据存在着对应关系</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301171025615.png" alt="image-20220301171025615" style="zoom:50%;">
<p>​		原来监控中显示的信息实际上是通过发送请求后得到 json 数据，然后展示出来。按照上述操作，可以发送更多的以 /actuator 开头的链接地址，获取更多的数据，这些数据汇总到一起组成了监控平台显示的所有数据。</p>
<p>​		到这里我们得到了一个核心信息，监控平台中显示的信息实际上是通过对被监控的应用发送请求得到的。那这些请求谁开发的呢？打开被监控应用的 pom 文件，其中导入了 springboot admin 的对应的 client，在这个资源中导入了一个名称叫做 actuator 的包。被监控的应用之所以可以对外提供上述请求路径，就是因为添加了这个包。</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301171437817.png" alt="image-20220301171437817"></p>
<p>​		这个 actuator 是什么呢？这就是本节要讲的核心内容，监控的端点。</p>
<p>​		Actuator，可以称为端点，描述了一组监控信息，SpringBootAdmin 提供了多个内置端点，通过访问端点就可以获取对应的监控信息，也可以根据需要自定义端点信息。通过发送请求路劲 **/actuator<strong> 可以访问应用所有端点信息，如果端点中还有明细信息可以发送请求</strong> /actuator/ 端点名称 ** 来获取详细信息。以下列出了所有端点信息说明：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
<th>默认启用</th>
</tr>
</thead>
<tbody>
<tr>
<td>auditevents</td>
<td>暴露当前应用程序的审计事件信息。</td>
<td>是</td>
</tr>
<tr>
<td>beans</td>
<td>显示应用程序中所有 Spring bean 的完整列表。</td>
<td>是</td>
</tr>
<tr>
<td>caches</td>
<td>暴露可用的缓存。</td>
<td>是</td>
</tr>
<tr>
<td>conditions</td>
<td>显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。</td>
<td>是</td>
</tr>
<tr>
<td>configprops</td>
<td>显示所有 @ConfigurationProperties 的校对清单。</td>
<td>是</td>
</tr>
<tr>
<td>env</td>
<td>暴露 Spring ConfigurableEnvironment 中的属性。</td>
<td>是</td>
</tr>
<tr>
<td>flyway</td>
<td>显示已应用的 Flyway 数据库迁移。</td>
<td>是</td>
</tr>
<tr>
<td>health</td>
<td>显示应用程序健康信息</td>
<td>是</td>
</tr>
<tr>
<td>httptrace</td>
<td>显示 HTTP 追踪信息（默认情况下，最后 100 个  HTTP 请求 / 响应交换）。</td>
<td>是</td>
</tr>
<tr>
<td>info</td>
<td>显示应用程序信息。</td>
<td>是</td>
</tr>
<tr>
<td>integrationgraph</td>
<td>显示 Spring Integration 图。</td>
<td>是</td>
</tr>
<tr>
<td>loggers</td>
<td>显示和修改应用程序中日志记录器的配置。</td>
<td>是</td>
</tr>
<tr>
<td>liquibase</td>
<td>显示已应用的 Liquibase 数据库迁移。</td>
<td>是</td>
</tr>
<tr>
<td>metrics</td>
<td>显示当前应用程序的指标度量信息。</td>
<td>是</td>
</tr>
<tr>
<td>mappings</td>
<td>显示所有 @RequestMapping 路径的整理清单。</td>
<td>是</td>
</tr>
<tr>
<td>scheduledtasks</td>
<td>显示应用程序中的调度任务。</td>
<td>是</td>
</tr>
<tr>
<td>sessions</td>
<td>允许从 Spring Session 支持的会话存储中检索和删除用户会话。当使用 Spring Session 的响应式 Web 应用程序支持时不可用。</td>
<td>是</td>
</tr>
<tr>
<td>shutdown</td>
<td>正常关闭应用程序。</td>
<td>否</td>
</tr>
<tr>
<td>threaddump</td>
<td>执行线程 dump。</td>
<td>是</td>
</tr>
<tr>
<td>heapdump</td>
<td>返回一个 hprof 堆 dump 文件。</td>
<td>是</td>
</tr>
<tr>
<td>jolokia</td>
<td>通过 HTTP 暴露 JMX bean（当  Jolokia 在 classpath 上时，不适用于 WebFlux）。</td>
<td>是</td>
</tr>
<tr>
<td>logfile</td>
<td>返回日志文件的内容（如果已设置 logging.file 或 logging.path 属性）。支持使用 HTTP Range 头来检索部分日志文件的内容。</td>
<td>是</td>
</tr>
<tr>
<td>prometheus</td>
<td>以可以由 Prometheus 服务器抓取的格式暴露指标。</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>​		上述端点每一项代表被监控的指标，如果对外开放则监控平台可以查询到对应的端点信息，如果未开放则无法查询对应的端点信息。通过配置可以设置端点是否对外开放功能。使用 enable 属性控制端点是否对外开放。其中 health 端点为默认端点，不能关闭。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span>						<span class="comment"># 端点名称</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">info:</span>						<span class="comment"># 端点名称</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span>				<span class="comment"># 是否开放</span></span><br></pre></td></tr></table></figure>
<p>​		为了方便开发者快速配置端点，springboot admin 设置了 13 个较为常用的端点作为默认开放的端点，如果需要控制默认开放的端点的开放状态，可以通过配置设置，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">true</span>	<span class="comment"># 是否开启默认端点，默认值true</span></span><br></pre></td></tr></table></figure>
<p>​		上述端点开启后，就可以通过端点对应的路径查看对应的信息了。但是此时还不能通过 HTTP 请求查询此信息，还需要开启通过 HTTP 请求查询的端点名称，使用 “*” 可以简化配置成开放所有端点的 WEB 端 HTTP 请求权限。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
<p>​		整体上来说，对于端点的配置有两组信息，一组是 endpoints 开头的，对所有端点进行配置，一组是 endpoint 开头的，对具体端点进行配置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span>		<span class="comment"># 具体端点的配置</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">info:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">endpoints:</span>	<span class="comment"># 全部端点的配置</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>
<p>被监控客户端通过添加 actuator 的坐标可以对外提供被访问的端点功能</p>
</li>
<li>
<p>端点功能的开放与关闭可以通过配置进行控制</p>
</li>
<li>
<p>web 端默认无法获取所有端点信息，通过配置开放端点功能</p>
</li>
</ol>
<h3 id="kf-6-4自定义监控指标"><a class="markdownIt-Anchor" href="#kf-6-4自定义监控指标">#</a> KF-6-4. 自定义监控指标</h3>
<p>​		端点描述了被监控的信息，除了系统默认的指标，还可以自行添加显示的指标，下面就通过 3 种不同的端点的指标自定义方式来学习端点信息的二次开发。</p>
<p><strong>INFO 端点</strong></p>
<p>​		info 端点描述了当前应用的基本信息，可以通过两种形式快速配置 info 端点的信息</p>
<ul>
<li>
<p>配置形式</p>
<p>在 yml 文件中通过设置 info 节点的信息就可以快速配置端点信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">appName:</span> <span class="string">@project.artifactId@</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">@project.version@</span></span><br><span class="line">  <span class="attr">company:</span> <span class="string">传智教育</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">itheima</span></span><br></pre></td></tr></table></figure>
<p>配置完毕后，对应信息显示在监控平台上</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301174133248.png" alt="image-20220301174133248" style="zoom:50%;">
<p>也可以通过请求端点信息路径获取对应 json 信息</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301174241310.png" alt="image-20220301174241310" style="zoom:50%;">
</li>
<li>
<p>编程形式</p>
<p>通过配置的形式只能添加固定的数据，如果需要动态数据还可以通过配置 bean 的方式为 info 端点添加信息，此信息与配置信息共存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoConfig</span> <span class="keyword">implements</span> <span class="title">InfoContributor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contribute</span><span class="params">(Info.Builder builder)</span> </span>&#123;</span><br><span class="line">        builder.withDetail(<span class="string">&quot;runTime&quot;</span>,System.currentTimeMillis());		<span class="comment">//添加单个信息</span></span><br><span class="line">        Map infoMap = <span class="keyword">new</span> HashMap();		</span><br><span class="line">        infoMap.put(<span class="string">&quot;buildTime&quot;</span>,<span class="string">&quot;2006&quot;</span>);</span><br><span class="line">        builder.withDetails(infoMap);									<span class="comment">//添加一组信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Health 端点</strong></p>
<p>​		health 端点描述当前应用的运行健康指标，即应用的运行是否成功。通过编程的形式可以扩展指标信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HealthConfig</span> <span class="keyword">extends</span> <span class="title">AbstractHealthIndicator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doHealthCheck</span><span class="params">(Health.Builder builder)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> condition = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(condition) &#123;</span><br><span class="line">            builder.status(Status.UP);					<span class="comment">//设置运行状态为启动状态</span></span><br><span class="line">            builder.withDetail(<span class="string">&quot;runTime&quot;</span>, System.currentTimeMillis());</span><br><span class="line">            Map infoMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            infoMap.put(<span class="string">&quot;buildTime&quot;</span>, <span class="string">&quot;2006&quot;</span>);</span><br><span class="line">            builder.withDetails(infoMap);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            builder.status(Status.OUT_OF_SERVICE);		<span class="comment">//设置运行状态为不在服务状态</span></span><br><span class="line">            builder.withDetail(<span class="string">&quot;上线了吗？&quot;</span>,<span class="string">&quot;你做梦&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		当任意一个组件状态不为 UP 时，整体应用对外服务状态为非 UP 状态。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301174751845.png" alt="image-20220301174751845" style="zoom:50%;">
<p><strong>Metrics 端点</strong></p>
<p>​		metrics 端点描述了性能指标，除了系统自带的监控性能指标，还可以自定义性能指标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">BookDao</span>, <span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">IBookService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Counter counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookServiceImpl</span><span class="params">(MeterRegistry meterRegistry)</span></span>&#123;</span><br><span class="line">        counter = meterRegistry.counter(<span class="string">&quot;用户付费操作次数：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每次执行删除业务等同于执行了付费业务</span></span><br><span class="line">        counter.increment();</span><br><span class="line">        <span class="keyword">return</span> bookDao.deleteById(id) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在性能指标中就出现了自定义的性能指标监控项</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301175101812.png" alt="image-20220301175101812" style="zoom:50%;">
<p><strong>自定义端点</strong></p>
<p>​		可以根据业务需要自定义端点，方便业务监控</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Endpoint(id=&quot;pay&quot;,enableByDefault = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayEndpoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ReadOperation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map payMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        payMap.put(<span class="string">&quot;level 1&quot;</span>,<span class="string">&quot;300&quot;</span>);</span><br><span class="line">        payMap.put(<span class="string">&quot;level 2&quot;</span>,<span class="string">&quot;291&quot;</span>);</span><br><span class="line">        payMap.put(<span class="string">&quot;level 3&quot;</span>,<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> payMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		由于此端点数据 spirng boot admin 无法预知该如何展示，所以通过界面无法看到此数据，通过 HTTP 请求路径可以获取到当前端点的信息，但是需要先开启当前端点对外功能，或者设置当前端点为默认开发的端点。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/image-20220301175355482.png" alt="image-20220301175355482" style="zoom:50%;">
<p><strong>总结</strong></p>
<ol>
<li>端点的指标可以自定义，但是每种不同的指标根据其功能不同，自定义方式不同</li>
<li>info 端点通过配置和编程的方式都可以添加端点指标</li>
<li>health 端点通过编程的方式添加端点指标，需要注意要为对应指标添加启动状态的逻辑设定</li>
<li>metrics 指标通过在业务中添加监控操作设置指标</li>
<li>可以自定义端点添加更多的指标</li>
</ol>
<h2 id="开发实用篇完结"><a class="markdownIt-Anchor" href="#开发实用篇完结">#</a> 开发实用篇完结</h2>
<p>​		开发实用篇到这里就暂时完结了，在开发实用篇中我们讲解了大量的第三方技术的整合方案，选择的方案都是市面上比较流行的常用方案，还有一些国内流行度较低的方案目前还没讲，留到番外篇中慢慢讲吧。</p>
<p>​		整体开发实用篇中讲解的内容可以分为两大类知识：实用性知识与经验性知识。</p>
<p>​		实用性知识就是新知识了，springboot 整合各种技术，每种技术整合中都有一些特殊操作，整体来说其实就是三句话。加坐标做配置调接口。经验性知识是对前面两篇中出现的一些知识的补充，在学习基础篇时如果将精力放在这些东西上就有点学偏了，容易钻牛角尖，放到实用开发篇中结合实际开发说一些不常见的但是对系统功能又危害的操作解决方案，提升理解。</p>
<p>​		开发实用篇做到这里就告一段落，下面就要着手准备原理篇了。市面上很多课程原理篇讲的过于高深莫测，在新手还没明白 123 的时候就开始讲微积分了，着实让人看了着急。至于原理篇我讲成什么样子？一起期待吧。</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>教程</tag>
        <tag>SpringBoot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot讲义-基础篇</title>
    <url>/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="springboot"><a class="markdownIt-Anchor" href="#springboot">#</a> SpringBoot</h1>
<h3 id="前言白嫖发言"><a class="markdownIt-Anchor" href="#前言白嫖发言">#</a> 前言（白嫖发言）</h3>
<p>​		这个笔记是从黑马老师那里嫖来的，放在这里是为了方便查看，没有商用的意思，转载请标明<strong>黑马程序员</strong>以及链接。</p>
<h3 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h3>
<p>​		很荣幸有机会能以这样的形式和互联网上的各位小伙伴一起学习交流技术课程，这次给大家带来的是 Spring 家族中比较重要的一门技术课程 ——SpringBoot。一句话介绍这个技术，应该怎么说呢？现在如果开发 Spring 程序不用 SpringBoot 那就是给自己过不去，SpringBoot 为我们开发 Spring 程序提供了太多的帮助，在此借这个机会给大家分享这门课程，希望各位小伙伴学有所得，学有所用，学有所成。</p>
<p>​		正如上面提到的，这门技术是用来加速开发 Spring 程序的，因此学习这门技术是有一定的门槛的。你可以理解为你现在是一门传统的手工艺人，现在工艺升级，可以加速你的生产制作过程，但是前提是你要会原始工艺，然后才能学习新的工艺。嗯，怎么说呢？有一定的门槛，至少 Spring 怎么回事，与 Spring 配合在一起工作的一堆技术又是怎么回事，这些搞明白才能来看这个技术，不然就只能学个皮毛，或者学着学着就开始因为其他技术不太过关，然后就学不下去了，然后，就没有然后了，果断弃坑了。不管怎么说，既来之则安之，加油学习吧，投资自己肯定是没毛病的。</p>
<h3 id="课程内容说明"><a class="markdownIt-Anchor" href="#课程内容说明">#</a> 课程内容说明</h3>
<p>​		SpringBoot 这门技术课程所包含的技术点其实并不是很多，但是围绕着 SpringBoot 的周边知识，也就是 SpringBoot 整合其他技术，这样的知识量很大，例如 SpringBoot 整合 MyBatis 等等。因此为了能够将本课程制作的能够适应于各个层面的学习者进行学习，本套课程会针对小白，初学者，开发者三种不同的人群来设计全套课程。具体这三种人群如何划分，就按照我的描述形式来分吧，各位小伙伴可以对号入座，每种人群看课程的起始位置略有差别。</p>
<table>
<thead>
<tr>
<th>学习者</th>
<th>归类方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>小白</strong></td>
<td>完全没有用过 SpringBoot 技术</td>
</tr>
<tr>
<td><strong>初学者</strong></td>
<td>能使用 SpringBoot 技术完成基础的 SSM 整合</td>
</tr>
<tr>
<td><strong>开发者</strong></td>
<td>能使用 SpringBoot 技术实现常见的技术整合工作</td>
</tr>
</tbody>
</table>
<p>​		简单说就是你能用 SpringBoot 做多少东西，一点不会就是小白，会一点就是初学者，大部分都会就是开发者。其实这个划分也不用过于纠结，这个划分仅仅是为了帮助你对本技术课程所包含的阶段模块划分做一个清晰认知，因为本课程中会将 SpringBoot 技术划分成 4 个单元，每个单元是针对不同的学习者准备的。</p>
<table>
<thead>
<tr>
<th>学习者</th>
<th>课程单元</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>小白</strong></td>
<td><font color="#ff0000"><b>基础篇</b></font></td>
</tr>
<tr>
<td><strong>初学者</strong></td>
<td><font color="#cc0000"><b>应用篇</b></font>（  运维实用篇  &amp;  开发实用篇  ）</td>
</tr>
<tr>
<td><strong>开发者</strong></td>
<td><font color="#990000"><b>原理篇</b></font></td>
</tr>
</tbody>
</table>
<p>​		看完这个划分你就应该有这么个概念，我没有用过 SpringBoot 技术，所以从基础篇开始学习；或者我会一点 SpringBoot 技术，那我从实用篇开始学就好了，就是这个意思。</p>
<p>​		每个课程单元内容设置不同，目标也不一样，作为学习者如果想达成最佳的学习效果，最好明确自己的学习目标再进行学习，这样目标明确，学习的时候能够更轻松，你就不会在学习的时候纠结如下的问题了。比如学着<font color="#ff0000"><b>基础篇</b></font>在那想，这个东西是个什么原理啊？这个东西是这么用的，那个东西该怎么用啊？因为原理性的内容统一放置到了<font color="#990000"><b>原理篇</b></font>讲解了，应用相关的内容统一放到<font color="#cc0000"><b>应用篇</b></font>里面讲解，你在<font color="#ff0000"><b>基础篇</b></font>阶段纠结也没有用，这一部分不讲这些知识，在<font color="#ff0000"><b>基础篇</b></font>先把 SpringBoot 的基础使用掌握完再说后面的知识吧。</p>
<p>​		此外还有一点需要说明的是，目前 SpringBoot 技术发展速度很快，更新速度也很快，因此后续还会对本套课程进行持续更新，特此在三个课程单元的基础上追加一个<strong>番外篇</strong>。番外篇的设置为了解决如下问题：</p>
<ul>
<li>持续更新 SpringBoot 后续发展出现的新技术</li>
<li>讲解部分知识点规模较大的支线知识（例如 WebFlux）</li>
<li>扩展非实用性知识，扩展学习者视野</li>
</ul>
<p>​		每一个课程单元的学习目标如下，请各位查收，在学习的过程中可以阶段性的给自己提个问题，下面列出来的这些学习目标你是否达成了，可以检验你的学习成果。</p>
<table>
<thead>
<tr>
<th>课程单元</th>
<th>学习目标</th>
</tr>
</thead>
<tbody>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>能够创建 SpringBoot 工程<br>基于 SpringBoot 实现 ssm/ssmp 整合</td>
</tr>
<tr>
<td><font color="#cc0000"><b>应用篇</b></font></td>
<td>能够掌握 SpringBoot 程序多环境开发<br>能够基于 Linux 系统发布 SpringBoot 工程<br>能够解决线上灵活配置 SpringBoot 工程的需求<br>能够基于 SpringBoot 整合任意第三方技术</td>
</tr>
<tr>
<td><font color="#990000"><b>原理篇</b></font></td>
<td>掌握 SpringBoot 内部工作流程<br>理解 SpringBoot 整合第三方技术的原理<br>实现自定义开发整合第三方技术的组件</td>
</tr>
<tr>
<td><strong>番外篇</strong></td>
<td>掌握 SpringBoot 整合非常见的第三方技术<br>掌握相同领域的更多的解决方案，并提升同领域方案设计能力</td>
</tr>
</tbody>
</table>
<p>​		整体课程包含的内容就是这些啦，要想完成前面这些内容的学习，顺利的达成学习目标，有些东西还是要提前和大家说清楚的。SpringBoot 课程不像是 Java 基础，不管你有没有基础，都可以听一听，这个课程还真不行，需要一定的前置知识。下面给大家列表一些前置知识，如果还有不太会的，需要想办法快速补救一下。</p>
<h3 id="课程前置知识说明"><a class="markdownIt-Anchor" href="#课程前置知识说明">#</a> 课程前置知识说明</h3>
<table>
<thead>
<tr>
<th>课程单元</th>
<th>前置知识</th>
<th>要求</th>
</tr>
</thead>
<tbody>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>Java 基础语法</td>
<td>面向对象，封装，继承，多态，类与接口，集合，IO，网络编程等</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>Spring 与 SpringMVC</td>
<td>知道 Spring 是用来管理 bean，能够基于 Restful 实现页面请求交互功能</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>Mybatis 与 Mybatis-Plus</td>
<td>基于 Mybatis 和 MybatisPlus 能够开发出包含基础 CRUD 功能的标准 Dao 模块</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>数据库 MySQL</td>
<td>能够读懂基础 CRUD 功能的 SQL 语句</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>服务器</td>
<td>知道服务器与 web 工程的关系，熟悉 web 服务器的基础配置</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>maven</td>
<td>知道 maven 的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>web 技术（含 vue，ElementUI)</td>
<td>知道 vue 如何发送 ajax 请求，如何获取响应数据，如何进行数据模型双向绑定</td>
</tr>
<tr>
<td><font color="#cc0000"><b>应用篇</b></font></td>
<td>Linux（CenterOS7）</td>
<td>熟悉常用的 Linux 基础指令，熟悉 Linux 系统目录结构</td>
</tr>
<tr>
<td><font color="#cc0000"><b>应用篇</b></font></td>
<td>实用开发技术</td>
<td>缓存：Redis、MongoDB、……<br>消息中间件：RocketMq、RabbitMq、……</td>
</tr>
<tr>
<td><font color="#990000"><b>原理篇</b></font></td>
<td>Spring</td>
<td>了解 Spring 加载 bean 的各种方式<br>知道 Spring 容器底层工作原理，能够阅读简单的 Spring 底层源码</td>
</tr>
</tbody>
</table>
<p>​		看着略微有点多，其实还好吧，如果个别技术真的不会，在学习课程的时候多用心听就好，基础篇是可以跟着学下来了，后面的实用篇和原理篇就比较难了。比如我要在 Linux 系统下操作，命令我就直接使用了，然后你看不懂可能学习起来就比较心累了。</p>
<p>​		课程安排就说到这里了，下面进入到 SpringBoot<font color="#ff0000"><b>基础篇</b></font>的学习</p>
<h1 id="springboot基础篇"><a class="markdownIt-Anchor" href="#springboot基础篇">#</a> SpringBoot 基础篇</h1>
<p>​		在基础篇中，我给学习者的定位是先上手，能够使用 SpringBoot 搭建基于 SpringBoot 的 web 项目开发，所以内容设置较少，主要包含如下内容：</p>
<ul>
<li>SpringBoot 快速入门</li>
<li>SpringBoot 基础配置</li>
<li>基于 SpringBoot 整合 SSMP</li>
</ul>
<h2 id="jc-1快速上手springboot"><a class="markdownIt-Anchor" href="#jc-1快速上手springboot">#</a> JC-1. 快速上手 SpringBoot</h2>
<p>​		学习任意一项技术，首先要知道这个技术的作用是什么，不然学完以后，你都不知道什么时候使用这个技术，也就是技术对应的应用场景。SpringBoot 技术由 Pivotal 团队研发制作，功能的话简单概括就是加速 Spring 程序的开发，这个加速要从如下两个方面来说</p>
<ul>
<li>Spring 程序初始搭建过程</li>
<li>Spring 程序的开发过程</li>
</ul>
<p>​	通过上面两个方面的定位，我们可以产生两个模糊的概念：</p>
<ol>
<li>SpringBoot 开发团队认为原始的 Spring 程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的 Spring 程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的 Spring 程序至少有一个配置文件或配置类，用来描述 Spring 的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用 Spring 大部分情况下是做 web 开发，如果做 web 开发的话，还要在加载 web 环境时加载时加载指定的 spring 配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件 / 配置类呢？那换了 SpringBoot 技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子</li>
<li>SpringBoot 开发团队认为原始的 Spring 程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的 jar 包（或坐标）然后将这个技术的核心对象交给 Spring 容器管理，也就是配置成 Spring 容器管控的 bean 就可以了。这都是基本操作啊，难道这些东西 SpringBoot 也能帮我们简化？</li>
</ol>
<p>​	带着上面这些疑问我们就着手第一个 SpringBoot 程序的开发了，看看到底使用 SpringBoot 技术能简化开发到什么程度。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		如果对 Spring 程序的基础开发不太懂的小伙伴，看到这里可以弃坑了，下面的内容学习需要具备 Spring 技术的知识，硬着头皮学不下去的。</p>
<h3 id="jc-1-1springboot入门程序制作一"><a class="markdownIt-Anchor" href="#jc-1-1springboot入门程序制作一">#</a> JC-1-1.SpringBoot 入门程序制作（一）</h3>
<p>​		下面让我们开始做第一个 SpringBoot 程序吧，本课程基于 Idea2020.3 版本制作，使用的 Maven 版本为 3.6.1，JDK 版本为 1.8。如果你的环境和上述环境不同，可能在操作界面和操作过程中略有不同，只要软件匹配兼容即可（说到这个 Idea 和 Maven，它们两个还真不是什么版本都能搭到一起的，说多了都是泪啊）。</p>
<p>​		下面使用 SpringBoot 技术快速构建一个 SpringMVC 的程序，通过这个过程体会<font color="#ff0000"><b>简化</b></font>二字的含义。</p>
<p><strong>步骤①</strong>：创建新模块，选择 Spring Initializr，并配置模块相关基础信息</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211116125259385.png" alt="image-20211116125259385"></p>
<p>​		<font color="#ff0000"><b>特别关注</b></font>：第 3 步点击 Next 时，Idea 需要联网状态才可以进入到后面那一页，如果不能正常联网，就无法正确到达右面那个设置页了，会一直<font color="#ff0000"><b>联网</b></font>转转转。</p>
<p>​		<font color="#ff0000"><b>特别关注</b></font>：第 5 步选择 java 版本和你计算机上安装的 JDK 版本匹配即可，但是最低要求为 JDK8 或以上版本，推荐使用 8 或 11。</p>
<p><strong>步骤②</strong>：选择当前模块需要使用的技术集</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211116125615728.png" alt="image-20211116125615728"></p>
<p>​		按照要求，左侧选择 web，然后在中间选择 Spring Web 即可，选完右侧就出现了新的内容项，这就表示勾选成功了。</p>
<p>​		<font color="#ff0000"><b>关注</b></font>：此处选择的 SpringBoot 的版本使用默认的就可以了，需要说一点，SpringBoot 的版本升级速度很快，可能昨天创建工程的时候默认版本是 2.5.4，今天再创建工程默认版本就变成 2.5.5 了，差别不大，无需过于纠结，并且还可以到配置文件中修改对应的版本。</p>
<p><strong>步骤③</strong>：开发控制器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Rest模式</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;springboot is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springboot is running...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		入门案例制作的 SpringMVC 的控制器基于 Rest 风格开发，当然此处使用原始格式制作 SpringMVC 的程序也是没有问题的，上例中的 @RestController 与 @GetMapping 注解是基于 Restful 开发的典型注解。</p>
<p>​		<font color="#ff0000"><b>关注</b></font>：做到这里 SpringBoot 程序的最基础的开发已经做完了，现在就可以正常的运行 Spring 程序了。可能有些小伙伴会有疑惑，Tomcat 服务器没有配置，Spring 也没有配置，什么都没有配置这就能用吗？这就是 SpringBoot 技术的强大之处。关于内部工作流程后面再说，先专心学习开发过程。</p>
<p><strong>步骤④</strong>：运行自动生成的 Application 类</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211116130152452.png" alt="image-20211116130152452"></p>
<p>​		使用带 main 方法的 java 程序的运行形式来运行程序，运行完毕后，控制台输出上述信息。</p>
<p>​		不难看出，运行的信息中包含了 8080 的端口，Tomcat 这种熟悉的字样，难道这里启动了 Tomcat 服务器？是的，这里已经启动了。那服务器没有配置，哪里来的呢？后面再说。现在你就可以通过浏览器访问请求的路径，测试功能是否工作正常了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问路径：	http:<span class="comment">//localhost:8080/books</span></span><br></pre></td></tr></table></figure>
<p>​		是不是感觉很神奇？当前效果其实依赖的底层逻辑还是很复杂的，但是从开发者角度来看，目前只有两个文件展现到了开发者面前。</p>
<ul>
<li>
<p>pom.xml</p>
<p>这是 maven 的配置文件，描述了当前工程构建时相应的配置信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot_01_01_quickstart<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置中有两个信息需要关注，一个是 parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说。</p>
</li>
<li>
<p>Application 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类功能很简单，就一句代码，前面运行程序就是运行的这个类。</p>
</li>
</ul>
<p>​       到这里我们可以大胆推测一下，如果上面这两个文件没有的话，SpringBoot 肯定没法玩，看来核心就是这两个文件了。由于是制作第一个 SpringBoot 程序，先不要关注这两个文件的功能，后面详细讲解内部工作流程。</p>
<p>​       通过上面的制作，我们不难发现，SpringBoot 程序简直太好写了，几乎什么都没写，功能就有了，这也是 SpringBoot 技术为什么现在这么火的原因，和 Spring 程序相比，SpringBoot 程序在开发的过程中各个层面均具有优势。</p>
<table>
<thead>
<tr>
<th><strong>类配置文件</strong></th>
<th><strong>Spring</strong></th>
<th><strong>SpringBoot</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>pom 文件中的坐标</td>
<td><strong>手工添加</strong></td>
<td><strong>勾选添加</strong></td>
</tr>
<tr>
<td>web3.0 配置类</td>
<td><strong>手工制作</strong></td>
<td><strong>无</strong></td>
</tr>
<tr>
<td>Spring/SpringMVC 配置类</td>
<td><strong>手工制作</strong></td>
<td><strong>无</strong></td>
</tr>
<tr>
<td>控制器</td>
<td><strong>手工制作</strong></td>
<td><strong>手工制作</strong></td>
</tr>
</tbody>
</table>
<p>​		一句话总结一下就是<font color="#ff0000"><b>能少写就少写</b></font>，<font color="#ff0000"><b>能不写就不写</b></font>，这就是 SpringBoot 技术给我们带来的好处，行了，现在你就可以动手做一做 SpringBoot 程序了，看看效果如何，是否真的帮助你简化开发了。</p>
<p><strong>总结</strong></p>
<ol>
<li>开发 SpringBoot 程序在 Idea 工具中基于联网的前提下可以根据向导快速制作</li>
<li>SpringBoot 程序需要依赖 JDK，版本要求最低为 JDK8</li>
<li>SpringBoot 程序中需要使用某种功能时可以通过勾选的形式选择技术，也可以手工添加对应的要使用的技术（后期讲解）</li>
<li>运行 SpringBoot 程序通过运行 Application 程序进行</li>
</ol>
<p><strong>思考</strong></p>
<p>​		前面制作的时候说过，这个过程必须联网才可以进行，但是有些时候你会遇到一些莫名其妙的问题，比如基于 Idea 开发时，你会发现你配置了一些坐标，然后 Maven 下载对应东西的时候死慢死慢的，甚至还会失败。其实这种现象和 Idea 这款 IDE 工具有关，万一 Idea 不能正常访问网络的话，我们是不是就无法制作 SpringBoot 程序了呢？咱们下一节再说。</p>
<h3 id="jc-1-2springboot入门程序制作二"><a class="markdownIt-Anchor" href="#jc-1-2springboot入门程序制作二">#</a> JC-1-2.SpringBoot 入门程序制作（二）</h3>
<p>​		如果 Idea 不能正常联网，这个 SpringBoot 程序就无法制作了吗？开什么玩笑，世上 IDE 工具千千万，难道 SpringBoot 技术还必须基于 Idea 来做了？这是不可能的。开发 SpringBoot 程序可以不基于 IDE 工具进行，在 SpringBoot 官网中可以直接创建 SpringBoot 程序。</p>
<p>​		SpringBoot 官网和 Spring 的官网是在一起的，都是  <a href="http://spring.io">spring.io</a>  。你可以通过项目一级一级的找到 SpringBoot 技术的介绍页，然后在页面中间部位找到如下内容</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122150444816.png" alt="image-20211122150444816" style="zoom: 67%;">
<p><strong>步骤①</strong>：点击<strong> Spring Initializr</strong> 后进入到创建 SpringBoot 程序界面，接下来就是输入信息的过程，和在 Idea 中制作是一样的，只是界面发生了变化，根据自己的要求，在左侧选择对应信息和输入对应的信息。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122150608039.png" alt="image-20211122150608039">
<p><strong>步骤②</strong>：右侧的<strong> ADD DEPENDENCIES</strong> 用于选择使用何种技术，和之前勾选的 Spring WEB 是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122161257361.png" alt="image-20211122161257361" style="zoom:50%;">
<p><strong>步骤③</strong>：所有信息设置完毕后，点击下面左侧<strong> GENERATE</strong> 按钮，生成一个文件包。</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-202111221615480212.png" alt="image-20211122161548022"></p>
<p><strong>步骤④</strong>：保存后得到一个压缩文件，这个文件就是创建的 SpringBoot 工程</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122161709478.png" alt="image-20211122161709478"></p>
<p><strong>步骤⑤</strong>：解压缩此文件得到工程目录，在 Idea 中导入即可直接使用，和之前在 Idea 环境下根据向导创建的工程完全一样，你可以创建一个 Controller 测试一下当前工程是否可用。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		做到这里其实可以透漏一个小秘密，Idea 工具中创建 SpringBoot 工程其实连接的就是 SpringBoot 的官网，还句话说这种方式和第一种方式是一模一样的，只不过 Idea 把界面给整合了一下，读取 Spring 官网信息，然后展示到 Idea 界面中而已，可以通过如下信息比对一下</p>
<p><strong>Idea 中创建工程时默认选项</strong></p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122162443035.png" alt="image-20211122162443035" style="zoom: 67%;">
<p><strong>SpringBoot 官网创建工程时对应的地址</strong></p>
<p>​		看看 SpringBoot 官网创建工程的 URL 地址，是不是和 Idea 中使用的 URL 地址是一样的？</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122162820719.png" alt="image-20211122162820719">
<p><strong>总结</strong></p>
<ol>
<li>
<p>打开 SpringBoot 官网，选择<strong> Quickstart Your Project</strong> 中的 Spring Initializr。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122150444816.png" alt="image-20211122150444816" style="zoom: 67%;">
</li>
<li>
<p>创建工程。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122150608039.png" alt="image-20211122150608039">
</li>
<li>
<p>保存项目文件。</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122161548022.png" alt="image-20211122161548022"></p>
</li>
<li>
<p>解压项目，通过 IDE 导入项目后进行编辑使用。</p>
</li>
</ol>
<p><strong>思考</strong></p>
<p>​		现在创建工程靠的是访问国外的 Spring 主站，但是互联网信息的访问是可以被约束的，如果一天这个网站你在国内无法访问了，那前面这两种方式就无法创建 SpringBoot 工程了，这时候又该怎么解决这个问题呢？咱们下一节再说。</p>
<h3 id="jc-1-3springboot入门程序制作三"><a class="markdownIt-Anchor" href="#jc-1-3springboot入门程序制作三">#</a> JC-1-3.SpringBoot 入门程序制作（三）</h3>
<p>​		前面提到网站如果被限制访问了，该怎么办？开动脑筋想一想，不管是方式一还是方式二其实走的都是同一个路线，就是通过 SpringBoot 官网创建 SpringBoot 工程，假如国内有这么一个网站也能提供这样的功能，是不是就解决了呢？必然的嘛，新的问题又来了，国内有提供这样功能的网站吗？还真有，阿里提供了一个，下面问题就简单了，网址告诉我们就 OK 了，没错，就是这样。</p>
<p>​		创建工程时，切换选择 starter 服务路径，然后手工输入阿里云地址即可，地址：<a href="http://start.aliyun.xn--comhttps-bt7p">http://start.aliyun.com 或 https</a>😕/start.aliyun.com</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122163605950.png" alt="image-20211122163605950"></p>
<p>​		阿里为了便于自己公司开发使用，特此在依赖坐标中添加了一些阿里自主的技术，也是为了推广自己的技术吧，所以在依赖选择列表中，你有了更多的选择。此外，阿里提供的地址更符合国内开发者的使用习惯，里面有一些 SpringBoot 官网上没有给出的坐标，大家可以好好看一看。</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122163937408.png" alt="image-20211122163937408"></p>
<p>​		不过有一点需要说清楚，阿里云地址默认创建的 SpringBoot 工程版本是<font color="#ff0000"><b>2.4.1</b></font>，所以如果你想更换其他的版本，创建项目后在 pom 文件中手工修改即可，别忘了刷新一下，加载新版本信息。</p>
<p>​		<font color="#ff0000"><b>注意</b></font>：阿里云提供的工程创建地址初始化完毕后和使用 SpringBoot 官网创建出来的工程略有区别，主要是在配置文件的形式上有区别，这个信息在后面讲解 SpringBoot 程序的执行流程时给大家揭晓。</p>
<p><strong>总结</strong></p>
<ol>
<li>选择 start 来源为自定义 URL</li>
<li>输入阿里云 starter 地址</li>
<li>创建项目</li>
</ol>
<p><strong>思考</strong></p>
<p>​		做到这里我们已经有了三种方式创建 SpringBoot 工程，但是每种方式都要求你必须能上网才能创建工程。假如有一天，你加入了一个保密级别比较高的项目组，整个项目组没有外网，这个事情是不是就不能做了呢？咱们下一节再说。</p>
<h3 id="jc-1-4springboot入门程序制作四"><a class="markdownIt-Anchor" href="#jc-1-4springboot入门程序制作四">#</a> JC-1-4.SpringBoot 入门程序制作（四）</h3>
<p>​		不能上网，还想创建 SpringBoot 工程，能不能做呢？能做，但是你要先问问自己联网和不联网到底差别是什么？这个差别找到以后，你就发现，你把联网要干的事情都提前准备好，就无需联网了。</p>
<p>​		联网做什么呢？首先 SpringBoot 工程也是基于 Maven 构建的，而 Maven 工程中如果加载一些工程需要使用又不存在的东西时，就要联网去下载。其实 SpringBoot 工程创建的时候就是要去下载一些必要的组件。如果把这些东西提前准备好呢？是的，就是这样。</p>
<p>​		下面就手工创建一个 SpringBoot 工程，如果需要使用的东西提前保障在 maven 仓库中存在，整个过程就可以不依赖联网环境了。不过咱们已经用 3 种方式创建了 SprongBoot 工程了，所以下面也没什么东西需要下载了。</p>
<p><strong>步骤①</strong>：创建工程时，选择创建普通 Maven 工程。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122165341684.png" alt="image-20211122165341684" style="zoom:50%;">
<p><strong>步骤②</strong>：参照标准 SpringBoot 工程的 pom 文件，书写自己的 pom 文件即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot_01_04_quickstart<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		用什么写什么，不用的都可以不写。当然，现在小伙伴们可能还不知道用什么和不用什么，最简单的就是复制粘贴了，随着后面的学习，你就知道哪些可以省略了。此处我删减了一些目前不是必须的东西，一样能用。核心的内容有两条，一个是继承了一个父工程，另外添加了一个依赖。</p>
<p><strong>步骤③</strong>：之前运行 SpringBoot 工程需要一个类，这个缺不了，自己手写一个就行了，建议按照之前的目录结构来创建，先别玩花样，先学走后学跑。类名可以自定义，关联的名称同步修改即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		<font color="#ff0000"><b>关注</b></font>：类上面的注解 @SpringBootApplication 千万别丢了，这个是核心，后面再介绍。</p>
<p>​		<font color="#ff0000"><b>关注</b></font>：类名可以自定义，只要保障下面代码中使用的类名和你自己定义的名称一样即可，也就是 run 方法中的那个 class 对应的名称。</p>
<p><strong>步骤④</strong>：下面就可以自己创建一个 Controller 测试一下是否能用了，和之前没有差别的。</p>
<p>​		看到这里其实应该能够想明白了，通过向导或者网站创建的 SpringBoot 工程其实就是帮你写了一些代码，而现在是自己手写，写的内容都一样，仅此而已。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		如果你的计算机上从来没有创建成功过 SpringBoot 工程，自然也就没有下载过 SpringBoot 对应的坐标相关的资源，那用手写创建的方式在不联网的情况下肯定该是不能用的。所谓手写，其实就是自己写别人帮你生成的东西，但是引用的坐标对应的资源必须保障 maven 仓库里面有才行，如果没有，还是要去下载的。</p>
<p><strong>总结</strong></p>
<ol>
<li>创建普通 Maven 工程</li>
<li>继承 spring-boot-starter-parent</li>
<li>添加依赖 spring-boot-starter-web</li>
<li>制作引导类 Application</li>
</ol>
<p>​        到这里已经学习了 4 种创建 SpringBoot 工程的方式，其实本质是一样的，都是根据 SpringBoot 工程的文件格式要求，通过不同时方式生成或者手写得到对应的文件，效果完全一样。</p>
<h4 id="教你一招在idea中隐藏指定文件文件夹"><a class="markdownIt-Anchor" href="#教你一招在idea中隐藏指定文件文件夹">#</a> 教你一招：在 Idea 中隐藏指定文件 / 文件夹</h4>
<p>​		创建 SpringBoot 工程时，使用 SpringBoot 向导也好，阿里云也罢，其实都是为了一个目的，得到一个标准的 SpringBoot 工程文件结构。这个时候就有新的问题出现了，标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，这一节就来说说这些文件怎么处理。</p>
<p>​		处理方案无外乎两种，如果你对每一个文件 / 目录足够了解，有用的留着，没有用的完全可以删除掉。或者不删除，但是看着别扭，就设置文件为看不到就行了。删除不说了，选中后直接 Delete 掉就好了，这一节说说如何隐藏指定的文件或文件夹信息。</p>
<p>​		既然是在 Idea 下做隐藏功能，肯定隶属于 Idea 的设置，设置方式如下。</p>
<p><strong>步骤①</strong>：打开设置，【Files】→【Settings】。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122173835517.png" alt="image-20211122173835517" style="zoom:80%;">
<p><strong>步骤②</strong>：打开文件类型设置界面后，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122174020028.png" alt="image-20211122174020028" style="zoom: 67%;">
<p><strong>步骤③</strong>：添加你要隐藏的文件名称或文件夹名称，可以使用 * 号通配符，表示任意，设置完毕即可。</p>
<p>​	到这里就做完了，其实就是 Idea 的一个小功能</p>
<p><strong>总结</strong></p>
<ol>
<li>Idea 中隐藏指定文件或指定类型文件
<ol>
<li>【Files】→【Settings】</li>
<li>【Editor】→【File Types】→【Ignored Files and Folders】</li>
<li>输入要隐藏的名称，支持 * 号通配符</li>
<li>回车确认添加</li>
</ol>
</li>
</ol>
<h3 id="jc-1-5springboot简介"><a class="markdownIt-Anchor" href="#jc-1-5springboot简介">#</a> JC-1-5.SpringBoot 简介</h3>
<p>​		入门案例做完了，这个时候回忆一下咱们之前说的 SpringBoot 的功能是什么还记得吗？加速 Spring 程序的开发，现在是否深有体会？再来看 SpringBoot 技术的设计初衷就很容易理解了。</p>
<p>​		SpringBoot 是由 Pivotal 团队提供的全新框架，其设计目的是用来<font color="#ff0000"><b>简化 Spring 应用的初始搭建以及开发过程</b></font>。</p>
<p>​		都简化了了哪些东西呢？其实就是针对原始的 Spring 程序制作的两个方面进行了简化：</p>
<ul>
<li>Spring 程序缺点
<ul>
<li>依赖设置繁琐
<ul>
<li>以前写 Spring 程序，使用的技术都要自己一个一个的写，现在不需要了，如果做过原始 SpringMVC 程序的小伙伴应该知道，写 SpringMVC 程序，最基础的 spring-web 和 spring-webmvc 这两个坐标是必须的，就这还不包含你用 json 啊等等这些坐标，现在呢？一个坐标搞定了。</li>
</ul>
</li>
<li>配置繁琐
<ul>
<li>以前写配置类或者配置文件，然后用什么东西就要自己写加载 bean 这些东西，现在呢？什么都没写，照样能用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>回顾</p>
<p>​	通过上面两个方面的定位，我们可以产生两个模糊的概念：</p>
<ol>
<li>SpringBoot 开发团队认为原始的 Spring 程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的 Spring 程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的 Spring 程序至少有一个配置文件或配置类，用来描述 Spring 的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用 Spring 大部分情况下是做 web 开发，如果做 web 开发的话，还要在加载 web 环境时加载时加载指定的 spring 配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件 / 配置类呢？那换了 SpringBoot 技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子</li>
<li>SpringBoot 开发团队认为原始的 Spring 程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的 jar 包（或坐标）然后将这个技术的核心对象交给 Spring 容器管理，也就是配置成 Spring 容器管控的 bean 就可以了。这都是基本操作啊，难道这些东西 SpringBoot 也能帮我们简化？</li>
</ol>
</blockquote>
<p>​		再来看看前面提出的两个问题，已经有答案了，都简化了，都不用写了，这就是 SpringBoot 给我们带来的好处。这些简化操作在 SpringBoot 中有专业的用语，也是 SpringBoot 程序的核心功能及优点：</p>
<ul>
<li>起步依赖（简化依赖配置）
<ul>
<li>依赖配置的书写简化就是靠这个起步依赖达成的。</li>
</ul>
</li>
<li>自动配置（简化常用工程相关配置）
<ul>
<li>配置过于繁琐，使用自动配置就可以做相应的简化，但是内部还是很复杂的，后面具体展开说。</li>
</ul>
</li>
<li>辅助功能（内置服务器，……）
<ul>
<li>除了上面的功能，其实 SpringBoot 程序还有其他的一些优势，比如我们没有配置 Tomcat 服务器，但是能正常运行，这是 SpringBoot 入门程序中一个可以感知到的功能，也是 SpringBoot 的辅助功能之一。一个辅助功能都能做的这么 6，太牛了。</li>
</ul>
</li>
</ul>
<p>​		下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为 4 个方面</p>
<ul>
<li>parent</li>
<li>starter</li>
<li>引导类</li>
<li>内嵌 tomcat</li>
</ul>
<h4 id="parent"><a class="markdownIt-Anchor" href="#parent">#</a> parent</h4>
<p>​		SpringBoot 关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如 A 技术的 2.0 版，在与 B 技术进行配合使用时，与 B 技术的 3.5 版可以合作在一起工作，但是和 B 技术的 3.7 版合作开发使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。</p>
<p>​		SpringBoot 一看这种情况 so easy 啊，于是将所有的技术版本的常见使用方案都给开发者整理了出来，以后开发者使用时直接用它提供的版本方案，就不用担心冲突问题了，相当于 SpringBoot 做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做<font color="#ff0000"><b>parent</b></font>。</p>
<p>​		<font color="#ff0000"><b>parent</b></font>自身具有很多个版本，每个<font color="#ff0000"><b>parent</b></font>版本中包含有几百个其他技术的版本号，不同的 parent 间使用的各种技术的版本号有可能会发生变化。当开发者使用某些技术时，直接使用 SpringBoot 提供的<font color="#ff0000"><b>parent</b></font>就行了，由<font color="#ff0000"><b>parent</b></font>帮助开发者统一的进行各种技术的版本管理。</p>
<p>​		比如你现在要使用 Spring 配合 MyBatis 开发，没有 parent 之前怎么做呢？选个 Spring 的版本，再选个 MyBatis 的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你 Spring 的版本发生变化需要切换时，你的 MyBatis 版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现其他问题。现在这一切工作都可以交给 parent 来做了。你无需关注这些技术间的版本冲突问题，你只需要关注你用什么技术就行了，冲突问题由<font color="#ff0000"><b>parent</b></font>负责处理。</p>
<p>​		有人可能会提出来，万一<font color="#ff0000"><b>parent</b></font>给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，<font color="#ff0000"><b>parent</b></font>仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，<font color="#ff0000"><b>使用 parent 可以帮助开发者进行版本的统一管理。</b></font></p>
<p>​		<font color="#ff0000"><b>关注</b></font>：parent 定义出来以后，并不是直接使用的，仅仅给了开发者一个说明书，但是并没有实际使用，这个一定要确认清楚。</p>
<p>​		那 SpringBoot 又是如何做到这一点的呢？可以查阅 SpringBoot 的配置源码，看到这些定义。</p>
<ul>
<li>项目中的 pom.xml 中继承了一个坐标</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>打开后可以查阅到其中又继承了一个坐标</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个坐标中定义了两组信息</li>
</ul>
<p>第一组是各式各样的依赖版本号属性，下面列出依赖版本属性的局部，可以看的出来，定义了若干个技术的依赖版本号。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.16.3<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.19.0<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-codec.version</span>&gt;</span>1.15<span class="tag">&lt;/<span class="name">commons-codec.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-dbcp2.version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">commons-dbcp2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool.version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">commons-pool.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool2.version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">commons-pool2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2.version</span>&gt;</span>1.4.200<span class="tag">&lt;/<span class="name">h2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hibernate.version</span>&gt;</span>5.4.32.Final<span class="tag">&lt;/<span class="name">hibernate.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hibernate-validator.version</span>&gt;</span>6.2.0.Final<span class="tag">&lt;/<span class="name">hibernate-validator.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">httpclient.version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">httpclient.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jackson-bom.version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">jackson-bom.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-jms.version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">javax-jms.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-json.version</span>&gt;</span>1.1.4<span class="tag">&lt;/<span class="name">javax-json.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-websocket.version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">javax-websocket.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jetty-el.version</span>&gt;</span>9.0.48<span class="tag">&lt;/<span class="name">jetty-el.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二组是各式各样的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		<font color="#ff0000"><b>关注</b></font>：上面的依赖坐标定义是出现在<dependencyManagement>标签中的，是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组 parent 信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的。</dependencyManagement></p>
<p>​		<font color="#ff0000"><b>关注</b></font>：因为在 maven 中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的 starter 创建工程时就使用了此种形式。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>开发 SpringBoot 程序要继承 spring-boot-starter-parent</li>
<li>spring-boot-starter-parent 中定义了若干个依赖管理</li>
<li>继承 parent 模块可以避免多个依赖使用相同技术时出现依赖版本冲突</li>
<li>继承 parent 的形式也可以采用引入依赖的形式实现效果</li>
</ol>
<p><strong>思考</strong></p>
<p>​		parent 中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？</p>
<h4 id="starter"><a class="markdownIt-Anchor" href="#starter">#</a> starter</h4>
<p>​		SpringBoot 关注到实际开发时，开发者对于依赖坐标的使用往往都有一些固定的组合方式，比如使用 spring-webmvc 就一定要使用 spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。</p>
<p>​		SpringBoot 一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用每次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot 给它起了个名字叫做<font color="#ff0000"><b>starter</b></font>。</p>
<p>​		starter 定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，<font color="#ff0000"><b>使用 starter 可以帮助开发者减少依赖配置</b></font>。</p>
<p>​		这个东西其实在入门案例里面已经使用过了，入门案例中的 web 功能就是使用这种方式添加依赖的。可以查阅 SpringBoot 的配置源码，看到这些定义。</p>
<ul>
<li>项目中的 pom.xml 定义了使用 SpringMVC 技术，但是并没有写 SpringMVC 的坐标，而是添加了一个名字中包含 starter 的依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 spring-boot-starter-web 中又定义了若干个具体依赖的坐标</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		之前提到过开发 SpringMVC 程序需要导入 spring-webmvc 的坐标和 spring 整合 web 开发的坐标，就是上面这组坐标中的最后两个了。</p>
<p>​		但是我们发现除了这两个坐标，还有其他的坐标。比如第二个，叫做 spring-boot-starter-json。看名称就知道，这个是与 json 有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有 starter，打开看看里面有什么？</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.module<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-module-parameter-names<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		我们可以发现，这个 starter 中又包含了若干个坐标，其实就是使用 SpringMVC 开发通常都会使用到 Json，使用 json 又离不开这里面定义的这些坐标，看来还真是方便，SpringBoot 把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过 maven 中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。</p>
<p>​	到这里基本上得到了一个信息，使用 starter 可以帮开发者快速配置依赖关系。以前写依赖 3 个坐标的，现在写导入一个就搞定了，就是加速依赖配置的。</p>
<p><strong>starter 与 parent 的区别</strong></p>
<p>​		朦朦胧胧中感觉 starter 与 parent 好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。</p>
<p>​		<font color="#ff0000"><b>starter</b></font>是一个坐标中定了若干个坐标，以前写多个的，现在写一个，<font color="#ff0000"><b>是用来减少依赖配置的书写量的</b></font>。</p>
<p>​		<font color="#ff0000"><b>parent</b></font>是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由 SpringBoot 统一管理，这样就不存在版本冲突了，<font color="#ff0000"><b>是用来减少依赖冲突的</b></font>。</p>
<p><strong>实际开发应用方式</strong></p>
<ul>
<li>
<p>实际开发中如果需要用什么技术，先去找有没有这个技术对应的 starter</p>
<ul>
<li>如果有对应的 starter，直接写 starter，而且无需指定版本，版本由 parent 提供</li>
<li>如果没有对应的 starter，手写坐标即可</li>
</ul>
</li>
<li>
<p>实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖 SpringBoot 提供给我们的配置管理</p>
<ul>
<li>方式一：直接写坐标</li>
<li>方式二：覆盖<properties>中定义的版本号，就是下面这堆东西了，哪个冲突了覆盖哪个就 OK 了</properties></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.16.3<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.19.0<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-codec.version</span>&gt;</span>1.15<span class="tag">&lt;/<span class="name">commons-codec.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-dbcp2.version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">commons-dbcp2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool.version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">commons-pool.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool2.version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">commons-pool2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2.version</span>&gt;</span>1.4.200<span class="tag">&lt;/<span class="name">h2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hibernate.version</span>&gt;</span>5.4.32.Final<span class="tag">&lt;/<span class="name">hibernate.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hibernate-validator.version</span>&gt;</span>6.2.0.Final<span class="tag">&lt;/<span class="name">hibernate-validator.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">httpclient.version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">httpclient.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jackson-bom.version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">jackson-bom.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-jms.version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">javax-jms.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-json.version</span>&gt;</span>1.1.4<span class="tag">&lt;/<span class="name">javax-json.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-websocket.version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">javax-websocket.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jetty-el.version</span>&gt;</span>9.0.48<span class="tag">&lt;/<span class="name">jetty-el.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		SpringBoot 官方给出了好多个 starter 的定义，方便我们使用，而且名称都是如下格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">命名规则：spring-boot-starter-技术名称</span><br></pre></td></tr></table></figure>
<p>​	所以后期见了 spring-boot-starter-aaa 这样的名字，这就是 SpringBoot 官方给出的 starter 定义。那非官方定义的也有吗？有的，具体命名方式到整合技术的章节再说。</p>
<p><strong>总结</strong></p>
<ol>
<li>开发 SpringBoot 程序需要导入坐标时通常导入对应的 starter</li>
<li>每个不同的 starter 根据功能不同，通常包含多个依赖坐标</li>
<li>使用 starter 可以实现快速配置的效果，达到简化配置的目的</li>
</ol>
<h4 id="引导类"><a class="markdownIt-Anchor" href="#引导类">#</a> 引导类</h4>
<p>​		配置说完了，我们发现 SpringBoot 确实帮助我们减少了很多配置工作，下面说一下程序是如何运行的。目前程序运行的入口就是 SpringBoot 工程创建时自带的那个类，也就是带有 main 方法的那个类，运行这个类就可以启动 SpringBoot 工程的运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot0101QuickstartApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springboot0101QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		SpringBoot 本身是为了加速 Spring 程序的开发的，而 Spring 程序运行的基础是需要创建 Spring 容器对象（IoC 容器）并将所有的对象放置到 Spring 容器中管理，也就是一个一个的 Bean。现在改用 SpringBoot 加速开发 Spring 程序，这个容器还在吗？这个疑问不用说，一定在。其实当前这个类运行后就会产生一个 Spring 容器对象，并且可以将这个对象保存起来，通过容器对象直接操作 Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickstartApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext ctx = SpringApplication.run(QuickstartApplication.class, args);</span><br><span class="line">        BookController bean = ctx.getBean(BookController.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;bean======&gt;&quot;</span> + bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		通过上述操作不难看出，其实 SpringBoot 程序启动还是创建了一个 Spring 容器对象。当前运行的这个类在 SpringBoot 程序中是所有功能的入口，称为<font color="#ff0000"><b>引导类</b></font>。</p>
<p>​		作为一个引导类最典型的特征就是当前类上方声明了一个注解<font color="#ff0000"><b>@SpringBootApplication</b></font>。</p>
<p><strong>总结</strong></p>
<ol>
<li>SpringBoot 工程提供引导类用来启动程序</li>
<li>SpringBoot 工程启动后创建并初始化 Spring 容器</li>
</ol>
<p><strong>思考</strong></p>
<p>​		程序现在已经运行了，通过引导类的 main 方法运行了起来。但是运行 java 程序不应该是执行完就结束了吗？但是我们现在明显是启动了一个 web 服务器啊，不然网页怎么能正常访问呢？这个服务器是在哪里写的呢？</p>
<h4 id="内嵌tomcat"><a class="markdownIt-Anchor" href="#内嵌tomcat">#</a> 内嵌 tomcat</h4>
<p>​		当前我们做的 SpringBoot 入门案例勾选了 Spring-web 的功能，并且导入了对应的 starter。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		SpringBoot 发现，既然你要做 web 程序，肯定离不开使用 web 服务器，这样吧，帮人帮到底，送佛送到西，我帮你搞一个 web 服务器，你要愿意用的，直接使用就好了。SpringBoot 又琢磨，提供一种服务器万一不满足开发者需要呢？干脆我再多给你几种选择，你随便切换。万一你不想用我给你提供的，也行，你可以自己搞。</p>
<p>​		由于这个功能不属于程序的主体功能，可用可不用，于是乎 SpringBoot 将其定位成辅助功能，别小看这么一个辅助功能，它可是帮我们开发者又减少了好多的设置性工作。</p>
<p>​		下面就围绕着这个内置的 web 服务器，也可以说是内置的 tomcat 服务器来研究几个问题：</p>
<ol>
<li>这个服务器在什么位置定义的</li>
<li>这个服务器是怎么运行的</li>
<li>这个服务器如果想换怎么换？虽然这个需求很垃圾，搞得开发者会好多 web 服务器一样，用别人提供好的不香么？非要自己折腾</li>
</ol>
<p><strong>内嵌 Tomcat 定义位置</strong></p>
<p>​		说到定义的位置，我们就想，如果我们不开发 web 程序，用的着 web 服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是 web 相关的功能啊，没错，就是前面导入的 web 相关的 starter 做的这件事。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		打开 web 对应的 starter 查看导入了哪些东西。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		第三个依赖就是 tomcat 对应的东西了，居然也是一个 starter，再打开看看。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-annotations-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-annotations-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		这里面有一个核心的坐标，tomcat-embed-core，叫做 tomcat 内嵌核心。就是这个东西把 tomcat 功能引入到了我们的程序中的。目前解决了第一个问题，找到根儿了，谁把 tomcat 引入到程序中的？spring-boot-starter-web 中的 spring-boot-starter-tomcat 做的。之所以你感觉很奇妙的原因就是，这个东西是默认加入到程序中了，所以感觉很神奇，居然什么都不做，就有了 web 服务器对应的功能。再来说第二个问题，这个服务器是怎么运行的。</p>
<p><strong>内嵌 Tomcat 运行原理</strong></p>
<p>​		Tomcat 服务器是一款软件，而且是一款使用 java 语言开发的软件，熟悉 tomcat 的话应该知道 tomcat 安装目录中保存有很多 jar 文件。</p>
<p>​		下面的问题来了，既然是使用 java 语言开发的，运行的时候肯定符合 java 程序运行的原理，java 程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那 tomcat 运行起来呢？也是对象啊。</p>
<p>​		如果是对象，那 Spring 容器是用来管理对象的，这个对象能交给 Spring 容器管理吗？把吗去掉，是个对象都可以交给 Spring 容器管理，行了，这下通了，tomcat 服务器运行其实是以对象的形式在 Spring 容器中运行的。怪不得我们没有安装这个 tomcat 但是还能用，闹了白天这东西最后是以一个对象的形式存在，保存在 Spring 容器中悄悄运行的。具体运行的是什么呢？其实就是上前面提到的那个 tomcat 内嵌核心。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		那既然是个对象，如果把这个对象从 Spring 容器中去掉是不是就没有 web 服务器的功能呢？是这样的，通过依赖排除可以去掉这个 web 服务器功能。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		上面对 web-starter 做了一个操作，使用 maven 的排除依赖去掉了使用 tomcat 的 starter。这下好了，容器中肯定没有这个对象了，重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后是一个一直运行的服务，而是直接停掉了，就是这个原因。</p>
<p><strong>更换内嵌 Tomcat</strong></p>
<p>​		那根据上面的操作我们思考是否可以换个服务器呢？必须的嘛。根据 SpringBoot 的工作机制，用什么技术，加入什么依赖就行了。SpringBoot 提供了 3 款内置的服务器：</p>
<ul>
<li>
<p>tomcat (默认)：apache 出品，粉丝多，应用面广，负载了若干较重的组件</p>
</li>
<li>
<p>jetty：更轻量级，负载性能远不及 tomcat</p>
</li>
<li>
<p>undertow：负载性能勉强跑赢 tomcat</p>
<p>想用哪个，加个坐标就 OK。前提是把 tomcat 排除掉，因为 tomcat 是默认加载的。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		现在就已经成功替换了 web 服务器，核心思想就是用什么加入对应坐标就可以了。如果有 starter，优先使用 starter。</p>
<p><strong>总结</strong></p>
<ol>
<li>内嵌 Tomcat 服务器是 SpringBoot 辅助功能之一</li>
<li>内嵌 Tomcat 工作原理是将 Tomcat 服务器作为对象运行，并将该对象交给 Spring 容器管理</li>
<li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li>
</ol>
<p>​		到这里第一章快速上手 SpringBoot 就结束了，这一章我们学习了两大块知识</p>
<ol>
<li>
<p>使用了 4 种方式制作了 SpringBoot 的入门程序，不管是哪一种，其实内部都是一模一样的</p>
</li>
<li>
<p>学习了入门程序的工作流程，知道什么是 parent，什么是 starter，这两个东西是怎么配合工作的，以及我们的程序为什么启动起来是一个 tomcat 服务器等等</p>
<p>第一章到这里就结束了，再往下学习就要去基于会创建 SpringBoot 工程的基础上，研究 SpringBoot 工程的具体细节了。</p>
</li>
</ol>
<h2 id="jc-2springboot基础配置"><a class="markdownIt-Anchor" href="#jc-2springboot基础配置">#</a> JC-2.SpringBoot 基础配置</h2>
<p>​		入门案例做完了，下面就要研究 SpringBoot 的用法了。通过入门案例，各位小伙伴能够感知到一个信息，SpringBoot 没有具体的功能，它是辅助加快 Spring 程序的开发效率的。我们发现，现在几乎不用做任何配置功能就有了，确实很好用。但是仔细想想，没有做配置意味着什么？意味着配置已经做好了，不用你自己写了。但是新的问题又来了，如果不想用已经写好的默认配置，该如何干预呢？这就是这一章咱们要研究的问题。</p>
<p>​		如果想修改默认的配置，这个信息应该写在什么位置呢？目前我们接触的入门案例中一共有 3 个文件，第一是 pom.xml 文件，设置项目的依赖，这个没什么好研究的，相关的高级内容咱们到原理篇再说，第二是引导类，这个是执行 SpringBoot 程序的入口，也不像是做功能配置的地方，其实还有一个信息，就是在 resources 目录下面有一个空白的文件，叫做 application.properties。一看就是个配置文件，咱们这一章就来说说配置文件怎么写，能写什么，怎么覆盖 SpringBoot 的默认配置修改成自己的配置。</p>
<p>​</p>
<h3 id="jc-2-1属性配置"><a class="markdownIt-Anchor" href="#jc-2-1属性配置">#</a> JC-2-1. 属性配置</h3>
<p>​		SpringBoot 通过配置文件 application.properties 就可以修改默认的配置，那咱们就先找个简单的配置下手，当前访问 tomcat 的默认端口是 8080，好熟悉的味道，但是不便于书写，我们先改成 80，通过这个操作来熟悉一下 SpringBoot 的配置格式是什么样的。</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211123165428245.png" alt="image-20211123165428245"></p>
<p>​		那该如何写呢？properties 格式的文件书写规范是 key=value</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">itheima</span></span><br></pre></td></tr></table></figure>
<p>​		这个格式肯定是不能颠覆的，那就尝试性的写就行了，改端口，写 port。当你输入 port 后，神奇的事情就发生了，这玩意儿带提示，太好了。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211123165719091.png" alt="image-20211123165719091" style="zoom:80%;">
<p>​		根据提示敲回车，输入 80 端口，搞定。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure>
<p>​		下面就可以直接运行程序，测试效果了。</p>
<p>​		我们惊奇的发现 SpringBoot 这玩意儿狠啊，以前修改端口在哪里改？tomcat 服务器的配置文件中改，现在呢？SpringBoot 专用的配置文件中改，是不是意味着以后所有的配置都可以写在这一个文件中呢？是的，简化开发者配置的书写位置，集中管理。妙啊，妈妈再也不用担心我找不到配置文件了。</p>
<p>​		其实到这里我们应该得到如下三个信息：</p>
<ol>
<li>SpringBoot 程序可以在 application.properties 文件中进行属性配置</li>
<li>application.properties 文件中只要输入要配置的属性关键字就可以根据提示进行设置</li>
<li>SpringBoot 将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li>SpringBoot 默认配置文件是 application.properties</li>
</ol>
<p>​		做完了端口的配置，趁热打铁，再做几个配置，目前项目启动时会显示一些日志信息，就来改一改这里面的一些设置。</p>
<p><strong>关闭运行日志图表（banner)</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.main.banner-mode</span>=<span class="string">off</span></span><br></pre></td></tr></table></figure>
<p><strong>设置运行日志的显示级别</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.root</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure>
<p>​		你会发现，现在这么搞配置太爽了，以前你做配置怎么做？不同的技术有自己专用的配置文件，文件不同格式也不统一，现在呢？不用东奔西走的找配置文件写配置了，统一格式了，这就是大秦帝国啊，统一六国。SpringBoot 比大秦狠，因为未来出现的技术还没出现呢，但是现在已经确认了，配置都写这个文件里面。</p>
<p>​		我们现在配置了 3 个信息，但是又有新的问题了。这个配置是随便写的吗？什么都能配？有没有一个东西显示所有能配置的项呢？此外这个配置和什么东西有关呢？会不会因为我写了什么东西以后才可以写什么配置呢？比如我现在没有写数据库相关的东西，能否配置数据呢？一个一个来，先说第一个问题，都能配置什么。</p>
<p>​		打开 SpringBoot 的官网，找到 SpringBoot 官方文档，打开查看附录中的 Application Properties 就可以获取到对应的配置项了，网址奉上：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties</a></p>
<p>​		能写什么的问题解决了，再来说第二个问题，这个配置项和什么有关。在 pom 中注释掉导入的 spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。也合理，不然没有使用对应技术，配了也是白配。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		所有的 starter 中都会依赖下面这个 starter，叫做 spring-boot-starter。这个 starter 是所有的 SpringBoot 的 starter 的基础依赖，里面定义了 SpringBoot 相关的基础配置，关于这个 starter 我们到开发应用篇和原理篇中再深入讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.5</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>SpringBoot 中导入对应 starter 后，提供对应配置属性</li>
<li>书写 SpringBoot 配置采用关键字 + 提示形式书写</li>
</ol>
<h3 id="jc-2-2配置文件分类"><a class="markdownIt-Anchor" href="#jc-2-2配置文件分类">#</a> JC-2-2. 配置文件分类</h3>
<p>​		现在已经能够进行 SpringBoot 相关的配置了，但是 properties 格式的配置写起来总是觉得看着不舒服，所以就期望存在一种书写起来更简便的配置格式提供给开发者使用。有吗？还真有，SpringBoot 除了支持 properties 格式的配置文件，还支持另外两种格式的配置文件。三种配置文件格式分别如下:</p>
<ul>
<li>properties 格式</li>
<li>yml 格式</li>
<li>yaml 格式</li>
</ul>
<p>​		一看到全新的文件格式，各位小伙伴肯定想，这下又要学习新的语法格式了。怎么说呢？从知识角度来说，要学，从开发角度来说，不用学。为什么呢？因为 SpringBoot 的配置在 Idea 工具下有提示啊，跟着提示走就行了。下面列举三种不同文件格式配置相同的属性范例，先了解一下。</p>
<ul>
<li>application.properties（properties 格式）</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure>
<ul>
<li>application.yml（yml 格式）</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>
<ul>
<li>application.yaml（yaml 格式）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>
<p>​		仔细看会发现 yml 格式和 yaml 格式除了文件名后缀不一样，格式完全一样，是这样的，yml 和 yaml 文件格式就是一模一样的，只是文件后缀不同，所以可以合并成一种格式来看。那对于这三种格式来说，以后用哪一种比较多呢？记清楚，以后基本上都是用 yml 格式的，本课程后面的所有知识都是基于 yml 格式来制作的，以后在企业开发过程中用这个格式的机会也最多，一定要重点掌握。</p>
<p><strong>总结</strong></p>
<ol>
<li>SpringBoot 提供了 3 种配置文件的格式
<ul>
<li>properties（传统格式 / 默认格式）</li>
<li><strong>yml</strong>（主流格式）</li>
<li>yaml</li>
</ul>
</li>
</ol>
<p><strong>思考</strong></p>
<p>​		现在我们已经知道使用三种格式都可以做配置了，好奇宝宝们就有新的灵魂拷问了，万一我三个都写了，他们三个谁说了算呢？打一架吗？</p>
<h4 id="配置文件优先级"><a class="markdownIt-Anchor" href="#配置文件优先级">#</a> 配置文件优先级</h4>
<p>​		其实三个文件如果共存的话，谁生效说的就是配置文件加载的优先级别。先说一点，虽然以后这种情况很少出现，但是这个知识还是可以学习一下的。我们就让三个配置文件书写同样的信息，比如都配置端口，然后我们让每个文件配置的端口号都不一样，最后启动程序后看启动端口是多少就知道谁的加载优先级比较高了。</p>
<ul>
<li>application.properties（properties 格式）</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure>
<ul>
<li>application.yml（yml 格式）</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>
<ul>
<li>application.yaml（yaml 格式）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>
<p>​		启动后发现目前的启动端口为 80，把 80 对应的文件删除掉，然后再启动，现在端口又改成了 81。现在我们就已经知道了 3 个文件的加载优先顺序是什么。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">application.properties  &gt;  application.yml  &gt;  application.yaml</span><br></pre></td></tr></table></figure>
<p>​		虽然得到了一个知识结论，但是我们实际开发的时候还是要看最终的效果为准。也就是你要的最终效果是什么自己是明确的，上述结论只能帮助你分析结论产生的原因。这个知识了解一下就行了，因为以后同时写多种配置文件格式的情况实在是较少。</p>
<p>​		最后我们把配置文件内容给修改一下</p>
<ul>
<li>application.properties（properties 格式）</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">80</span></span><br><span class="line"><span class="meta">spring.main.banner-mode</span>=<span class="string">off</span></span><br></pre></td></tr></table></figure>
<ul>
<li>application.yml（yml 格式）</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br><span class="line"><span class="attr">logging:</span> </span><br><span class="line">  <span class="attr">level:</span> </span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>
<ul>
<li>application.yaml（yaml 格式）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>
<p>​		我们发现不仅端口生效了，最终显示 80，同时其他两条配置也生效了，看来每个配置文件中的项都会生效，只不过如果多个配置文件中有相同类型的配置会优先级高的文件覆盖优先级的文件中的配置。如果配置项不同的话，所有的配置项都会生效。</p>
<p><strong>总结</strong></p>
<ol>
<li>配置文件间的加载优先级	properties（最高）&gt;  yml  &gt;  yaml（最低）</li>
<li>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</li>
</ol>
<h4 id="教你一招自动提示功能消失解决方案"><a class="markdownIt-Anchor" href="#教你一招自动提示功能消失解决方案">#</a> 教你一招：<strong>自动提示功能消失解决方案</strong></h4>
<p>​		在做程序的过程中，可能有些小伙伴会基于各种各样的原因导致配置文件中没有提示，这个确实很让人头疼，所以下面给大家说一下如果自动提示功能消失了怎么解决。</p>
<p>​		先要明确一个核心，就是自动提示功能不是 SpringBoot 技术给我们提供的，是我们在 Idea 工具下编程，这个编程工具给我们提供的。明白了这一点后，再来说为什么会出现这种现象。其实这个自动提示功能消失的原因还是蛮多的，如果想解决这个问题，就要知道为什么会消失，大体原因有如下 2 种：</p>
<ol>
<li>
<p>Idea 认为你现在写配置的文件不是个配置文件，所以拒绝给你提供提示功能</p>
</li>
<li>
<p>Idea 认定你是合理的配置文件，但是 Idea 加载不到对应的提示信息</p>
<p>这里我们主要解决第一个现象，第二种现象到原理篇再讲解。第一种现象的解决方式如下：</p>
</li>
</ol>
<p><strong>步骤①</strong>：打开设置，【Files】→【Project Structure…】</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126160548690.png" alt="image-20211126160548690"></p>
<p><strong>步骤②</strong>：在弹出窗口中左侧选择【Facets】，右侧选中 Spring 路径下对应的模块名称，也就是你自动提示功能消失的那个模块</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126160726589.png" alt="image-20211126160726589" style="zoom:67%;"><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126160844372.png" alt="image-20211126160844372"></p>
<p><strong>步骤③</strong>：点击 Customize Spring Boot 按钮，此时可以看到当前模块对应的配置文件是哪些了。如果没有你想要称为配置文件的文件格式，就有可能无法弹出提示</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126160946448.png" alt="image-20211126160946448"><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126160954338.png" alt="image-20211126160954338" style="zoom:80%;"></p>
<p><strong>步骤④</strong>：选择添加配置文件，然后选中要作为配置文件的具体文件就 OK 了</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126161145082.png" alt="image-20211126161145082" style="zoom:80%;"><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126161156324.png" alt="image-20211126161156324" style="zoom: 67%;"></p>
<p>​		到这里就做完了，其实就是 Idea 的一个小功能</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126161301699.png" alt="image-20211126161301699"></p>
<p><strong>总结</strong></p>
<ol>
<li>
<p>指定 SpringBoot 配置文件</p>
<ul>
<li>Setting → Project Structure → Facets</li>
<li>选中对应项目 / 工程</li>
<li>Customize Spring Boot</li>
<li>选择配置文件</li>
</ul>
</li>
</ol>
<h3 id="jc-2-3yaml文件"><a class="markdownIt-Anchor" href="#jc-2-3yaml文件">#</a> JC-2-3.yaml 文件</h3>
<p>​		SpringBoot 的配置以后主要使用 yml 结尾的这种文件格式，并且在书写时可以通过提示的形式加载正确的格式。但是这种文件还是有严格的书写格式要求的。下面就来说一下具体的语法格式。</p>
<p>​		YAML（YAML Ain’t Markup Language），一种数据序列化格式。具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。常见的文件扩展名有两种：</p>
<ul>
<li>
<p>.yml 格式（主流）</p>
</li>
<li>
<p>.yaml 格式</p>
<p>具体的语法格式要求如下：</p>
</li>
</ul>
<ol>
<li>大小写敏感</li>
<li>属性层级关系使用多行描述，<strong>每行结尾使用冒号结束</strong></li>
<li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用 Tab 键）</li>
<li>属性值前面添加空格（属性名与属性值之间使用冒号 + 空格作为分隔）</li>
<li>#号 表示注释</li>
</ol>
<p>​		上述规则不要死记硬背，按照书写习惯慢慢适应，并且在 Idea 下由于具有提示功能，慢慢适应着写格式就行了。核心的一条规则要记住，<font color="#ff0000"><b>数据前面要加空格与冒号隔开</b></font>。</p>
<p>​		下面列出常见的数据书写格式，熟悉一下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">boolean:</span> <span class="literal">TRUE</span>  						<span class="comment">#TRUE,true,True,FALSE,false，False均可</span></span><br><span class="line"><span class="attr">float:</span> <span class="number">3.14</span>    						<span class="comment">#6.8523015e+5  #支持科学计数法</span></span><br><span class="line"><span class="attr">int:</span> <span class="number">123</span>       						<span class="comment">#0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制</span></span><br><span class="line"><span class="attr">null:</span> <span class="string">~</span>        						<span class="comment">#使用~表示null</span></span><br><span class="line"><span class="attr">string:</span> <span class="string">HelloWorld</span>      			<span class="comment">#字符串可以直接书写</span></span><br><span class="line"><span class="attr">string2:</span> <span class="string">&quot;Hello World&quot;</span>  			<span class="comment">#可以使用双引号包裹特殊字符</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-02-17</span>        			<span class="comment">#日期必须使用yyyy-MM-dd格式</span></span><br><span class="line"><span class="attr">datetime:</span> <span class="number">2018-02-17T15:02:31+08:00</span>  <span class="comment">#时间和日期之间使用T连接，最后使用+代表时区</span></span><br></pre></td></tr></table></figure>
<p>​		此外，yaml 格式中也可以表示数组，在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">subject:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">前端</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">大数据</span></span><br><span class="line"><span class="attr">enterprise:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">itcast</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">16</span></span><br><span class="line">    <span class="attr">subject:</span></span><br><span class="line">    	<span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">前端</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">大数据</span></span><br><span class="line"><span class="attr">likes:</span> [<span class="string">王者荣耀</span>,<span class="string">刺激战场</span>]			<span class="comment">#数组书写缩略格式</span></span><br><span class="line"><span class="attr">users:</span>							 <span class="comment">#对象数组格式一</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line">   	<span class="attr">age:</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Jerry</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">users:</span>							 <span class="comment">#对象数组格式二</span></span><br><span class="line">  <span class="bullet">-</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span>   </span><br><span class="line">    <span class="attr">name:</span> <span class="string">Jerry</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span>			    </span><br><span class="line"><span class="attr">users2:</span> [ &#123; <span class="string">name:Tom</span> , <span class="string">age:4</span> &#125; , &#123; <span class="string">name:Jerry</span> , <span class="string">age:5</span> &#125; ]	<span class="comment">#对象数组缩略格式</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>yaml 语法规则
<ul>
<li>大小写敏感</li>
<li>属性层级关系使用多行描述，每行结尾使用冒号结束</li>
<li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用 Tab 键）</li>
<li>属性值前面添加空格（属性名与属性值之间使用冒号 + 空格作为分隔）</li>
<li>#号 表示注释</li>
</ul>
</li>
<li>注意属性名冒号后面与数据之间有一个<strong>空格</strong></li>
<li>字面值、对象数据格式、数组数据格式</li>
</ol>
<p><strong>思考</strong></p>
<p>​		现在我们已经知道了 yaml 具有严格的数据格式要求，并且已经可以正确的书写 yaml 文件了，那这些文件书写后其实是在定义一些数据。这些数据是给谁用的呢？大部分是 SpringBoot 框架内部使用，但是如果我们想配置一些数据自己使用，能不能用呢？答案是可以的，那如何读取 yaml 文件中的数据呢？咱们下一节再说。</p>
<h3 id="jc-2-4yaml数据读取"><a class="markdownIt-Anchor" href="#jc-2-4yaml数据读取">#</a> JC-2-4.yaml 数据读取</h3>
<p>​		对于 yaml 文件中的数据，其实你就可以想象成这就是一个小型的数据库，里面保存有若干数据，每个数据都有一个独立的名字，如果你想读取里面的数据，肯定是支持的，下面就介绍 3 种读取数据的方式。</p>
<h4 id="读取单一数据"><a class="markdownIt-Anchor" href="#读取单一数据">#</a> 读取单一数据</h4>
<p>​		yaml 中保存的单个数据，可以使用 Spring 中的注解 @Value 读取单个数据，属性名引用方式：<font color="#ff0000"><b>${一级属性名。二级属性名……}</b></font></p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126180433356.png" alt="image-20211126180433356" style="zoom:80%;">
<p>​		记得使用 @Value 注解时，要将该注解写在某一个指定的 Spring 管控的 bean 的属性名上方，这样当 bean 进行初始化时候就可以读取到对应的单一数据了。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用 @Value 配合 SpEL 读取单个数据</li>
<li>如果数据存在多层级，依次书写层级名称即可</li>
</ol>
<h4 id="读取全部数据"><a class="markdownIt-Anchor" href="#读取全部数据">#</a> 读取全部数据</h4>
<p>​		读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，SpringBoot 提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做 Environment，使用自动装配注解可以将所有的 yaml 数据封装到这个对象中</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126180738569.png" alt="image-20211126180738569" style="zoom:80%;">
<p>​		数据封装到了 Environment 对象中，获取属性时，通过 Environment 的接口操作进行，具体方法是 getProperties（String），参数填写属性名即可</p>
<p><strong>总结</strong></p>
<ol>
<li>使用 Environment 对象封装全部配置信息</li>
<li>使用 @Autowired 自动装配数据到 Environment 对象中</li>
</ol>
<h4 id="读取对象数据"><a class="markdownIt-Anchor" href="#读取对象数据">#</a> 读取对象数据</h4>
<p>​		单一数据读取书写比较繁琐，全数据读取封装的太厉害了，每次拿数据还要一个一个的 getProperties（）, 总之用起来都不是很舒服。由于 Java 是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。SpringBoot 也提供了可以将一组 yaml 对象数据封装一个 Java 对象的操作</p>
<p>​		首先定义一个对象，并将该对象纳入 Spring 管控的范围，也就是定义成一个 bean，然后使用注解 @ConfigurationProperties 指定该对象加载哪一组 yaml 中配置的信息。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126181126382.png" alt="image-20211126181126382" style="zoom:80%;">
<p>​		这个 @ConfigurationProperties 必须告诉他加载的数据前缀是什么，这样指定前缀下的所有属性就封装到这个对象中。记得数据属性名要与对象的变量名一一对应啊，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可。</p>
<p>​	<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126181423432.png" alt="image-20211126181423432" style="zoom:80%;"></p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		细心的小伙伴会发现一个问题，自定义的这种数据在 yaml 文件中书写时没有弹出提示，咱们到原理篇再揭秘如何弹出提示。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用 @ConfigurationProperties 注解绑定配置信息到封装类中</li>
<li>封装类需要定义为 Spring 管理的 bean，否则无法进行属性注入</li>
</ol>
<h4 id="yaml文件中的数据引用"><a class="markdownIt-Anchor" href="#yaml文件中的数据引用">#</a> yaml 文件中的数据引用</h4>
<p>​		如果你在书写 yaml 数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">center:</span></span><br><span class="line">	<span class="attr">dataDir:</span> <span class="string">/usr/local/fire/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">/usr/local/fire/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">/usr/local/fire/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">/usr/local/fire/msgDir</span></span><br></pre></td></tr></table></figure>
<p>​		或者</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">center:</span></span><br><span class="line">	<span class="attr">dataDir:</span> <span class="string">D:/usr/local/fire/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">D:/usr/local/fire/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">D:/usr/local/fire/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">D:/usr/local/fire/msgDir</span></span><br></pre></td></tr></table></figure>
<p>​		这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baseDir:</span> <span class="string">/usr/local/fire</span></span><br><span class="line"><span class="attr">center:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">$&#123;baseDir&#125;/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">$&#123;baseDir&#125;/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">$&#123;baseDir&#125;/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">$&#123;baseDir&#125;/msgDir</span></span><br></pre></td></tr></table></figure>
<p>​	还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">lesson:</span> <span class="string">&quot;Spring\tboot\nlesson&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>在配置文件中可以使用 ${属性名} 方式引用属性值</li>
<li>如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析</li>
</ol>
<p>​		到这里有关 yaml 文件的基础使用就先告一段落，实用篇中再继续研究更深入的内容。</p>
<h2 id="jc-3基于springboot实现ssmp整合"><a class="markdownIt-Anchor" href="#jc-3基于springboot实现ssmp整合">#</a> JC-3. 基于 SpringBoot 实现 SSMP 整合</h2>
<p>​		重头戏来了，SpringBoot 之所以好用，就是它能方便快捷的整合其他技术，这一部分咱们就来聊聊一些技术的整合方式，通过这一章的学习，大家能够感受到 SpringBoot 到底有多酷炫。这一章咱们学习如下技术的整合方式</p>
<ul>
<li>
<p>整合 JUnit</p>
</li>
<li>
<p>整合 MyBatis</p>
</li>
<li>
<p>整合 MyBatis-Plus</p>
</li>
<li>
<p>整合 Druid</p>
<p>上面这些技术都整合完毕后，我们做一个小案例，也算是学有所用吧。涉及的技术比较多，综合运用一下。</p>
</li>
</ul>
<h3 id="jc-3-1整合junit"><a class="markdownIt-Anchor" href="#jc-3-1整合junit">#</a> JC-3-1. 整合 JUnit</h3>
<p>​		SpringBoot 技术的定位用于简化开发，再具体点是简化 Spring 程序的开发。所以在整合任意技术的时候，如果你想直观感触到简化的效果，你必须先知道使用非 SpringBoot 技术时对应的整合是如何做的，然后再看基于 SpringBoot 的整合是如何做的，才能比对出来简化在了哪里。</p>
<p>​		我们先来看一下不使用 SpringBoot 技术时，Spring 整合 JUnit 的制作方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载spring整合junit专用的类运行器</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//指定对应的配置信息</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTestCase</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        System.out.println(accountService.findById(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​		其中核心代码是前两个注解，第一个注解 @RunWith 是设置 Spring 专用的测试类运行器，简单说就是 Spring 程序执行程序有自己的一套独立的运行程序的方式，不能使用 JUnit 提供的类运行方式了，必须指定一下，但是格式是固定的，琢磨一下，<font color="#ff0000"><b>每次都指定一样的东西，这个东西写起来没有技术含量啊</b></font>，第二个注解 @ContextConfiguration 是用来设置 Spring 核心配置文件或配置类的，简单说就是加载 Spring 的环境你要告诉 Spring 具体的环境配置是在哪里写的，虽然每次加载的文件都有可能不同，但是仔细想想，如果文件名是固定的，这个貌似也是一个固定格式。既然<font color="#ff0000"><b>有可能是固定格式，那就有可能每次都写一样的东西，也是一个没有技术含量的内容书写</b></font></p>
<p>​		SpringBoot 就抓住上述两条没有技术含量的内容书写进行开发简化，能走默认值的走默认值，能不写的就不写，具体格式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot04JunitApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;two...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		看看这次简化成什么样了，一个注解就搞定了，而且还没有参数，再体会 SpringBoot 整合其他技术的优势在哪里，就两个字 ——<font color="#ff0000"><b>简化</b></font>。使用一个注解 @SpringBootTest 替换了前面两个注解。至于内部是怎么回事？和之前一样，只不过都走默认值。</p>
<p>​		这个时候有人就问了，你加载的配置类或者配置文件是哪一个？就是我们前面启动程序使用的引导类。如果想手工指定引导类有两种方式，第一种方式使用属性的形式进行，在注解 @SpringBootTest 中添加 classes 属性指定配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = Springboot04JunitApplication.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot04JunitApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;two...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		第二种方式回归原始配置方式，仍然使用 @ContextConfiguration 注解进行，效果是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = Springboot04JunitApplication.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot04JunitApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;two...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		使用 SpringBoot 整合 JUnit 需要保障导入 test 对应的 starter，由于初始化项目时此项是默认导入的，所以此处没有提及，其实和之前学习的内容一样，用什么技术导入对应的 starter 即可。</p>
<p><strong>总结</strong></p>
<ol>
<li>导入测试对应的 starter</li>
<li>测试类使用 @SpringBootTest 修饰</li>
<li>使用自动装配的形式添加要测试的对象</li>
<li>测试类如果存在于引导类所在包或子包中无需指定引导类</li>
<li>测试类如果不存在于引导类所在的包或子包中需要通过 classes 属性指定引导类</li>
</ol>
<h3 id="jc-3-2整合mybatis"><a class="markdownIt-Anchor" href="#jc-3-2整合mybatis">#</a> JC-3-2. 整合 MyBatis</h3>
<p>​		整合完 JUnit 下面再来说一下整合 MyBatis，这个技术是大部分公司都要使用的技术，务必掌握。如果对 Spring 整合 MyBatis 不熟悉的小伙伴好好复习一下，下面列举出原始整合的全部内容，以配置类的形式为例进行</p>
<ul>
<li>
<p>导入坐标，MyBatis 坐标不能少，Spring 整合 MyBatis 还有自己专用的坐标，此外 Spring 进行数据库操作的 jdbc 坐标是必须的，剩下还有 mysql 驱动坐标，本例中使用了 Druid 数据源，这个倒是可以不要</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.导入mybatis与spring整合的jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入spring操作数据库必选的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Spring 核心配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>MyBatis 要交给 Spring 接管的 bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义mybatis专用的配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">//    定义创建SqlSessionFactory对应的bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="comment">//SqlSessionFactoryBean是由mybatis-spring包提供的，专用于整合用的对象</span></span><br><span class="line">        SqlSessionFactoryBean sfb = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        <span class="comment">//设置数据源替代原始配置中的environments的配置</span></span><br><span class="line">        sfb.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//设置类型别名替代原始配置中的typeAliases的配置</span></span><br><span class="line">        sfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sfb;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    定义加载所有的映射配置</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MapperScannerConfigurer <span class="title">mapperScannerConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MapperScannerConfigurer msc = <span class="keyword">new</span> MapperScannerConfigurer();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数据源对应的 bean，此处使用 Druid 数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource ds = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数据库连接信息（properties 格式）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring_db?useSSL=false</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>上述格式基本上是最简格式了，要写的东西还真不少。下面看看 SpringBoot 整合 MyBaits 格式</p>
</li>
</ul>
<p><strong>步骤①</strong>：创建模块</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129092156020.png" alt="image-20211129092156020"></p>
<p><strong>步骤②</strong>：勾选要使用的技术，MyBatis，由于要操作数据库，还要勾选对应数据库</p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129092210993.png" alt="image-20211129092210993"></p>
<p>​	或者手工导入对应技术的 starter，和对应数据库的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.导入对应的starter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：配置数据源相关信息，没有这个信息你连接哪个数据库都不知道</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>​		结束了，就这么多，没了。有人就很纳闷，这就结束了？对，这就结束了，SpringBoot 把配置中所有可能出现的通用配置都简化了。下面写一个 MyBatis 程序运行需要的 Dao（或者 Mapper）就可以运行了</p>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>映射接口（Dao）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot05MybatisApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(bookDao.getById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		完美，开发从此变的就这么简单。再体会一下 SpringBoot 如何进行第三方技术整合的，是不是很优秀？具体内部的原理到原理篇再展开讲解</p>
<p>​		<font color="#ff0000"><b>注意</b></font>：当前使用的 SpringBoot 版本是 2.5.4，对应的坐标设置中 Mysql 驱动使用的是 8x 版本。使用 SpringBoot2.4.3（不含）之前版本会出现一个小 BUG，就是 MySQL 驱动升级到 8 以后要求强制配置时区，如果不设置会出问题。解决方案很简单，驱动 url 上面添加上对应设置就行了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>​		这里设置的 UTC 是全球标准时间，你也可以理解为是英国时间，中国处在东八区，需要在这个基础上加上 8 小时，这样才能和中国地区的时间对应的，也可以修改配置为 Asia/Shanghai，同样可以解决这个问题。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>​		如果不想每次都设置这个东西，也可以去修改 mysql 中的配置文件 mysql.ini，在 mysqld 项中添加 default-time-zone=+8:00 也可以解决这个问题。其实方式方法很多，这里就说这么多吧。</p>
<p>​		此外在运行程序时还会给出一个提示，说数据库驱动过时的警告，根据提示修改配置即可，弃用<strong> com.mysql.jdbc.Driver</strong>，换用<font color="#ff0000"><b>com.mysql.cj.jdbc.Driver</b></font>。前面的例子中已经更换了驱动了，在此说明一下。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Loading class `com.mysql.jdbc.Driver&#x27;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&#x27;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>
<p>整合操作需要勾选 MyBatis 技术，也就是导入 MyBatis 对应的 starter</p>
</li>
<li>
<p>数据库连接相关信息转换成配置</p>
</li>
<li>
<p>数据库 SQL 映射需要添加 @Mapper 被容器识别到</p>
</li>
<li>
<p>MySQL 8.X 驱动强制要求设置时区</p>
<ul>
<li>修改 url，添加 serverTimezone 设定</li>
<li>修改 MySQL 数据库配置</li>
</ul>
</li>
<li>
<p>驱动类过时，提醒更换为 com.mysql.cj.jdbc.Driver</p>
</li>
</ol>
<h3 id="jc-3-3整合mybatis-plus"><a class="markdownIt-Anchor" href="#jc-3-3整合mybatis-plus">#</a> JC-3-3. 整合 MyBatis-Plus</h3>
<p>​		做完了两种技术的整合了，各位小伙伴要学会总结，我们做这个整合究竟哪些是核心？总结下来就两句话</p>
<ul>
<li>
<p>导入对应技术的 starter 坐标</p>
</li>
<li>
<p>根据对应技术的要求做配置</p>
<p>虽然看起来有点虚，但是确实是这个理儿，下面趁热打铁，再换一个技术，看看是不是上面这两步。</p>
</li>
</ul>
<p>​		接下来在 MyBatis 的基础上再升级一下，整合 MyBaitsPlus（简称 MP），国人开发的技术，符合中国人开发习惯，谁用谁知道。来吧，一起做整合</p>
<p><strong>步骤①</strong>：导入对应的 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		关于这个坐标，此处要说明一点，之前我们看的 starter 都是 spring-boot-starter-？？？，也就是说都是下面的格式</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Spring-boot-start-***</span><br></pre></td></tr></table></figure>
<p>​	而 MyBatis 与 MyBatisPlus 这两个坐标的名字书写比较特殊，是第三方技术名称在前，boot 和 starter 在后。此处简单提一下命名规范，后期原理篇会再详细讲解</p>
<table>
<thead>
<tr>
<th>starter 所属</th>
<th>命名规则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>官方提供</td>
<td>spring-boot-starter - 技术名称</td>
<td>spring-boot-starter-web <br>spring-boot-starter-test</td>
</tr>
<tr>
<td>第三方提供</td>
<td>第三方技术名称 - spring-boot-starter</td>
<td>mybatis-spring-boot-starter<br>druid-spring-boot-starter</td>
</tr>
<tr>
<td>第三方提供</td>
<td>第三方技术名称 - boot-starter（第三方技术名称过长，简化命名）</td>
<td>mybatis-plus-boot-starter</td>
</tr>
</tbody>
</table>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		有些小伙伴在创建项目时想通过勾选的形式找到这个名字，别翻了，没有。截止目前，SpringBoot 官网还未收录此坐标，而我们 Idea 创建模块时读取的是 SpringBoot 官网的 Spring Initializr，所以也没有。如果换用阿里云的 url 创建项目可以找到对应的坐标。</p>
<p><strong>步骤②</strong>：配置数据源相关信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>​	没了，就这么多，剩下的就是写 MyBaitsPlus 的程序了</p>
<p><strong>映射接口（Dao）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	核心在于 Dao 接口继承了一个 BaseMapper 的接口，这个接口中帮助开发者预定了若干个常用的 API 接口，简化了通用 API 接口的开发工作。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129100313919.png" alt="image-20211129100313919" style="zoom:80%;">
<p>​	下面就可以写一个测试类进行测试了，此处省略。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		目前数据库的表名定义规则是 tbl_模块名称，为了能和实体类相对应，需要做一个配置，相关知识各位小伙伴可以到 MyBatisPlus 课程中去学习，此处仅给出解决方案。配置 application.yml 文件，添加如下配置即可，设置所有表名的通用前缀名</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span>		<span class="comment">#设置所有表的通用前缀名称为tbl_</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>手工添加 MyBatis-Plus 对应的 starter</li>
<li>数据层接口使用 BaseMapper 简化开发</li>
<li>需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标</li>
</ol>
<h3 id="jc-3-4整合druid"><a class="markdownIt-Anchor" href="#jc-3-4整合druid">#</a> JC-3-4. 整合 Druid</h3>
<p>​		使用 SpringBoot 整合了 3 个技术了，发现套路基本相同，导入对应的 starter，然后做配置，各位小伙伴需要一直强化这套思想。下面再整合一个技术，继续深入强化此思想。</p>
<p>​		前面整合 MyBatis 和 MyBatisPlus 的时候，使用的数据源对象都是 SpringBoot 默认的数据源对象，下面我们手工控制一下，自己指定了一个数据源对象，Druid。</p>
<p>​		在没有指定数据源时，我们的配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>​		此时虽然没有指定数据源，但是根据 SpringBoot 的德行，肯定帮我们选了一个它认为最好的数据源对象，这就是 HiKari。通过启动日志可以查看到对应的身影。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">2021-11-29 09:39:15.202  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2021-11-29 09:39:15.208  WARN 12260 --- [           main] com.zaxxer.hikari.util.DriverDataSource  : Registered driver with driverClassName=com.mysql.jdbc.Driver was not found, trying direct instantiation.</span><br><span class="line">2021-11-29 09:39:15.551  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br></pre></td></tr></table></figure>
<p>​		上述信息中每一行都有 HiKari 的身影，如果需要更换数据源，其实只需要两步即可。</p>
<ol>
<li>
<p>导入对应的技术坐标</p>
</li>
<li>
<p>配置使用指定的数据源类型</p>
<p>下面就切换一下数据源对象</p>
</li>
</ol>
<p><strong>步骤①</strong>：导入对应的坐标（注意，是坐标，此处不是 starter）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：修改配置，在数据源配置中有一个 type 属性，专用于指定数据源类型</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure>
<p>​		这里其实要提出一个问题的，目前的数据源配置格式是一个通用格式，不管你换什么数据源都可以用这种形式进行配置。但是新的问题又来了，如果对数据源进行个性化的配置，例如配置数据源对应的连接数量，这个时候就有新的问题了。每个数据源技术对应的配置名称都一样吗？肯定不是啊，各个厂商不可能提前商量好都写一样的名字啊，怎么办？就要使用专用的配置格式了。这个时候上面这种通用格式就不能使用了，怎么办？还能怎么办？按照 SpringBoot 整合其他技术的通用规则来套啊，导入对应的 starter，进行相应的配置即可。</p>
<p><strong>步骤①</strong>：导入对应的 starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：修改配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>​		注意观察，配置项中，在 datasource 下面并不是直接配置 url 这些属性的，而是先配置了一个 druid 节点，然后再配置的 url 这些东西。言外之意，url 这个属性是 druid 下面的属性，那你能想到什么？除了这 4 个常规配置外，还有 druid 专用的其他配置。通过提示功能可以打开 druid 相关的配置查阅</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129112610729.png" alt="image-20211129112610729" style="zoom:80%;">
<p>​	与 druid 相关的配置超过 200 条以上，这就告诉你，如果想做 druid 相关的配置，使用这种格式就可以了，这里就不展开描述了，太多了。</p>
<p>​	这是我们做的第 4 个技术的整合方案，还是那两句话：<font color="#ff0000"><b>导入对应 starter，使用对应配置</b></font>。没了，SpringBoot 整合其他技术就这么简单粗暴。</p>
<p><strong>总结</strong></p>
<ol>
<li>整合 Druid 需要导入 Druid 对应的 starter</li>
<li>根据 Druid 提供的配置方式进行配置</li>
<li>整合第三方技术通用方式
<ul>
<li>导入对应的 starter</li>
<li>根据提供的配置格式，配置非默认值对应的配置项</li>
</ul>
</li>
</ol>
<h3 id="jc-3-5ssmp整合综合案例"><a class="markdownIt-Anchor" href="#jc-3-5ssmp整合综合案例">#</a> JC-3-5.SSMP 整合综合案例</h3>
<p>​		SpringBoot 能够整合的技术太多太多了，对于初学者来说慢慢来，一点点掌握。前面咱们做了 4 个整合了，下面就通过一个稍微综合一点的案例，将所有知识贯穿起来，同时做一个小功能，体会一下。不过有言在先，这个案例制作的时候，你可能会有这种感觉，说好的 SpringBoot 整合其他技术的案例，为什么感觉 SpringBoot 整合其他技术的身影不多呢？因为这东西书写太简单了，简单到瞬间写完，大量的时间做的不是这些整合工作。</p>
<p>​		先看一下这个案例的最终效果</p>
<p><strong>主页面</strong></p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113447844.png" alt="image-20211129113447844"></p>
<p><strong>添加</strong></p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113522459.png" alt="image-20211129113522459"></p>
<p><strong>删除</strong></p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113550829.png" alt="image-20211129113550829"></p>
<p><strong>修改</strong></p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113610966.png" alt="image-20211129113610966"></p>
<p><strong>分页</strong></p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113628969.png" alt="image-20211129113628969"></p>
<p><strong>条件查询</strong></p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113650369.png" alt="image-20211129113650369"></p>
<p>​	整体案例中需要采用的技术如下，先了解一下，做到哪一个说哪一个</p>
<ol>
<li>实体类开发 ———— 使用 Lombok 快速制作实体类</li>
<li>Dao 开发 ———— 整合 MyBatisPlus，制作数据层测试</li>
<li>Service 开发 ———— 基于 MyBatisPlus 进行增量开发，制作业务层测试类</li>
<li>Controller 开发 ———— 基于 Restful 开发，使用 PostMan 测试接口功能</li>
<li>Controller 开发 ———— 前后端开发协议制作</li>
<li>页面开发 ———— 基于 VUE+ElementUI 制作，前后端联调，页面数据处理，页面消息处理
<ul>
<li>列表</li>
<li>新增</li>
<li>修改</li>
<li>删除</li>
<li>分页</li>
<li>查询</li>
</ul>
</li>
<li>项目异常处理</li>
<li>按条件查询 ———— 页面功能调整、Controller 修正功能、Service 修正功能</li>
</ol>
<p>​		可以看的出来，东西还是很多的，希望通过这个案例，各位小伙伴能够完成基础开发的技能训练。整体开发过程采用做一层测一层的形式进行，过程完整，战线较长，希望各位能跟紧进度，完成这个小案例的制作。</p>
<h4 id="0模块创建"><a class="markdownIt-Anchor" href="#0模块创建">#</a> 0. 模块创建</h4>
<p>​		对于这个案例如果按照企业开发的形式进行应该制作后台微服务，前后端分离的开发。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129114306062.png" alt="image-20211129114306062" style="zoom:80%;">
<p>​		我知道这个对初学的小伙伴要求太高了，咱们简化一下。后台做单体服务器，前端不使用前后端分离的制作了。</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129114328967.png" alt="image-20211129114328967" style="zoom:80%;">
<p>​		一个服务器即充当后台服务调用，又负责前端页面展示，降低学习的门槛。</p>
<p>​		下面我们创建一个新的模块，加载要使用的技术对应的 starter，修改配置文件格式为 yml 格式，并把 web 访问端口先设置成 80。</p>
<p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<h4 id="1实体类开发"><a class="markdownIt-Anchor" href="#1实体类开发">#</a> 1. 实体类开发</h4>
<p>​		本案例对应的模块表结构如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for tbl<span class="built_in">_</span>book</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `tbl<span class="built_in">_</span>book`;</span><br><span class="line">CREATE TABLE `tbl<span class="built_in">_</span>book`  (</span><br><span class="line">  `id` int(11) NOT NULL AUTO<span class="built_in">_</span>INCREMENT,</span><br><span class="line">  `type` varchar(20) CHARACTER SET utf8 COLLATE utf8<span class="built_in">_</span>general<span class="built_in">_</span>ci NULL DEFAULT NULL,</span><br><span class="line">  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8<span class="built_in">_</span>general<span class="built_in">_</span>ci NULL DEFAULT NULL,</span><br><span class="line">  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8<span class="built_in">_</span>general<span class="built_in">_</span>ci NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO<span class="built_in">_</span>INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8<span class="built_in">_</span>general<span class="built_in">_</span>ci ROW<span class="built_in">_</span>FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of tbl<span class="built_in">_</span>book</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第5版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实战&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (3, &#x27;计算机理论&#x27;, &#x27;Spring 5 设计模式&#x27;, &#x27;深入Spring源码剖析Spring源码中蕴含的10大设计模式&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+MyBatis开发从入门到项目实战&#x27;, &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级剖析Spring框架，适合已掌握Java基础的读者&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷I 基础知识（原书第11版）&#x27;, &#x27;Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个维度全面剖析JVM，大厂面试知识点全覆盖&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想（第4版）&#x27;, &#x27;Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java（全彩版）&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (10, &#x27;市场营销&#x27;, &#x27;直播就该这么做：主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳琦、薇娅成长为网红的秘密都在书中&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (12, &#x27;市场营销&#x27;, &#x27;直播带货：淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure>
<p>​		根据上述表结构，制作对应的实体类</p>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		实体类的开发可以自动通过工具手工生成 get/set 方法，然后覆盖 toString () 方法，方便调试，等等。不过这一套操作书写很繁琐，有对应的工具可以帮助我们简化开发，介绍一个小工具，lombok。</p>
<p>​		Lombok，一个 Java 类库，提供了一组注解，简化 POJO 实体类开发，SpringBoot 目前默认集成了 lombok 技术，并提供了对应的版本控制，所以只需要提供对应的坐标即可，在 pom.xml 中添加 lombok 的坐标。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		使用 lombok 可以通过一个注解 @Data 完成一个实体类对应的 getter，setter，toString，equals，hashCode 等操作的快速添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		到这里实体类就做好了，是不是比不使用 lombok 简化好多，这种工具在 Java 开发中还有 N 多，后面遇到了能用的实用开发技术时，在不增加各位小伙伴大量的学习时间的情况下，尽量多给大家介绍一些。</p>
<p><strong>总结</strong></p>
<ol>
<li>实体类制作</li>
<li>使用 lombok 简化开发
<ul>
<li>导入 lombok 无需指定版本，由 SpringBoot 提供版本</li>
<li>@Data 注解</li>
</ul>
</li>
</ol>
<h4 id="2数据层开发基础crud"><a class="markdownIt-Anchor" href="#2数据层开发基础crud">#</a> 2. 数据层开发 —— 基础 CRUD</h4>
<p>​		数据层开发本次使用 MyBatisPlus 技术，数据源使用前面学习的 Druid，学都学了都用上。</p>
<p><strong>步骤①</strong>：导入 MyBatisPlus 与 Druid 对应的 starter，当然 mysql 的驱动不能少</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤②</strong>：配置数据库连接相关的数据源配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤③</strong>：使用 MyBatisPlus 的标准通用接口 BaseMapper 加速开发，别忘了 @Mapper 和泛型的指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤④</strong>：制作测试类测试结果，这个测试类制作是个好习惯，不过在企业开发中往往都为加速开发跳过此步，且行且珍惜吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.metadata.IPage;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Book;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testGetById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(bookDao.selectById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setType(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookDao.insert(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setId(<span class="number">17</span>);</span><br><span class="line">        book.setType(<span class="string">&quot;测试数据abcdefg&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookDao.updateById(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bookDao.deleteById(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testGetAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bookDao.selectList(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		MyBatisPlus 技术默认的主键生成策略为雪花算法，生成的主键 ID 长度较大，和目前的数据库设定规则不相符，需要配置一下使 MyBatisPlus 使用数据库的主键生成策略，方式嘛还是老一套，做配置。在 application.yml 中添加对应配置即可，具体如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span>		<span class="comment">#设置表名通用前缀</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span>				<span class="comment">#设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增</span></span><br></pre></td></tr></table></figure>
<h5 id="查看mybatisplus运行日志"><a class="markdownIt-Anchor" href="#查看mybatisplus运行日志">#</a> 查看 MyBatisPlus 运行日志</h5>
<p>​		在进行数据层测试的时候，因为基础的 CRUD 操作均由 MyBatisPlus 给我们提供了，所以就出现了一个局面，开发者不需要书写 SQL 语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装 SQL 语句这些操作完全不是你开发出来的，所以查看执行期运行的 SQL 语句就成为当务之急。</p>
<p>​		SpringBoot 整合 MyBatisPlus 的时候充分考虑到了这点，通过配置的形式就可以查阅执行期 SQL 语句，配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>
<p>​		再来看运行结果，此时就显示了运行期执行 SQL 的情况。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2c9a6717] was not registered for synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6ca30b8a] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: SELECT id,type,name,description FROM tbl<span class="built_in">_</span>book</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: id, type, name, description</span><br><span class="line">&lt;==        Row: 1, 计算机理论, Spring实战 第5版, Spring入门经典教程，深入理解Spring原理技术内幕</span><br><span class="line">&lt;==        Row: 2, 计算机理论, Spring 5核心原理与30个类手写实战, 十年沉淀之作，手写Spring精华思想</span><br><span class="line">&lt;==        Row: 3, 计算机理论, Spring 5 设计模式, 深入Spring源码剖析Spring源码中蕴含的10大设计模式</span><br><span class="line">&lt;==        Row: 4, 计算机理论, Spring MVC+MyBatis开发从入门到项目实战, 全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手</span><br><span class="line">&lt;==        Row: 5, 计算机理论, 轻量级Java Web企业应用实战, 源码级剖析Spring框架，适合已掌握Java基础的读者</span><br><span class="line">&lt;==        Row: 6, 计算机理论, Java核心技术 卷I 基础知识（原书第11版）, Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新</span><br><span class="line">&lt;==        Row: 7, 计算机理论, 深入理解Java虚拟机, 5个维度全面剖析JVM，大厂面试知识点全覆盖</span><br><span class="line">&lt;==        Row: 8, 计算机理论, Java编程思想（第4版）, Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉</span><br><span class="line">&lt;==        Row: 9, 计算机理论, 零基础学Java（全彩版）, 零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术</span><br><span class="line">&lt;==        Row: 10, 市场营销, 直播就该这么做：主播高效沟通实战指南, 李子柒、李佳琦、薇娅成长为网红的秘密都在书中</span><br><span class="line">&lt;==        Row: 11, 市场营销, 直播销讲实战一本通, 和秋叶一起学系列网络营销书籍</span><br><span class="line">&lt;==        Row: 12, 市场营销, 直播带货：淘宝、天猫直播从新手到高手, 一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+</span><br><span class="line">&lt;==        Row: 13, 测试类型, 测试数据, 测试描述数据</span><br><span class="line">&lt;==        Row: 14, 测试数据update, 测试数据update, 测试数据update</span><br><span class="line">&lt;==        Row: 15, -----------------, 测试数据123, 测试数据123</span><br><span class="line">&lt;==      Total: 15</span><br></pre></td></tr></table></figure>
<p>​		其中清晰的标注了当前执行的 SQL 语句是什么，携带了什么参数，对应的执行结果是什么，所有信息应有尽有。</p>
<p>​		此处设置的是日志的显示形式，当前配置的是控制台输出，当然还可以由更多的选择，根据需求切换即可</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129143207295.png" alt="image-20211129143207295" style="zoom:80%;">
<p><strong>总结</strong></p>
<ol>
<li>
<p>手工导入 starter 坐标（2 个），mysql 驱动（1 个）</p>
</li>
<li>
<p>配置数据源与 MyBatisPlus 对应的配置</p>
</li>
<li>
<p>开发 Dao 接口（继承 BaseMapper）</p>
</li>
<li>
<p>制作测试类测试 Dao 功能是否有效</p>
</li>
<li>
<p>使用配置方式开启日志，设置日志输出方式为标准输出即可查阅 SQL 执行日志</p>
</li>
</ol>
<h4 id="3数据层开发分页功能制作"><a class="markdownIt-Anchor" href="#3数据层开发分页功能制作">#</a> 3. 数据层开发 —— 分页功能制作</h4>
<p>​		前面仅仅是使用了 MyBatisPlus 提供的基础 CRUD 功能，实际上 MyBatisPlus 给我们提供了几乎所有的基础操作，这一节说一下如何实现数据库端的分页操作。</p>
<p>​		MyBatisPlus 提供的分页操作 API 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGetPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IPage page = <span class="keyword">new</span> Page(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    bookDao.selectPage(page, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(page.getCurrent());</span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    System.out.println(page.getRecords());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其中 selectPage 方法需要传入一个封装分页数据的对象，可以通过 new 的形式创建这个对象，当然这个对象也是 MyBatisPlus 提供的，别选错包了。创建此对象时需要指定两个分页的基本数据</p>
<ul>
<li>当前显示第几页</li>
<li>每页显示几条数据</li>
</ul>
<p>​		可以通过创建 Page 对象时利用构造方法初始化这两个数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IPage page = <span class="keyword">new</span> Page(<span class="number">2</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>​		将该对象传入到查询方法 selectPage 后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个 IPage 对象，这又是怎么回事？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IPage page = bookDao.selectPage(page, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>​		原来这个 IPage 对象中封装了若干个数据，而查询的结果作为 IPage 对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个 IPage 对象中，其实还是为了高度的封装，一个 IPage 描述了分页所有的信息。下面 5 个操作就是 IPage 对象中封装的所有信息了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGetPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IPage page = <span class="keyword">new</span> Page(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    bookDao.selectPage(page, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(page.getCurrent());		<span class="comment">//当前页码值</span></span><br><span class="line">    System.out.println(page.getSize());			<span class="comment">//每页显示数</span></span><br><span class="line">    System.out.println(page.getTotal());		<span class="comment">//数据总量</span></span><br><span class="line">    System.out.println(page.getPages());		<span class="comment">//总页数</span></span><br><span class="line">    System.out.println(page.getRecords());		<span class="comment">//详细数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		到这里就知道这些数据如何获取了，但是当你去执行这个操作时，你会发现并不像我们分析的这样，实际上这个分页功能当前是无效的。为什么这样呢？这个要源于 MyBatisPlus 的内部机制。</p>
<p>​		对于 MySQL 的分页操作使用 limit 关键字进行，而并不是所有的数据库都使用 limit 关键字实现的，这个时候 MyBatisPlus 为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，你可以理解为 IPhone6 与 IPhone6S-PLUS 的关系。</p>
<p>​		基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以 MyBatisPlus 将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过 MyBatisPlus 的拦截器的形式存在的，其中的原理这里不分析了，有兴趣的小伙伴可以学习 MyBatisPlus 这门课程进行详细解读。具体设置方式如下：</p>
<p><strong>定义 MyBatisPlus 拦截器并将其设置为 Spring 管控的 bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MPConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title">mybatisPlusInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = <span class="keyword">new</span> MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> PaginationInnerInterceptor());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		上述代码第一行是创建 MyBatisPlus 的拦截器栈，这个时候拦截器栈中没有具体的拦截器，第二行是初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续 add 进去新的拦截器就可以了。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用 IPage 封装分页数据</li>
<li>分页操作依赖 MyBatisPlus 分页拦截器实现功能</li>
<li>借助 MyBatisPlus 日志查阅执行 SQL 语句</li>
</ol>
<h4 id="4数据层开发条件查询功能制作"><a class="markdownIt-Anchor" href="#4数据层开发条件查询功能制作">#</a> 4. 数据层开发 —— 条件查询功能制作</h4>
<p>​		除了分页功能，MyBatisPlus 还提供有强大的条件查询功能。以往我们写条件查询要自己动态拼写复杂的 SQL 语句，现在简单了，MyBatisPlus 将这些操作都制作成 API 接口，调用一个又一个的方法就可以实现各种条件的拼装。这里给大家普及一下基本格式，详细的操作还是到 MyBatisPlus 的课程中查阅吧。</p>
<p>​		下面的操作就是执行一个模糊匹配对应的操作，由 like 条件书写变为了 like 方法的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGetBy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QueryWrapper&lt;Book&gt; qw = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    qw.like(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">    bookDao.selectList(qw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其中第一句 QueryWrapper 对象是一个用于封装查询条件的对象，该对象可以动态使用 API 调用的方法添加条件，最终转化成对应的 SQL 语句。第二句就是一个条件了，需要什么条件，使用 QueryWapper 对象直接调用对应操作即可。比如做大于小于关系，就可以使用 lt 或 gt 方法，等于使用 eq 方法，等等，此处不做更多的解释了。</p>
<p>​		这组 API 使用还是比较简单的，但是关于属性字段名的书写存在着安全隐患，比如查询字段 name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。</p>
<p>​		MyBatisPlus 针对字段检查进行了功能升级，全面支持 Lambda 表达式，就有了下面这组 API。由 QueryWrapper 对象升级为 LambdaQueryWrapper 对象，这下就避免了上述问题的出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGetBy2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;Book&gt; lqw = <span class="keyword">new</span> LambdaQueryWrapper&lt;Book&gt;();</span><br><span class="line">    lqw.like(Book::getName,name);</span><br><span class="line">    bookDao.selectList(lqw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		为了便于开发者动态拼写 SQL，防止将 null 数据作为条件使用，MyBatisPlus 还提供了动态拼装 SQL 的快捷书写方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGetBy2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;Book&gt; lqw = <span class="keyword">new</span> LambdaQueryWrapper&lt;Book&gt;();</span><br><span class="line">    <span class="comment">//if(name != null) lqw.like(Book::getName,name);		//方式一：JAVA代码控制</span></span><br><span class="line">    lqw.like(name != <span class="keyword">null</span>,Book::getName,name);				<span class="comment">//方式二：API接口提供控制开关</span></span><br><span class="line">    bookDao.selectList(lqw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其实就是个格式，没有区别。关于 MyBatisPlus 的基础操作就说到这里吧，如果这一块知识不太熟悉的小伙伴建议还是完整的学习一下 MyBatisPlus 的知识吧，这里只是蜻蜓点水的用了几个操作而已。</p>
<p><strong>总结</strong></p>
<ol>
<li>
<p>使用 QueryWrapper 对象封装查询条件</p>
</li>
<li>
<p>推荐使用 LambdaQueryWrapper 对象</p>
</li>
<li>
<p>所有查询操作封装成方法调用</p>
</li>
<li>
<p>查询条件支持动态条件拼装</p>
</li>
</ol>
<h4 id="5业务层开发"><a class="markdownIt-Anchor" href="#5业务层开发">#</a> 5. 业务层开发</h4>
<p>​		数据层开发告一段落，下面进行业务层开发，其实标准业务层开发很多初学者认为就是调用数据层，怎么说呢？这个理解是没有大问题的，更精准的说法应该是<font color="#ff0000"><b>组织业务逻辑功能，并根据业务需求，对数据持久层发起调用</b></font>。有什么差别呢？目标是为了组织出符合需求的业务逻辑功能，至于调不调用数据层还真不好说，有需求就调用，没有需求就不调用。</p>
<p>​		一个常识性的知识普及一下，业务层的方法名定义一定要与业务有关，例如登录操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">login(String username,String password);</span><br></pre></td></tr></table></figure>
<p>​		而数据层的方法名定义一定与业务无关，是一定，不是可能，也不是有可能，例如根据用户名密码查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectByUserNameAndPassword(String username,String password);</span><br></pre></td></tr></table></figure>
<p>​		我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">接口：传入用户名与密码字段，查询出对应结果，结果是单条数据</span><br><span class="line">接口：传入ID字段，查询出对应结果，结果是单条数据</span><br><span class="line">接口：传入离职字段，查询出对应结果，结果是多条数据</span><br></pre></td></tr></table></figure>
<p>​		但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对密码字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO<span class="built_in">_</span>LOGON<span class="built_in">_</span>USERNAME<span class="built_in">_</span>PASSWORD<span class="built_in">_</span>ERROR</span><br></pre></td></tr></table></figure>
<p>​		你比较一下，能是一回事吗？差别太大了，所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的 ISO 标准化文档而已。</p>
<p>​		多余的话不说了，咱们做案例就简单制作了，业务层接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="function">Boolean <span class="title">save</span><span class="params">(Book book)</span></span>;</span><br><span class="line">    <span class="function">Boolean <span class="title">update</span><span class="params">(Book book)</span></span>;</span><br><span class="line">    <span class="function">Boolean <span class="title">delete</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">Book <span class="title">getById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">IPage&lt;Book&gt; <span class="title">getPage</span><span class="params">(<span class="keyword">int</span> currentPage,<span class="keyword">int</span> pageSize)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		业务层实现类如下，转调数据层即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">save</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.insert(book) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">update</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.updateById(book) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.deleteById(id) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.selectList(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPage&lt;Book&gt; <span class="title">getPage</span><span class="params">(<span class="keyword">int</span> currentPage, <span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">        IPage page = <span class="keyword">new</span> Page(currentPage,pageSize);</span><br><span class="line">        bookDao.selectPage(page,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		别忘了对业务层接口进行测试，测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IBookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testGetById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(bookService.getById(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setType(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setId(<span class="number">17</span>);</span><br><span class="line">        book.setType(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookService.updateById(book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bookService.removeById(<span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testGetAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bookService.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testGetPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IPage&lt;Book&gt; page = <span class="keyword">new</span> Page&lt;Book&gt;(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">        bookService.page(page);</span><br><span class="line">        System.out.println(page.getCurrent());</span><br><span class="line">        System.out.println(page.getSize());</span><br><span class="line">        System.out.println(page.getTotal());</span><br><span class="line">        System.out.println(page.getPages());</span><br><span class="line">        System.out.println(page.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>Service 接口名称定义成业务名称，并与 Dao 接口名称进行区分</li>
<li>制作测试类测试 Service 功能是否有效</li>
</ol>
<h5 id="业务层快速开发"><a class="markdownIt-Anchor" href="#业务层快速开发">#</a> 业务层快速开发</h5>
<p>​		其实 MyBatisPlus 技术不仅提供了数据层快速开发方案，业务层 MyBatisPlus 也给了一个通用接口，个人观点不推荐使用，凑合能用吧，其实就是一个封装 + 继承的思想，代码给出，实际开发慎用。</p>
<p>​		业务层接口快速开发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//添加非通用操作API接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">BookDao</span>, <span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">IBookService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">	<span class="comment">//添加非通用操作API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		如果感觉 MyBatisPlus 提供的功能不足以支撑你的使用需要（其实是一定不能支撑的，因为需求不可能是通用的），在原始接口基础上接着定义新的 API 接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的 API 接口名冲突即可。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用通用接口（ISerivce<T>）快速开发 Service</T></li>
<li>使用通用实现类（ServiceImpl&lt;M,T&gt;）快速开发 ServiceImpl</li>
<li>可以在通用接口基础上做功能重载或功能追加</li>
<li>注意重载时不要覆盖原始操作，避免原始提供的功能丢失</li>
</ol>
<h4 id="6表现层开发"><a class="markdownIt-Anchor" href="#6表现层开发">#</a> 6. 表现层开发</h4>
<p>​		终于做到表现层了，做了这么多都是基础工作。其实你现在回头看看，哪里还有什么 SpringBoot 的影子？前面 1,2 步就搞完了。继续完成表现层制作吧，咱们表现层的开发使用基于 Restful 的表现层接口开发，功能测试通过 Postman 工具进行。</p>
<p>​		表现层接口如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IBookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.modify(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPage&lt;Book&gt; <span class="title">getPage</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="keyword">int</span> pageSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getPage(currentPage,pageSize, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在使用 Postman 测试时关注提交类型，对应上即可，不然就会报 405 的错误码了。</p>
<p><strong>普通 GET 请求</strong></p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129152237371.png" alt="image-20211129152237371"></p>
<p><strong>PUT 请求传递 json 数据，后台实用 @RequestBody 接收数据</strong></p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129152300177.png" alt="image-20211129152300177"></p>
<p><strong>GET 请求传递路径变量，后台实用 @PathVariable 接收数据</strong></p>
<p><img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129152320073.png" alt="image-20211129152320073"></p>
<p><strong>总结</strong></p>
<ol>
<li>基于 Restful 制作表现层接口
<ul>
<li>新增：POST</li>
<li>删除：DELETE</li>
<li>修改：PUT</li>
<li>查询：GET</li>
</ul>
</li>
<li>接收参数
<ul>
<li>实体数据：@RequestBody</li>
<li>路径变量：@PathVariable</li>
</ul>
</li>
</ol>
<h4 id="7表现层消息一致性处理"><a class="markdownIt-Anchor" href="#7表现层消息一致性处理">#</a> 7. 表现层消息一致性处理</h4>
<p>​		目前我们通过 Postman 测试后业务层接口功能是通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重。</p>
<p>​	<strong>增删改操作结果</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>​	<strong>查询单个数据操作结果</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;计算机理论&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Spring实战 第5版&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	<strong>查询全部数据操作结果</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;计算机理论&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Spring实战 第5版&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;计算机理论&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Spring 5核心原理与30个类手写实战&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;十年沉淀之作&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>​		每种不同操作返回的数据格式都不一样，而且还不知道以后还会有什么格式，这样的结果让前端人员看了是很容易让人崩溃的，必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为<strong>前后端数据协议</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean flag;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其中 flag 用于标识操作是否成功，data 用于封装操作数据，现在的数据格式就变了</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;flag&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;计算机理论&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Spring实战 第5版&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		表现层开发格式也需要转换一下</p>
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129153301262.png" alt="image-20211129153301262" style="zoom:80%;">
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129153319052.png" alt="image-20211129153319052" style="zoom:80%;">
<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129153332499.png" alt="image-20211129153332499" style="zoom:80%;">
<p>​		结果这么一折腾，全格式统一，现在后端发送给前端的数据格式就统一了，免去了不少前端解析数据的烦恼。</p>
<p><strong>总结</strong></p>
<ol>
<li>
<p>设计统一的返回值结果类型便于前端开发读取数据</p>
</li>
<li>
<p>返回值结果类型可以根据需求自行设定，没有固定格式</p>
</li>
<li>
<p>返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议</p>
</li>
</ol>
<h4 id="8前后端联通性测试"><a class="markdownIt-Anchor" href="#8前后端联通性测试">#</a> 8. 前后端联通性测试</h4>
<p>​		后端的表现层接口开发完毕，就可以进行前端的开发了。</p>
<p>​		将前端人员开发的页面保存到 lresources 目录下的 static 目录中，建议执行 maven 的 clean 生命周期，避免缓存的问题出现。</p>
<p>​	<img src="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129153831990.png" alt="image-20211129153831990" style="zoom:67%;"></p>
<p>​		在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列表</span></span><br><span class="line"><span class="function"><span class="title">getAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	axios.get(<span class="string">&quot;/books&quot;</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(res.data);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，也就可以进行下一步的功能开发了。</p>
<p><strong>总结</strong></p>
<ol>
<li>单体项目中页面放置在 resources/static 目录下</li>
<li>created 钩子函数用于初始化页面时发起调用</li>
<li>页面使用 axios 发送异步请求获取数据后确认前后端是否联通</li>
</ol>
<h4 id="9页面基础功能开发"><a class="markdownIt-Anchor" href="#9页面基础功能开发">#</a> 9. 页面基础功能开发</h4>
<h5 id="f-1列表功能非分页版"><a class="markdownIt-Anchor" href="#f-1列表功能非分页版">#</a> F-1. 列表功能（非分页版）</h5>
<p>​		列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用 VUE 的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可。</p>
<p>​		<strong>页面数据模型定义</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">	<span class="attr">dataList</span>: [],		<span class="comment">//当前页要展示的列表数据</span></span><br><span class="line">	...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		异步请求获取数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列表</span></span><br><span class="line"><span class="function"><span class="title">getAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    axios.get(<span class="string">&quot;/books&quot;</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.dataList = res.data.data;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		这样在页面加载时就可以获取到数据，并且由 VUE 将数据展示到页面上了。</p>
<p>总结：</p>
<ol>
<li>将查询数据返回到页面，利用前端数据绑定进行数据展示</li>
</ol>
<h5 id="f-2添加功能"><a class="markdownIt-Anchor" href="#f-2添加功能">#</a> F-2. 添加功能</h5>
<p>​		添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可。</p>
<p>​		<strong>默认状态</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">	<span class="attr">dialogFormVisible</span>: <span class="literal">false</span>,	<span class="comment">//添加表单是否可见</span></span><br><span class="line">	...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		<strong>切换为显示状态</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弹出添加窗口</span></span><br><span class="line"><span class="function"><span class="title">handleCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.dialogFormVisible = <span class="literal">true</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹。</p>
<p>​		<strong>定义清理数据操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重置表单</span></span><br><span class="line"><span class="function"><span class="title">resetForm</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.formData = &#123;&#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		<strong>切换弹窗状态时清理数据</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弹出添加窗口</span></span><br><span class="line"><span class="function"><span class="title">handleCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dialogFormVisible = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.resetForm();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		至此准备工作完成，下面就要调用后台完成添加操作了。</p>
<p>​		<strong>添加操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加</span></span><br><span class="line">handleAdd () &#123;</span><br><span class="line">    <span class="comment">//发送异步请求</span></span><br><span class="line">    axios.post(<span class="string">&quot;/books&quot;</span>,<span class="built_in">this</span>.formData).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//如果操作成功，关闭弹层，显示数据</span></span><br><span class="line">        <span class="keyword">if</span>(res.data.flag)&#123;</span><br><span class="line">            <span class="built_in">this</span>.dialogFormVisible = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.$message.success(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.$message.error(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).finally(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getAll();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ol>
<li>将要保存的数据传递到后台，通过 post 请求的第二个参数传递 json 数据到后台</li>
<li>根据返回的操作结果决定下一步操作
<ul>
<li>如何是 true 就关闭添加窗口，显示添加成功的消息</li>
<li>如果是 false 保留添加窗口，显示添加失败的消息</li>
</ul>
</li>
<li>无论添加是否成功，页面均进行刷新，动态加载数据（对 getAll 操作发起调用）</li>
</ol>
<p>​		<strong>取消添加操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消</span></span><br><span class="line"><span class="function"><span class="title">cancel</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.dialogFormVisible = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.$message.info(<span class="string">&quot;操作取消&quot;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>请求方式使用 POST 调用后台对应操作</li>
<li>添加操作结束后动态刷新页面加载数据</li>
<li>根据操作结果不同，显示对应的提示信息</li>
<li>弹出添加 Div 时清除表单数据</li>
</ol>
<h5 id="f-3删除功能"><a class="markdownIt-Anchor" href="#f-3删除功能">#</a> F-3. 删除功能</h5>
<p>​		模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据 id 到后台即可。</p>
<p>​		<strong>删除操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="title">handleDelete</span>(<span class="params">row</span>)</span> &#123;</span><br><span class="line">    axios.delete(<span class="string">&quot;/books/&quot;</span>+row.id).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.data.flag)&#123;</span><br><span class="line">            <span class="built_in">this</span>.$message.success(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$message.error(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).finally(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getAll();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		<strong>删除操作提示信息</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="title">handleDelete</span>(<span class="params">row</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1.弹出提示框</span></span><br><span class="line">    <span class="built_in">this</span>.$confirm(<span class="string">&quot;此操作永久删除当前数据，是否继续？&quot;</span>,<span class="string">&quot;提示&quot;</span>,&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;info&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//2.做删除业务</span></span><br><span class="line">        axios.delete(<span class="string">&quot;/books/&quot;</span>+row.id).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">       		<span class="keyword">if</span>(res.data.flag)&#123;</span><br><span class="line">            	<span class="built_in">this</span>.$message.success(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            	<span class="built_in">this</span>.$message.error(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;).finally(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.getAll();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).catch(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//3.取消删除</span></span><br><span class="line">        <span class="built_in">this</span>.$message.info(<span class="string">&quot;取消删除操作&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;，	</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>请求方式使用 Delete 调用后台对应操作</li>
<li>删除操作需要传递当前行数据对应的 id 值到后台</li>
<li>删除操作结束后动态刷新页面加载数据</li>
<li>根据操作结果不同，显示对应的提示信息</li>
<li>删除操作前弹出提示框避免误操作</li>
</ol>
<h5 id="f-4修改功能"><a class="markdownIt-Anchor" href="#f-4修改功能">#</a> F-4. 修改功能</h5>
<p>​		修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：</p>
<ol>
<li>
<p>页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗</p>
</li>
<li>
<p>弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据</p>
</li>
<li>
<p>查询操作需要将要修改的数据 id 发送到后台，这一点与删除相同，都是传递 id 到后台</p>
</li>
<li>
<p>查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据</p>
</li>
<li>
<p>修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据</p>
<p>所以整体上来看，修改功能就是前面几个功能的大合体</p>
<p><strong>查询并展示数据</strong></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弹出编辑窗口</span></span><br><span class="line"><span class="function"><span class="title">handleUpdate</span>(<span class="params">row</span>)</span> &#123;</span><br><span class="line">    axios.get(<span class="string">&quot;/books/&quot;</span>+row.id).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.data.flag)&#123;</span><br><span class="line">            <span class="comment">//展示弹层，加载数据</span></span><br><span class="line">            <span class="built_in">this</span>.formData = res.data.data;</span><br><span class="line">            <span class="built_in">this</span>.dialogFormVisible4Edit = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$message.error(<span class="string">&quot;数据同步失败，自动刷新&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		<strong>修改操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="function"><span class="title">handleEdit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    axios.put(<span class="string">&quot;/books&quot;</span>,<span class="built_in">this</span>.formData).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//如果操作成功，关闭弹层并刷新页面</span></span><br><span class="line">        <span class="keyword">if</span>(res.data.flag)&#123;</span><br><span class="line">            <span class="built_in">this</span>.dialogFormVisible4Edit = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.$message.success(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.$message.error(<span class="string">&quot;修改失败，请重试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).finally(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getAll();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>加载要修改数据通过传递当前行数据对应的 id 值到后台查询数据（同删除与查询全部）</li>
<li>利用前端双向数据绑定将查询到的数据进行回显（同查询全部）</li>
<li>请求方式使用 PUT 调用后台对应操作（同新增传递数据）</li>
<li>修改操作结束后动态刷新页面加载数据（同新增）</li>
<li>根据操作结果不同，显示对应的提示信息（同新增）</li>
</ol>
<p>​</p>
<h4 id="10业务消息一致性处理"><a class="markdownIt-Anchor" href="#10业务消息一致性处理">#</a> 10. 业务消息一致性处理</h4>
<p>​		目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出 BUG，如果我们搞一个 BUG 出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2021-09-15T03:27:31.038+00:00&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;Internal Server Error&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/books&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		面对这种情况，前端的同学又不会了，这又是什么格式？怎么和之前的格式不一样？</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;flag&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;计算机理论&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Spring实战 第5版&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理。</p>
<p>​		首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean flag;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> String msg;		<span class="comment">//用于封装消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		后台代码也要根据情况做处理，当前是模拟的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Boolean flag = bookService.insert(book);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> R(flag , flag ? <span class="string">&quot;添加成功^_^&quot;</span> : <span class="string">&quot;添加失败-_-!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		然后在表现层做统一的异常处理，使用 SpringMVC 提供的异常处理器做统一的异常处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectExceptionAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">doOtherException</span><span class="params">(Exception ex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">//发送消息给运维</span></span><br><span class="line">        <span class="comment">//发送邮件给开发人员,ex对象发送给开发人员</span></span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> R(<span class="keyword">false</span>,<span class="keyword">null</span>,<span class="string">&quot;系统错误，请稍后再试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果 false，就读取后台传递的消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加</span></span><br><span class="line">handleAdd () &#123;</span><br><span class="line">	<span class="comment">//发送ajax请求</span></span><br><span class="line">    axios.post(<span class="string">&quot;/books&quot;</span>,<span class="built_in">this</span>.formData).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//如果操作成功，关闭弹层，显示数据</span></span><br><span class="line">        <span class="keyword">if</span>(res.data.flag)&#123;</span><br><span class="line">            <span class="built_in">this</span>.dialogFormVisible = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.$message.success(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.$message.error(res.data.msg);			<span class="comment">//消息来自于后台传递过来，而非固定内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).finally(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getAll();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>使用注解 @RestControllerAdvice 定义 SpringMVC 异常处理器用来处理异常的</li>
<li>异常处理器必须被扫描加载，否则无法生效</li>
<li>表现层返回结果的模型类中添加消息属性用来传递消息到页面</li>
</ol>
<p>​</p>
<h4 id="11页面功能开发"><a class="markdownIt-Anchor" href="#11页面功能开发">#</a> 11. 页面功能开发</h4>
<h5 id="f-5分页功能"><a class="markdownIt-Anchor" href="#f-5分页功能">#</a> F-5. 分页功能</h5>
<p>​		分页功能的制作用于替换前面的查询全部，其中要使用到 elementUI 提供的分页组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--分页组件--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pagination-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-pagination</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">		<span class="attr">class</span>=<span class="string">&quot;pagiantion&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">		@<span class="attr">current-change</span>=<span class="string">&quot;handleCurrentChange&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">		<span class="attr">:current-page</span>=<span class="string">&quot;pagination.currentPage&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">		<span class="attr">:page-size</span>=<span class="string">&quot;pagination.pageSize&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">		<span class="attr">layout</span>=<span class="string">&quot;total, prev, pager, next, jumper&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">		<span class="attr">:total</span>=<span class="string">&quot;pagination.total&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>​		为了配合分页组件，封装分页对应的数据模型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">	<span class="attr">pagination</span>: &#123;	</span><br><span class="line">		<span class="comment">//分页相关模型数据</span></span><br><span class="line">		<span class="attr">currentPage</span>: <span class="number">1</span>,	<span class="comment">//当前页码</span></span><br><span class="line">		<span class="attr">pageSize</span>:<span class="number">10</span>,	<span class="comment">//每页显示的记录数</span></span><br><span class="line">		<span class="attr">total</span>:<span class="number">0</span>,		<span class="comment">//总记录数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		修改查询全部功能为分页查询，通过路径变量传递页码信息参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    axios.get(<span class="string">&quot;/books/&quot;</span>+<span class="built_in">this</span>.pagination.currentPage+<span class="string">&quot;/&quot;</span>+<span class="built_in">this</span>.pagination.pageSize).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		后台提供对应的分页功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">getAll</span><span class="params">(<span class="meta">@PathVariable</span> Integer currentPage,<span class="meta">@PathVariable</span> Integer pageSize)</span></span>&#123;</span><br><span class="line">    IPage&lt;Book&gt; pageBook = bookService.getPage(currentPage, pageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> R(<span class="keyword">null</span> != pageBook ,pageBook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		页面根据分页操作结果读取对应数据，并进行数据模型绑定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    axios.get(<span class="string">&quot;/books/&quot;</span>+<span class="built_in">this</span>.pagination.currentPage+<span class="string">&quot;/&quot;</span>+<span class="built_in">this</span>.pagination.pageSize).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pagination.total = res.data.data.total;</span><br><span class="line">        <span class="built_in">this</span>.pagination.currentPage = res.data.data.current;</span><br><span class="line">        <span class="built_in">this</span>.pagination.pagesize = res.data.data.size;</span><br><span class="line">        <span class="built_in">this</span>.dataList = res.data.data.records;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​		对切换页码操作设置调用当前分页操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//切换页码</span></span><br><span class="line"><span class="function"><span class="title">handleCurrentChange</span>(<span class="params">currentPage</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.pagination.currentPage = currentPage;</span><br><span class="line">    <span class="built_in">this</span>.getAll();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>使用 el 分页组件</li>
<li>定义分页组件绑定的数据模型</li>
<li>异步调用获取分页数据</li>
<li>分页数据页面回显</li>
</ol>
<h5 id="f-6删除功能维护"><a class="markdownIt-Anchor" href="#f-6删除功能维护">#</a> F-6. 删除功能维护</h5>
<p>​		由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现 BUG，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">getPage</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="keyword">int</span> pageSize)</span></span>&#123;</span><br><span class="line">    IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize);</span><br><span class="line">    <span class="comment">//如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值</span></span><br><span class="line">    <span class="keyword">if</span>( currentPage &gt; page.getPages())&#123;</span><br><span class="line">        page = bookService.getPage((<span class="keyword">int</span>)page.getPages(), pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> R(<span class="keyword">true</span>, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="f-7条件查询功能"><a class="markdownIt-Anchor" href="#f-7条件查询功能">#</a> F-7. 条件查询功能</h5>
<p>​		最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了</p>
<ul>
<li>
<p>页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递 2 个分页相关数据转换成 2 个分页数据加若干个条件</p>
</li>
<li>
<p>后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是 null，现在换成具体条件，差别不大</p>
</li>
<li>
<p>查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略</p>
<p>经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别。</p>
<p>页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装 url 参数的形式传递。</p>
<p><strong>页面封装查询条件字段</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pagination: &#123;		</span><br><span class="line">//分页相关模型数据</span><br><span class="line">	currentPage: 1,		//当前页码</span><br><span class="line">	pageSize:10,		//每页显示的记录数</span><br><span class="line">	total:0,			//总记录数</span><br><span class="line">	name: &quot;&quot;,</span><br><span class="line">	type: &quot;&quot;,</span><br><span class="line">	description: &quot;&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>页面添加查询条件字段对应的数据模型绑定名称</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;filter-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;图书类别&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pagination.type&quot;</span> <span class="attr">class</span>=<span class="string">&quot;filter-item&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pagination.name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;filter-item&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;图书描述&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pagination.description&quot;</span> <span class="attr">class</span>=<span class="string">&quot;filter-item&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;getAll()&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dalfBut&quot;</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">class</span>=<span class="string">&quot;butT&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleCreate()&quot;</span>&gt;</span>新建<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将查询条件组织成 url 参数，添加到请求 url 地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取查询条件,拼接查询条件</span></span><br><span class="line">    param = <span class="string">&quot;?name=&quot;</span>+<span class="built_in">this</span>.pagination.name;</span><br><span class="line">    param += <span class="string">&quot;&amp;type=&quot;</span>+<span class="built_in">this</span>.pagination.type;</span><br><span class="line">    param += <span class="string">&quot;&amp;description=&quot;</span>+<span class="built_in">this</span>.pagination.description;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;-----------------&quot;</span>+ param);</span><br><span class="line">    axios.get(<span class="string">&quot;/books/&quot;</span>+<span class="built_in">this</span>.pagination.currentPage+<span class="string">&quot;/&quot;</span>+<span class="built_in">this</span>.pagination.pageSize+param).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataList = res.data.data.records;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>后台代码中定义实体类封查询条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">getAll</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="keyword">int</span> pageSize,Book book)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数=====&gt;&quot;</span>+book);</span><br><span class="line">    IPage&lt;Book&gt; pageBook = bookService.getPage(currentPage,pageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> R(<span class="keyword">null</span> != pageBook ,pageBook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应业务层接口与实现类进行修正</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">IPage&lt;Book&gt; <span class="title">getPage</span><span class="params">(Integer currentPage,Integer pageSize,Book queryBook)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl2</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">BookDao</span>,<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">IBookService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPage&lt;Book&gt; <span class="title">getPage</span><span class="params">(Integer currentPage,Integer pageSize,Book queryBook)</span></span>&#123;</span><br><span class="line">        IPage page = <span class="keyword">new</span> Page(currentPage,pageSize);</span><br><span class="line">        LambdaQueryWrapper&lt;Book&gt; lqw = <span class="keyword">new</span> LambdaQueryWrapper&lt;Book&gt;();</span><br><span class="line">        lqw.like(Strings.isNotEmpty(queryBook.getName()),Book::getName,queryBook.getName());</span><br><span class="line">        lqw.like(Strings.isNotEmpty(queryBook.getType()),Book::getType,queryBook.getType());</span><br><span class="line">        lqw.like(Strings.isNotEmpty(queryBook.getDescription()),Book::getDescription,queryBook.getDescription());</span><br><span class="line">        <span class="keyword">return</span> bookDao.selectPage(page,lqw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面回显数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取查询条件,拼接查询条件</span></span><br><span class="line">    param = <span class="string">&quot;?name=&quot;</span>+<span class="built_in">this</span>.pagination.name;</span><br><span class="line">    param += <span class="string">&quot;&amp;type=&quot;</span>+<span class="built_in">this</span>.pagination.type;</span><br><span class="line">    param += <span class="string">&quot;&amp;description=&quot;</span>+<span class="built_in">this</span>.pagination.description;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;-----------------&quot;</span>+ param);</span><br><span class="line">    axios.get(<span class="string">&quot;/books/&quot;</span>+<span class="built_in">this</span>.pagination.currentPage+<span class="string">&quot;/&quot;</span>+<span class="built_in">this</span>.pagination.pageSize+param).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pagination.total = res.data.data.total;</span><br><span class="line">        <span class="built_in">this</span>.pagination.currentPage = res.data.data.current;</span><br><span class="line">        <span class="built_in">this</span>.pagination.pagesize = res.data.data.size;</span><br><span class="line">        <span class="built_in">this</span>.dataList = res.data.data.records;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>定义查询条件数据模型（当前封装到分页数据模型中）</li>
<li>异步调用分页功能并通过请求参数传递数据到后台</li>
</ol>
<h2 id="基础篇完结"><a class="markdownIt-Anchor" href="#基础篇完结">#</a> 基础篇完结</h2>
<p>​		基础篇到这里就全部结束了，在基础篇中带着大家学习了如何创建一个 SpringBoot 工程，然后学习了 SpringBoot 的基础配置语法格式，接下来对常见的市面上的实用技术做了整合，最后通过一个小的案例对前面学习的内容做了一个综合应用。整体来说就是一个最基本的入门，关于 SpringBoot 的实际开发其实接触的还是很少的，我们到实用篇和原理篇中继续吧，各位小伙伴，加油学习，再见。</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>教程</tag>
        <tag>SpringBoot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
