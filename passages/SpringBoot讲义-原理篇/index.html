<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>SpringBoot讲义-原理篇 | LXR的小站</title><meta name="keywords" content="学习,教程,SpringBoot,Java"><meta name="author" content="LXR"><meta name="copyright" content="LXR"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="# SpringBoot 原理篇 # 前言（白嫖发言） ​		这个笔记是从黑马老师那里嫖来的，放在这里是为了方便查看，没有商用的意思，转载请标明黑马程序员以及链接。 黑马程序员 SpringBoot2 全套视频教程，springboot 零基础到项目实战 ​		原理篇来辣！ ​		其实从本人的角度出发，看了这么多学习 java 的小伙伴的学习过程，个人观点，不建议小伙伴过早的去研究技术的原理。原因">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot讲义-原理篇">
<meta property="og:url" content="http://laz0825.cn/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%8E%9F%E7%90%86%E7%AF%87/index.html">
<meta property="og:site_name" content="LXR的小站">
<meta property="og:description" content="# SpringBoot 原理篇 # 前言（白嫖发言） ​		这个笔记是从黑马老师那里嫖来的，放在这里是为了方便查看，没有商用的意思，转载请标明黑马程序员以及链接。 黑马程序员 SpringBoot2 全套视频教程，springboot 零基础到项目实战 ​		原理篇来辣！ ​		其实从本人的角度出发，看了这么多学习 java 的小伙伴的学习过程，个人观点，不建议小伙伴过早的去研究技术的原理。原因">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img13.360buyimg.com/ddimg/jfs/t1/201014/9/2100/116055/611b9a15E22fe0582/06f08140ca9867a4.jpg">
<meta property="article:published_time" content="2022-09-02T14:28:45.000Z">
<meta property="article:modified_time" content="2024-10-28T11:41:25.901Z">
<meta property="article:author" content="LXR">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="SpringBoot">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img13.360buyimg.com/ddimg/jfs/t1/201014/9/2100/116055/611b9a15E22fe0582/06f08140ca9867a4.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://laz0825.cn/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%8E%9F%E7%90%86%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: LXR","link":"链接: ","source":"来源: LXR的小站","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringBoot讲义-原理篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-28 19:41:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://butterfly.lete114.top/css/Lete.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macblack.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/xxx.css"><link rel="stylesheet" href="/css/tag.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-clock/lib/clock.min.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s3.bmp.ovh/imgs/2022/01/48416141b447da0f.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-sitemap"></i><span> 分站</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/ad/"><i class="fa-fw fas fa-chevron-right"></i><span> 分站（ad主题）</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-sitemap"></i><span> 在线技术文档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/index.html"><span> Java8官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.wdbyte.com/"><span> Java系列文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework"><span> spring官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot"><span> springBoot官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html"><span> MyBatis官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://baomidou.com/"><span> MyBatis-Plus官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://cn.vuejs.org/"><span> VUE官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/"><span> 微信小程序官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN/"><span> ELEMENT-UI官方中文文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://jquery.com/"><span> jQuery官网(内含Ajax)</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://jquery.asprain.cn/ajaxSend.htm"><span> jQuery中文文档(内含Ajax)</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.axios-http.cn/docs/intro"><span> Axios中文文档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img13.360buyimg.com/ddimg/jfs/t1/201014/9/2100/116055/611b9a15E22fe0582/06f08140ca9867a4.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LXR的小站</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-sitemap"></i><span> 分站</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/ad/"><i class="fa-fw fas fa-chevron-right"></i><span> 分站（ad主题）</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-sitemap"></i><span> 在线技术文档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/index.html"><span> Java8官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.wdbyte.com/"><span> Java系列文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework"><span> spring官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot"><span> springBoot官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html"><span> MyBatis官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://baomidou.com/"><span> MyBatis-Plus官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://cn.vuejs.org/"><span> VUE官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/"><span> 微信小程序官方文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN/"><span> ELEMENT-UI官方中文文档</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://jquery.com/"><span> jQuery官网(内含Ajax)</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://jquery.asprain.cn/ajaxSend.htm"><span> jQuery中文文档(内含Ajax)</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.axios-http.cn/docs/intro"><span> Axios中文文档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringBoot讲义-原理篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-02T14:28:45.000Z" title="发表于 2022-09-02 22:28:45">2022-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-28T11:41:25.901Z" title="更新于 2024-10-28 19:41:25">2024-10-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>55分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SpringBoot讲义-原理篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="springboot原理篇"><a class="markdownIt-Anchor" href="#springboot原理篇">#</a> SpringBoot 原理篇</h1>
<h3 id="前言白嫖发言"><a class="markdownIt-Anchor" href="#前言白嫖发言">#</a> 前言（白嫖发言）</h3>
<p>​		这个笔记是从黑马老师那里嫖来的，放在这里是为了方便查看，没有商用的意思，转载请标明<strong>黑马程序员</strong>以及链接。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15b4y1a7yG">黑马程序员 SpringBoot2 全套视频教程，springboot 零基础到项目实战</a></p>
<p>​		原理篇来辣！</p>
<p>​		其实从本人的角度出发，看了这么多学习 java 的小伙伴的学习过程，个人观点，不建议小伙伴过早的去研究技术的原理。原因有二：一，<strong>先应用熟练</strong>，<strong>培养技术应用的条件反射</strong>，然后再学原理。大把的学习者天天还纠结于这里少写一个这，那里少写一个那，程序都跑不下去，要啥原理，要啥自行车。这里要说一句啊，懂不懂啥意思那不叫原理，原理是抽象到顶层设计层面的东西。知道为什么写这句话，知道错误的原因和懂原理是两码事。二， <strong>原理真不是看源码</strong>，源码只能称作原理的落地实现方式，当好的落地实现方式出现后，就会有新旧版本的迭代，底层实现方式也会伴随着更新升级。但是原理不变，只是找到了更好的实现最初目标的路径。一个好的课程，一位好的老师，不会用若干行云里雾里的源代码把学习者带到沟里，然后爬不出来，深陷泥潭。一边沮丧的看着源码，一边舔着老师奉其为大神，这就叫不干人事。原理就应该使用最通俗易懂的语言，把设计思想讲出来，至于看源码，只是因为目前的技术原创人员只想到了当前这种最笨的设计方案，还没有更好的。比如 spirng 程序，写起来很费劲，springboot 出来以后就简单轻松了很多，实现方案变了，原理不变。但凡你想通过下面的课程学习去读懂若干行代码，然后特别装逼的告诉自己，我懂原理了。我只能告诉你，你选了一条成本最高的路线，看源码仅仅是验证原理，源码仅对应程序流程，不对应原理。原理是思想级的，不是代码级的，原理是原本的道理。</p>
<p>​		springboot 技术本身就是为了加速 spring 程序的开发的，可以大胆的说，springboot 技术没有自己的原理层面的设计，仅仅是实现方案进行了改进。将 springboot 定位成工具，你就不会去想方设法的学习其原理了。就像是将木头分割成若干份，我们可以用斧子，用锯子，用刀，用火烧或者一脚踹断它，这些都是方式方法，而究其本质底层原理是植物纤维的组织方式，研究完这个，你再看前述的各种工具，都是基于这个原理在说如何变更破坏这种植物纤维的方式。所以不要一张嘴说了若干种技术，然后告诉自己，这就是 spirngboot 的原理。没有的事，springboot 作为一款工具，压根就没有原理。我们下面要学习的其实就是 spirngboot 程序的工作流程。</p>
<p>​		下面就开始学习原理篇，因为没有想出来特别好的名字，所以还是先称作原理篇吧。原理篇中包含如下内容：</p>
<ul>
<li>自动配置工作流程</li>
<li>自定义 starter 开发</li>
<li>springboot 程序启动流程</li>
</ul>
<p>​		下面开启第一部分自动配置工作流程的学习</p>
<h2 id="yl-1自动配置工作流程"><a class="markdownIt-Anchor" href="#yl-1自动配置工作流程">#</a> YL-1. 自动配置工作流程</h2>
<p>​		自动配置是 springboot 技术非常好用的核心因素，前面学习了这么多种技术的整合，每一个都离不开自动配置。不过在学习自动配置的时候，需要你对 spring 容器如何进行 bean 管理的过程非常熟悉才行，所以这里需要先复习一下有关 spring 技术中 bean 加载相关的知识。方式方法很多，逐一快速复习一下，查漏补缺。不过这里需要声明一点，这里列出的 bean 的加载方式仅仅应用于后面课程的学习，并不是所有的 spring 加载 bean 的方式。跟着我的步伐一种一种的复习，他们这些方案之间有千丝万缕的关系，顺着看完，你就懂自动配置是怎么回事了。</p>
<h3 id="yl-1-1bean的加载方式"><a class="markdownIt-Anchor" href="#yl-1-1bean的加载方式">#</a> YL-1-1.bean 的加载方式</h3>
<p>​		关于 bean 的加载方式，spring 提供了各种各样的形式。因为 spring 管理 bean 整体上来说就是由 spring 维护对象的生命周期，所以 bean 的加载可以从大的方面划分成 2 种形式。已知类并交给 spring 管理，和已知类名并交给 spring 管理。有什么区别？一个给.class，一个给类名字符串。内部其实都一样，都是通过 spring 的 BeanDefinition 对象初始化 spring 的 bean。如果前面这句话看起来有障碍，可以去复习一下 spring 的相关知识。B 站中有我尊敬的满一航老师录制的 spring 高级课程，链接地址如下，欢迎大家捧场，记得一键三连哦。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">https://<span class="title">www.bilibili.com</span>/<span class="title">video</span>/<span class="title">BV1P44y1N7QG</span></span></span><br></pre></td></tr></table></figure>
<h4 id="方式一配置文件bean标签"><a class="markdownIt-Anchor" href="#方式一配置文件bean标签">#</a> 方式一：配置文件 + <code>&lt;bean/&gt;</code>  标签</h4>
<p>​		最高端的食材往往只需要最简单的烹饪方法，搞错了，再来。最初级的 bean 的加载方式其实可以直击 spring 管控 bean 的核心思想，就是提供类名，然后 spring 就可以管理了。所以第一种方式就是给出 bean 的类名，至于内部嘛就是反射机制加载成 class，然后，就没有然后了，拿到了 class 你就可以搞定一切了。如果这句话听不太懂，请这些小盆友转战 java 基础高级部分复习一下反射相关知识。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--xml方式声明自己开发的bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--xml方式声明第三方开发的bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="方式二配置文件扫描注解定义bean"><a class="markdownIt-Anchor" href="#方式二配置文件扫描注解定义bean">#</a> 方式二：配置文件扫描 + 注解定义 bean</h4>
<p>​		由于方式一种需要将 spring 管控的 bean 全部写在 xml 文件中，对于程序员来说非常不友好，所以就有了第二种方式。哪一个类要受到 spring 管控加载成 bean，就在这个类的上面加一个注解，还可以顺带起一个 bean 的名字（id）。这里可以使用的注解有 @Component 以及三个衍生注解 @Service、@Controller、@Repository。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;tom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		当然，由于我们无法在第三方提供的技术源代码中去添加上述 4 个注解，因此当你需要加载第三方开发的 bean 的时候可以使用下列方式定义注解式的 bean。@Bean 定义在一个方法上方，当前方法的返回值就可以交给 spring 管控，记得这个方法所在的类一定要定义在 @Component 修饰的类中，有人会说不是 @Configuration 吗？建议把 spring 注解开发相关课程学习一下，就不会有这个疑问了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource ds = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		上面提供的仅仅是 bean 的声明，spring 并没有感知到这些东西，像极了上课积极回答问题的你，手举的非常高，可惜老师都没有往你的方向看上一眼。想让 spring 感知到这些积极的小伙伴，必须设置 spring 去检查这些类，看他们是否贴标签，想当积极分子。可以通过下列 xml 配置设置 spring 去检查哪些包，发现定了对应注解，就将对应的类纳入 spring 管控范围，声明成 bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定扫描加载bean的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.bean,com.itheima.config&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		方式二声明 bean 的方式是目前企业中较为常见的 bean 的声明方式，但是也有缺点。方式一中，通过一个配置文件，你可以查阅当前 spring 环境中定义了多少个或者说多少种 bean，但是方式二没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个 bean。</p>
<h4 id="方式三注解方式声明配置类"><a class="markdownIt-Anchor" href="#方式三注解方式声明配置类">#</a> 方式三：注解方式声明配置类</h4>
<p>​		方式二已经完美的简化了 bean 的声明，以后再也不用写茫茫多的配置信息了。仔细观察 xml 配置文件，会发现这个文件中只剩了扫描包这句话，于是就有人提出，使用 java 类替换掉这种固定格式的配置，所以下面这种格式就出现了。严格意义上讲不能算全新的方式，但是由于此种开发形式是企业级开发中的主流形式，所以单独独立出来做成一种方式。嗯……，怎么说呢？方式二和方式三其实差别还是挺大的，番外篇找个时间再聊吧。</p>
<p>​		定义一个类并使用 @ComponentScan 替代原始 xml 配置中的包扫描这个动作，其实功能基本相同。为什么说基本，还是有差别的。先卖个关子吧，番外篇再聊。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.bean&quot;,&quot;com.itheima.config&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DogFactoryBean <span class="title">dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用factroybean接口"><a class="markdownIt-Anchor" href="#使用factroybean接口">#</a> 使用 FactroyBean 接口</h5>
<p>​		补充一个小知识，spring 提供了一个接口 FactoryBean，也可以用于声明 bean，只不过实现了 FactoryBean 接口的类造出来的对象不是当前类的对象，而是 FactoryBean 接口泛型指定类型的对象。如下列，造出来的 bean 并不是 DogFactoryBean，而是 Dog。有什么用呢？可以在对象初始化前做一些事情，下例中的注释位置就是让你自己去扩展要做的其他事情的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Dog</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">//.........</span></span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Dog.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		有人说，注释中的代码写入 Dog 的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为 Dog 是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果写入 Dog，或许初始化动作 A 当前并不能满足你的需要，这个时候你就要做一个 DogB 的方案了。然后，就没有然后了，你就要做两个 Dog 类。当时使用 FactoryBean 接口就可以完美解决这个问题。</p>
<p>​		通常实现了 FactoryBean 接口的类使用 @Bean 的形式进行加载，当然你也可以使用 @Component 去声明 DogFactoryBean，只要被扫描加载到即可，但是这种格式加载总觉得怪怪的，指向性不是很明确。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.bean&quot;,&quot;com.itheima.config&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DogFactoryBean <span class="title">dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注解格式导入xml格式配置的bean"><a class="markdownIt-Anchor" href="#注解格式导入xml格式配置的bean">#</a> 注解格式导入 XML 格式配置的 bean</h5>
<p>​		再补充一个小知识，由于早起开发的系统大部分都是采用 xml 的形式配置 bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发的用注解格式，之前开发的是 xml 格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring 提供了一个注解可以解决这个问题，@ImportResource，在配置类上直接写上要被融合的 xml 配置文件名即可，算的上一种兼容性解决方案，没啥实际意义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;applicationContext1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig32</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="proxybeanmethods属性"><a class="markdownIt-Anchor" href="#proxybeanmethods属性">#</a> proxyBeanMethods 属性</h5>
<p>​		前面的例子中用到了 @Configuration 这个注解，当我们使用 AnnotationConfigApplicationContext 加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的 bean 的唯一性。为 @Configuration 注解设置 proxyBeanMethods 属性值为 true 即可，由于此属性默认值为 true，所以很少看见明确书写的，除非想放弃此功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig33</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		下面通过容器再调用上面的 cat 方法时，得到的就是同一个对象了。注意，必须使用 spring 容器对象调用此方法才有保持 bean 唯一性的特性。此特性在很多底层源码中有应用，前面讲 MQ 时，也应用了此特性，只不过当前没有解释而已。这里算是填个坑吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App33</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig33.class);</span><br><span class="line">        String[] names = ctx.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">        SpringConfig33 springConfig33 = ctx.getBean(<span class="string">&quot;springConfig33&quot;</span>, SpringConfig33.class);</span><br><span class="line">        System.out.println(springConfig33.cat());</span><br><span class="line">        System.out.println(springConfig33.cat());</span><br><span class="line">        System.out.println(springConfig33.cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式四使用import注解注入bean"><a class="markdownIt-Anchor" href="#方式四使用import注解注入bean">#</a> 方式四：使用 @Import 注解注入 bean</h4>
<p>​		使用扫描的方式加载 bean 是企业级开发中常见的 bean 的加载方式，但是由于扫描的时候不仅可以加载到你要的东西，还有可能加载到各种各样的乱七八糟的东西，万一没有控制好得不偿失了。</p>
<p>​		有人就会奇怪，会有什么问题呢？比如你扫描了 com.itheima.service 包，后来因为业务需要，又扫描了 com.itheima.dao 包，你发现 com.itheima 包下面只有 service 和 dao 这两个包，这就简单了，直接扫描 com.itheima 就行了。但是万万没想到，十天后你加入了一个外部依赖包，里面也有 com.itheima 包，这下就热闹了，该来的不该来的全来了。</p>
<p>​		所以我们需要一种精准制导的加载方式，使用 @Import 注解就可以解决你的问题。它可以加载所有的一切，只需要在注解的参数中写上加载的类对应的.class 即可。有人就会觉得，还要自己手写，多麻烦，不如扫描好用。对呀，但是他可以指定加载啊，好的命名规范配合 @ComponentScan 可以解决很多问题，但是 @Import 注解拥有其重要的应用场景。有没有想过假如你要加载的 bean 没有使用 @Component 修饰呢？这下就无解了，而 @Import 就无需考虑这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Dog.class,DbConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig4</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用import注解注入配置类"><a class="markdownIt-Anchor" href="#使用import注解注入配置类">#</a> 使用 @Import 注解注入配置类</h5>
<p>​		除了加载 bean，还可以使用 @Import 注解加载配置类。其实本质上是一样的，不解释太多了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(DogFactoryBean.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig4</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式五编程形式注册bean"><a class="markdownIt-Anchor" href="#方式五编程形式注册bean">#</a> 方式五：编程形式注册 bean</h4>
<p>​		前面介绍的加载 bean 的方式都是在容器启动阶段完成 bean 的加载，下面这种方式就比较特殊了，可以在容器初始化完成后手动加载 bean。通过这种方式可以实现编程式控制 bean 的加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        <span class="comment">//上下文容器对象已经初始化完毕后，手工加载bean</span></span><br><span class="line">        ctx.register(Mouse.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其实这种方式坑还是挺多的，比如容器中已经有了某种类型的 bean，再加载会不会覆盖呢？这都是要思考和关注的问题。新手慎用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        <span class="comment">//上下文容器对象已经初始化完毕后，手工加载bean</span></span><br><span class="line">        ctx.registerBean(<span class="string">&quot;tom&quot;</span>, Cat.class,<span class="number">0</span>);</span><br><span class="line">        ctx.registerBean(<span class="string">&quot;tom&quot;</span>, Cat.class,<span class="number">1</span>);</span><br><span class="line">        ctx.registerBean(<span class="string">&quot;tom&quot;</span>, Cat.class,<span class="number">2</span>);</span><br><span class="line">        System.out.println(ctx.getBean(Cat.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式六导入实现了importselector接口的类"><a class="markdownIt-Anchor" href="#方式六导入实现了importselector接口的类">#</a> 方式六：导入实现了 ImportSelector 接口的类</h4>
<p>​		在方式五种，我们感受了 bean 的加载可以进行编程化的控制，添加 if 语句就可以实现 bean 的加载控制了。但是毕竟是在容器初始化后实现 bean 的加载控制，那是否可以在容器初始化过程中进行控制呢？答案是必须的。实现 ImportSelector 接口的类可以设置加载的 bean 的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。</p>
<p>​		现在又多了一种控制 bean 加载的方式，或者说是选择 bean 的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        <span class="comment">//各种条件的判定，判定完毕后，决定是否装载指定的bean</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = metadata.hasAnnotation(<span class="string">&quot;org.springframework.context.annotation.Configuration&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;com.itheima.bean.Dog&quot;</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;com.itheima.bean.Cat&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="方式七导入实现了importbeandefinitionregistrar接口的类"><a class="markdownIt-Anchor" href="#方式七导入实现了importbeandefinitionregistrar接口的类">#</a> 方式七：导入实现了 ImportBeanDefinitionRegistrar 接口的类</h4>
<p>​		方式六中提供了给定类全路径类名控制 bean 加载的形式，如果对 spring 的 bean 的加载原理比较熟悉的小伙伴知道，其实 bean 的加载不是一个简简单单的对象，spring 中定义了一个叫做 BeanDefinition 的东西，它才是控制 bean 初始化加载的核心。BeanDefinition 接口中给出了若干种方法，可以控制 bean 的相关属性。说个最简单的，创建的对象是单例还是非单例，在 BeanDefinition 中定义了 scope 属性就可以控制这个。如果你感觉方式六没有给你开放出足够的对 bean 的控制操作，那么方式七你值得拥有。我们可以通过定义一个类，然后实现 ImportBeanDefinitionRegistrar 接口的方式定义 bean，并且还可以让你对 bean 的初始化进行更加细粒度的控制，不过对于新手并不是很友好。忽然给你开放了若干个操作，还真不知道如何下手。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = 	</span><br><span class="line">            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;bookService&quot;</span>,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式八导入实现了beandefinitionregistrypostprocessor接口的类"><a class="markdownIt-Anchor" href="#方式八导入实现了beandefinitionregistrypostprocessor接口的类">#</a> 方式八：导入实现了 BeanDefinitionRegistryPostProcessor 接口的类</h4>
<p>​		上述七种方式都是在容器初始化过程中进行 bean 的加载或者声明，但是这里有一个 bug。这么多种方式，它们之间如果有冲突怎么办？谁能有最终裁定权？这是个好问题，当某种类型的 bean 被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你还真不知道最后谁说了算。即便你理清楚了，保不齐和你一起开发的猪队友又添加了一个 bean，得嘞，这下就热闹了。</p>
<p>​		spring 挥舞它仲裁者的大刀来了一个致命一击，都别哔哔了，我说了算，BeanDefinitionRegistryPostProcessor，看名字知道，BeanDefinition 意思是 bean 定义，Registry 注册的意思，Post 后置，Processor 处理器，全称 bean 定义后处理器，干啥的？在所有 bean 注册都折腾完后，它把最后一道关，说白了，它说了算，这下消停了，它是最后一个运行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = </span><br><span class="line">            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;bookService&quot;</span>,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​		总体上来说，上面介绍了各种各样的 bean 的注册加载初始化方式，脑子里建立个概念吧，方式很多，spring 源码中大量运用各种方式。复习的内容就先说到这里。</p>
<p><strong>总结</strong></p>
<ol>
<li>bean 的定义由前期 xml 配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是 spring 管控的 bean</li>
<li>@Import 注解可以指定加载某一个类作为 spring 管控的 bean，如果被加载的类中还具有 @Bean 相关的定义，会被一同加载</li>
<li>spring 开放出了若干种可编程控制的 bean 的初始化方式，通过分支语句由固定的加载 bean 转成了可以选择 bean 是否加载或者选择加载哪一种 bean</li>
</ol>
<h3 id="yl-1-2bean的加载控制"><a class="markdownIt-Anchor" href="#yl-1-2bean的加载控制">#</a> YL-1-2.bean 的加载控制</h3>
<p>​		前面复习 bean 的加载时，提出了有关加载控制的方式，其中手工注册 bean，ImportSelector 接口，ImportBeanDefinitionRegistrar 接口，BeanDefinitionRegistryPostProcessor 接口都可以控制 bean 的加载，这一节就来说说这些加载控制。</p>
<p>​		企业级开发中不可能在 spring 容器中进行 bean 的饱和式加载的。什么是饱和式加载，就是不管用不用，全部加载。比如 jdk 中有两万个类，那就加载两万个 bean，显然是不合理的，因为你压根就不会使用其中大部分的 bean。那合理的加载方式是什么？肯定是必要性加载，就是用什么加载什么。继续思考，加载哪些 bean 通常受什么影响呢？最容易想的就是你要用什么技术，就加载对应的 bean。用什么技术意味着什么？就是加载对应技术的类。所以在 spring 容器中，通过判定是否加载了某个类来控制某些 bean 的加载是一种常见操作。下例给出了对应的代码实现，其实思想很简单，先判断一个类的全路径名是否能够成功加载，加载成功说明有这个类，那就干某项具体的工作，否则就干别的工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.itheima.bean.Mouse&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;com.itheima.bean.Cat&quot;</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		通过上述的分析，可以看到此类操作将成为企业级开发中的常见操作，于是 springboot 将把这些常用操作给我们做了一次封装。这种逻辑判定你开发者就别搞了，我 springboot 信不过你这种新手开发者，我给你封装一下，做几个注解，你填参数吧，耶，happy。</p>
<p>​		下例使用 @ConditionalOnClass 注解实现了当虚拟机中加载了 com.itheima.bean.Wolf 类时加载对应的 bean。比较一下上面的代码和下面的代码，有没有感觉很清爽。其实此类注解还有很多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;com.itheima.bean.Wolf&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		@ConditionalOnMissingClass 注解控制虚拟机中没有加载指定的类才加载对应的 bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;com.itheima.bean.Dog&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		这种条件还可以做并且的逻辑关系，写 2 个就是 2 个条件都成立，写多个就是多个条件都成立。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;com.itheima.bean.Wolf&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;com.itheima.bean.Mouse&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		除了判定是否加载类，还可以对当前容器类型做判定，下例是判定当前容器环境是否是 web 环境。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		下面是判定容器环境是否是非 web 环境。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		当然还可以判定是否加载了指定名称的 bean，这种有什么用呢？太有用了。比如当前容器中已经提供了 jdbcTemplate 对应的 bean，你还需要再加载一个全新的 jdbcTemplate 的 bean 吗？没有必要了嘛。spring 说，如果你自己写的话，我就不帮你操这份心了，如果你没写，我再给你提供。自适应，自适应，明白？没有的话就提供给你，有的话就用你自己的，是不是很帅？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name=&quot;jerry&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">tom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		以下就是判定当前是否加载了 mysql 的驱动类，如果加载了，我就给你搞一个 Druid 的数据源对象出来，完美！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name=&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其中 springboot 的 bean 加载控制注解还有很多，这里就不一一列举了，最常用的判定条件就是根据类是否加载来进行控制。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 定义了若干种控制 bean 加载的条件设置注解，由 spring 固定加载 bean 变成了可以根据情况选择性的加载 bean</li>
</ol>
<h3 id="yl-1-3bean的依赖属性配置管理"><a class="markdownIt-Anchor" href="#yl-1-3bean的依赖属性配置管理">#</a> YL-1-3.bean 的依赖属性配置管理</h3>
<p>​		bean 的加载及加载控制已经搞完了，下面研究一下 bean 内部的事情。bean 在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，这个时候就可以使用前期学习的 bean 的属性配置相关的知识进行灵活的配置了。先通过 yml 配置文件，设置 bean 运行需要使用的配置信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cartoon:</span></span><br><span class="line">  <span class="attr">cat:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;图多盖洛&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">mouse:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;泰菲&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>​		然后定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;cartoon&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		最后在使用的位置注入对应的配置即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CartoonProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonCatAndMouse</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CartoonProperties cartoonProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		建议在业务类上使用 @EnableConfigurationProperties 声明 bean，这样在不使用这个类的时候，也不会无故加载专用的属性配置类 CartoonProperties，减少 spring 管控的资源数量。</p>
<p><strong>总结</strong></p>
<ol>
<li>bean 的运行如果需要外部设置值，建议将设置值封装成专用的属性类 * * * * Properties</li>
<li>设置属性类加载指定前缀的配置信息</li>
<li>在需要使用属性类的位置通过注解 @EnableConfigurationProperties 加载 bean，而不要直接在属性配置类上定义 bean，减少资源加载的数量，因需加载而不要饱和式加载。</li>
</ol>
<h3 id="yl-1-4自动配置原理工作流程"><a class="markdownIt-Anchor" href="#yl-1-4自动配置原理工作流程">#</a> YL-1-4. 自动配置原理（工作流程）</h3>
<p>​		经过前面的知识复习，下面终于进入到了本章核心内容的学习，自动配置原理。原理谈不上，就是自动配置的工作流程。</p>
<p>​		啥叫自动配置呢？简单说就是 springboot 根据我们开发者的行为猜测你要做什么事情，然后把你要用的 bean 都给你准备好。听上去是不是很神奇？其实非常简单，前面复习的东西都已经讲完了。springboot 咋做到的呢？就是看你导入了什么类，就知道你想干什么了。然后把你有可能要用的 bean（注意是有可能）都给你加载好，你直接使用就行了，springboot 把所需要的一切工作都做完了。</p>
<p>​		自动配置的意义就是加速开发效率，将开发者使用某种技术时需要使用的 bean 根据情况提前加载好，实现自动配置的效果。当然，开发者有可能需要提供必要的参数，比如你要用 mysql 技术，导入了 mysql 的坐标，springboot 就知道了你要做数据库操作，一系列的数据库操作相关的 bean 都给你提前声明好，但是你要告诉 springboot 你到底用哪一个数据库，像什么 IP 地址啊，端口啊，你不告诉 spirngboot，springboot 就无法帮你把自动配置相关的工作做完。</p>
<p>​		而这种思想其实就是在日常的开发过程中根据开发者的习惯慢慢抽取得到了。整体过程分为 2 个阶段：</p>
<p>​		<strong>阶段一：准备阶段</strong></p>
<ol>
<li>
<p>springboot 的开发人员先大量收集 Spring 开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成一个<strong>技术集 A</strong></p>
</li>
<li>
<p>收集常用技术 (<strong>技术集 A</strong>) 的使用参数，不管你用什么常用设置，我用什么常用设置，统统收集起来整理一下，得到开发过程中每一个技术的常用设置，形成每一个技术对应的<strong>设置集 B</strong></p>
<p><strong>阶段二：加载阶段</strong></p>
</li>
<li>
<p>springboot 初始化 Spring 容器基础环境，读取用户的配置信息，加载用户自定义的 bean 和导入的其他坐标，形成<strong>初始化环境</strong></p>
</li>
<li>
<p>springboot 将<strong>技术集 A</strong> 包含的所有技术在 SpringBoot 启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的</p>
</li>
<li>
<p>springboot 会对<strong>技术集 A</strong> 中每一个技术约定出启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些 bean 和其他坐标，也就是与<strong>初始化环境</strong>，这个时候就可以根据这个<strong>初始化环境</strong>与 springboot 的<strong>技术集 A</strong> 进行比对了，哪个匹配上加载哪个</p>
</li>
<li>
<p>因为有些技术不做配置就无法工作，所以 springboot 开始对<strong>设置集 B</strong> 下手了。它统计出各个国家各个行业的开发者使用某个技术时最常用的设置是什么，然后把这些设置作为默认值直接设置好，并告诉开发者当前设置我已经给你搞了一套，你要用可以直接用，这样可以减少开发者配置参数的工作量</p>
</li>
<li>
<p>但是默认配置不一定能解决问题，于是 springboot 开放修改<strong>设置集 B</strong> 的接口，可以由开发者根据需要决定是否覆盖默认配置</p>
</li>
</ol>
<p>​		以上这些仅仅是一个思想，落地到代码实现阶段就要好好思考一下怎么实现了。假定我们想自己实现自动配置的功能，都要做哪些工作呢？</p>
<ul>
<li>首先指定一个技术 X，我们打算让技术 X 具备自动配置的功能，这个技术 X 可以是任意功能，这个技术隶属于上面描述的<strong>技术集 A</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonCatAndMouse</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后找出技术 X 使用过程中的常用配置 Y，这个配置隶属于上面表述的<strong>设置集 B</strong></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cartoon:</span></span><br><span class="line">  <span class="attr">cat:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;图多盖洛&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">mouse:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;泰菲&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将常用配置 Y 设计出对应的 yml 配置书写格式，然后定义一个属性类封装对应的配置属性，这个过程其实就是上一节咱们做的 bean 的依赖属性管理，一模一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;cartoon&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后做一个配置类，当这个类加载的时候就可以初始化对应的功能 bean，并且可以加载到对应的配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CartoonProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonCatAndMouse</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CartoonProperties cartoonProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当然，你也可以为当前自动配置类设置上激活条件，例如使用 @CondtionOn* * * * 为其设置加载条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(name=&quot;org.springframework.data.redis.core.RedisOperations&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(CartoonProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartoonCatAndMouse</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CartoonProperties cartoonProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		做到这里都已经做完了，但是遇到了一个全新的问题，如何让 springboot 启动的时候去加载这个类呢？如果不加载的话，我们做的条件判定，做的属性加载这些全部都失效了。springboot 为我们开放了一个配置入口，在配置目录中创建 META-INF 目录，并创建 spring.factories 文件，在其中添加设置，说明哪些类要启动自动配置就可以了。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.itheima.bean.CartoonCatAndMouse</span><br></pre></td></tr></table></figure>
<p>​		其实这个文件就做了一件事，通过这种配置的方式加载了指定的类。转了一圈，就是个普通的 bean 的加载，和最初使用 xml 格式加载 bean 几乎没有区别，格式变了而已。那自动配置的核心究竟是什么呢？自动配置其实是一个小的生态，可以按照如下思想理解：</p>
<ol>
<li>自动配置从根本上来说就是一个 bean 的加载</li>
<li>通过 bean 加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用，这是蒙蔽我们双眼的第一层面纱</li>
<li>使用 bean 的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，感觉这个过程好屌，也是一种自适应的形式，其实还是需要使用分支语句来做判断的，这是蒙蔽我们双眼的第二层面纱</li>
<li>springboot 技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，其实就是提前帮我们把 spring.factories 文件写好了，这是蒙蔽我们双眼的第三层面纱</li>
</ol>
<p>​		你在不知道自动配置这个知识的情况下，经过上面这一二三，你当然觉得自动配置是一种特别牛的技术，但是一窥究竟后发现，也就那么回事。而且现在 springboot 程序启动时，在后台偷偷的做了这么多次检测，这么多种情况判定，不用问了，效率一定是非常低的，毕竟它要检测 100 余种技术是否在你程序中使用。</p>
<p>​		以上内容是自动配置的工作流程。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 启动时先加载 spring.factories 文件中的 org.springframework.boot.autoconfigure.EnableAutoConfiguration 配置项，将其中配置的所有的类都加载成 bean</li>
<li>在加载 bean 的时候，bean 对应的类定义上都设置有加载条件，因此有可能加载成功，也可能条件检测失败不加载 bean</li>
<li>对于可以正常加载成 bean 的类，通常会通过 @EnableConfigurationProperties 注解初始化对应的配置属性类并加载对应的配置</li>
<li>配置属性类上通常会通过 @ConfigurationProperties 加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须配置后使用了</li>
</ol>
<h3 id="yl-1-5变更自动配置"><a class="markdownIt-Anchor" href="#yl-1-5变更自动配置">#</a> YL-1-5. 变更自动配置</h3>
<p>​		知道了自动配置的执行过程，下面就可以根据这个自动配置的流程做一些高级定制了。例如系统默认会加载 100 多种自动配置的技术，如果我们先手工干预此工程，禁用自动配置是否可行呢？答案一定是可以的。方式还挺多：</p>
<p><strong>方式一：通过 yaml 配置设置排除指定的自动配置类</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">autoconfigure:</span></span><br><span class="line">    <span class="attr">exclude:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<p><strong>方式二：通过注解参数排除自动配置类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration(excludeName = &quot;&quot;,exclude = &#123;&#125;)</span></span><br></pre></td></tr></table></figure>
<p><strong>方式三：排除坐标（应用面较窄）</strong></p>
<p>如果当前自动配置中包含有更多的自动配置功能，也就是一个套娃的效果。此时可以通过检测条件的控制来管理自动配置是否启动。例如 web 程序启动时会自动启动 tomcat 服务器，可以通过排除坐标的方式，让加载 tomcat 服务器的条件失效。不过需要提醒一点，你把 tomcat 排除掉，记得再加一种可以运行的服务器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--添加Jetty起步依赖，匹配自动配置条件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>springboot 的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能</li>
</ol>
<h2 id="yl-2自定义starter开发"><a class="markdownIt-Anchor" href="#yl-2自定义starter开发">#</a> YL-2. 自定义 starter 开发</h2>
<p>​		自动配置学习完后，我们就可以基于自动配置的特性，开发 springboot 技术中最引以为傲的功能了，starter。其实通过前期学习，我们发现用什么技术直接导入对应的 starter，然后就实现了 springboot 整合对应技术，再加上一些简单的配置，就可以直接使用了。这种设计方式对开发者非常友好，本章就通过一个案例的制作，开发自定义 starter 来实现自定义功能的快捷添加。</p>
<h3 id="yl-2-1案例记录系统访客独立ip访问次数"><a class="markdownIt-Anchor" href="#yl-2-1案例记录系统访客独立ip访问次数">#</a> YL-2-1. 案例：记录系统访客独立 IP 访问次数</h3>
<p>​		本案例的功能是统计网站独立 IP 访问次数的功能，并将访问信息在后台持续输出。整体功能是在后台每 10 秒输出一次监控信息（格式：IP + 访问次数） ，当用户访问网站时，对用户的访问行为进行统计。</p>
<p>​		例如：张三访问网站功能 15 次，IP 地址：192.168.0.135，李四访问网站功能 20 次，IP 地址：61.129.65.248。那么在网站后台就输出如下监控信息，此信息每 10 秒刷新一次。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         IP访问监控</span><br><span class="line">+-----ip-address-----+--num--+</span><br><span class="line">|     192.168.0.135  |   15  |</span><br><span class="line">|     61.129.65.248  |   20  |</span><br><span class="line">+--------------------+-------+</span><br></pre></td></tr></table></figure>
<p>​		在进行具体制作之前，先对功能做具体的分析</p>
<ol>
<li>
<p>数据记录在什么位置</p>
<p>最终记录的数据是一个字符串（IP 地址）对应一个数字（访问次数），此处可以选择的数据存储模型可以使用 java 提供的 map 模型，也就是 key-value 的键值对模型，或者具有 key-value 键值对模型的存储技术，例如 redis 技术。本案例使用 map 作为实现方案，有兴趣的小伙伴可以使用 redis 作为解决方案。</p>
</li>
<li>
<p>统计功能运行位置，因为每次 web 请求都需要进行统计，因此使用拦截器会是比较好的方案，本案例使用拦截器来实现。不过在制作初期，先使用调用的形式进行测试，等功能完成了，再改成拦截器的实现方案。</p>
</li>
<li>
<p>为了提升统计数据展示的灵活度，为统计功能添加配置项。输出频度，输出的数据格式，统计数据的显示模式均可以通过配置实现调整。</p>
<ul>
<li>输出频度，默认 10 秒</li>
<li>数据特征：累计数据 / 阶段数据，默认累计数据</li>
<li>输出格式：详细模式 / 极简模式</li>
</ul>
</li>
</ol>
<p>​		在下面的制作中，分成若干个步骤实现。先完成最基本的统计功能的制作，然后开发出统计报表，接下来把所有的配置都设置好，最后将拦截器功能实现，整体功能就做完了。</p>
<h3 id="yl-2-2ip计数业务功能开发自定义starter"><a class="markdownIt-Anchor" href="#yl-2-2ip计数业务功能开发自定义starter">#</a> YL-2-2.IP 计数业务功能开发（自定义 starter）</h3>
<p>​		本功能最终要实现的效果是在现有的项目中导入一个 starter，对应的功能就添加上了，删除掉对应的 starter，功能就消失了，要求功能要与原始项目完全解耦。因此需要开发一个独立的模块，制作对应功能。</p>
<p><strong>步骤一：创建全新的模块，定义业务功能类</strong></p>
<p>​		功能类的制作并不复杂，定义一个业务类，声明一个 Map 对象，用于记录 ip 访问次数，key 是 ip 地址，value 是访问次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		有些小伙伴可能会有疑问，不设置成静态的，如何在每次请求时进行数据共享呢？记得，当前类加载成 bean 以后是一个单例对象，对象都是单例的，哪里存在多个对象共享变量的问题。</p>
<p><strong>步骤二：制作统计功能</strong></p>
<p>​		制作统计操作对应的方法，每次访问后对应 ip 的记录次数 + 1。需要分情况处理，如果当前没有对应 ip 的数据，新增一条数据，否则就修改对应 key 的值 + 1 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//每次调用当前操作，就记录当前访问的IP，然后累加访问次数</span></span><br><span class="line">        <span class="comment">//1.获取当前操作的IP地址</span></span><br><span class="line">        String ip = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//2.根据IP地址从Map取值，并递增</span></span><br><span class="line">        Integer count = ipCountMap.get(ip);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ipCountMap.put(ip,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ipCountMap.put(ip,count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		因为当前功能最终导入到其他项目中进行，而导入当前功能的项目是一个 web 项目，可以从容器中直接获取请求对象，因此获取 IP 地址的操作可以通过自动装配得到请求对象，然后获取对应的访问 IP 地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//当前的request对象的注入工作由使用当前starter的工程提供自动装配</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest httpServletRequest;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//每次调用当前操作，就记录当前访问的IP，然后累加访问次数</span></span><br><span class="line">        <span class="comment">//1.获取当前操作的IP地址</span></span><br><span class="line">        String ip = httpServletRequest.getRemoteAddr();</span><br><span class="line">        <span class="comment">//2.根据IP地址从Map取值，并递增</span></span><br><span class="line">        Integer count = ipCountMap.get(ip);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ipCountMap.put(ip,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ipCountMap.put(ip,count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤三：定义自动配置类</strong></p>
<p>​		我们需要做到的效果是导入当前模块即开启此功能，因此使用自动配置实现功能的自动装载，需要开发自动配置类在启动项目时加载当前功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpCountService <span class="title">ipCountService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IpCountService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		自动配置类需要在 spring.factories 文件中做配置方可自动运行。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">cn.itcast.autoconfig.IpAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤四：在原始项目中模拟调用，测试功能</strong></p>
<p>​		原始调用项目中导入当前开发的 starter</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ip_spring_boot_starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		推荐选择调用方便的功能做测试，推荐使用分页操作，当然也可以换其他功能位置进行测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IpCountService ipCountService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">getPage</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="keyword">int</span> pageSize,Book book)</span></span>&#123;</span><br><span class="line">        ipCountService.count();</span><br><span class="line">        IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize,book);</span><br><span class="line">        <span class="keyword">if</span>( currentPage &gt; page.getPages())&#123;</span><br><span class="line">            page = bookService.getPage((<span class="keyword">int</span>)page.getPages(), pageSize,book);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> R(<span class="keyword">true</span>, page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		由于当前制作的功能需要在对应的调用位置进行坐标导入，因此必须保障仓库中具有当前开发的功能，所以每次原始代码修改后，需要重新编译并安装到仓库中。为防止问题出现，建议每次安装之前先 clean 然后 install，保障资源进行了更新。切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		每次调用分页操作后，可以在控制台输出当前访问的 IP 地址，此功能可以在 count 操作中添加日志或者输出语句进行测试。</p>
<h3 id="yl-2-3定时任务报表开发"><a class="markdownIt-Anchor" href="#yl-2-3定时任务报表开发">#</a> YL-2-3. 定时任务报表开发</h3>
<p>​		当前已经实现了在业务功能类中记录访问数据，但是还没有输出监控的信息到控制台。由于监控信息需要每 10 秒输出 1 次，因此需要使用定时器功能。可以选取第三方技术 Quartz 实现，也可以选择 Spring 内置的 task 来完成此功能，此处选用 Spring 的 task 作为实现方案。</p>
<p><strong>步骤一：开启定时任务功能</strong></p>
<p>​		定时任务功能开启需要在当前功能的总配置中设置，结合现有业务设定，比较合理的位置是设置在自动配置类上。加载自动配置类即启用定时任务功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpCountService <span class="title">ipCountService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IpCountService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤二：制作显示统计数据功能</strong></p>
<p>​		定义显示统计功能的操作 print ()，并设置定时任务，当前设置每 5 秒运行一次统计数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;         IP访问监控&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;+-----ip-address-----+--num--+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;|%18s  |%5d  |&quot;</span>,key,value));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------------------+-------+&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		其中关于统计报表的显示信息拼接可以使用各种形式进行，此处使用 String 类中的格式化字符串操作进行，学习者可以根据自己的喜好调整实现方案。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先 clean 然后 install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		每次调用分页操作后，可以在控制台看到统计数据，到此基础功能已经开发完毕。</p>
<h3 id="yl-2-4使用属性配置设置功能参数"><a class="markdownIt-Anchor" href="#yl-2-4使用属性配置设置功能参数">#</a> YL-2-4. 使用属性配置设置功能参数</h3>
<p>​		由于当前报表显示的信息格式固定，为提高报表信息显示的灵活性，需要通过 yml 文件设置参数，控制报表的显示格式。</p>
<p><strong>步骤一：定义参数格式</strong></p>
<p>​		设置 3 个属性，分别用来控制显示周期（cycle），阶段数据是否清空（cycleReset），数据显示格式（model）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tools:</span></span><br><span class="line">  <span class="attr">ip:</span></span><br><span class="line">    <span class="attr">cycle:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">cycleReset:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">model:</span> <span class="string">&quot;detail&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤二：定义封装参数的属性类，读取配置参数</strong></p>
<p>​		为防止项目组定义的参数种类过多，产生冲突，通常设置属性前缀会至少使用两级属性作为前缀进行区分。</p>
<p>​		日志输出模式是在若干个类别选项中选择某一项，对于此种分类性数据建议制作枚举定义分类数据，当然使用字符串也可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;tools.ip&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpProperties</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志显示周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long cycle = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否周期内重置数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean cycleReset = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志输出模式  detail：详细模式  simple：极简模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String model = LogModel.DETAIL.value;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LogModel</span></span>&#123;</span><br><span class="line">        DETAIL(<span class="string">&quot;detail&quot;</span>),</span><br><span class="line">        SIMPLE(<span class="string">&quot;simple&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> String value;</span><br><span class="line">        LogModel(String value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤三：加载属性类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(IpProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpCountService <span class="title">ipCountService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IpCountService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤四：应用配置属性</strong></p>
<p>​		在应用配置属性的功能类中，使用自动装配加载对应的配置 bean，然后使用配置信息做分支处理。</p>
<p>​		注意：清除数据的功能一定要在输出后运行，否则每次查阅的数据均为空白数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IpProperties ipProperties;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ipProperties.getModel().equals(IpProperties.LogModel.DETAIL.getValue()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;         IP访问监控&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;+-----ip-address-----+--num--+&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) &#123;</span><br><span class="line">                String key = entry.getKey();</span><br><span class="line">                Integer value = entry.getValue();</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;|%18s  |%5d  |&quot;</span>,key,value));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;+--------------------+-------+&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ipProperties.getModel().equals(IpProperties.LogModel.SIMPLE.getValue()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;     IP访问监控&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;+-----ip-address-----+&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String key: ipCountMap.keySet()) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;|%18s  |&quot;</span>,key));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;+--------------------+&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阶段内统计数据归零</span></span><br><span class="line">        <span class="keyword">if</span>(ipProperties.getCycleReset())&#123;</span><br><span class="line">            ipCountMap.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先 clean 然后 install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		在 web 程序端可以通过控制 yml 文件中的配置参数对统计信息进行格式控制。但是数据显示周期还未进行控制。</p>
<h3 id="yl-2-5使用属性配置设置定时器参数"><a class="markdownIt-Anchor" href="#yl-2-5使用属性配置设置定时器参数">#</a> YL-2-5. 使用属性配置设置定时器参数</h3>
<p>​		在使用属性配置中的显示周期数据时，遇到了一些问题。由于无法在 @Scheduled 注解上直接使用配置数据，改用曲线救国的方针，放弃使用 @EnableConfigurationProperties 注解对应的功能，改成最原始的 bean 定义格式。</p>
<p><strong>步骤一：@Scheduled 注解使用 #{} 读取 bean 属性值</strong></p>
<p>​		此处读取 bean 名称为 ipProperties 的 bean 的 cycle 属性值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/#&#123;ipProperties.cycle&#125; * * * * ?&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤二：属性类定义 bean 并指定 bean 的访问名称</strong></p>
<p>​		如果此处不设置 bean 的访问名称，spring 会使用自己的命名生成器生成 bean 的长名称，无法实现属性的读取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;ipProperties&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;tools.ip&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpProperties</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤三：弃用 @EnableConfigurationProperties 注解对应的功能，改为导入 bean 的形式加载配置属性类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="comment">//@EnableConfigurationProperties(IpProperties.class)</span></span><br><span class="line"><span class="meta">@Import(IpProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpCountService <span class="title">ipCountService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IpCountService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先 clean 然后 install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		在 web 程序端可以通过控制 yml 文件中的配置参数对统计信息的显示周期进行控制</p>
<h3 id="yl-2-6拦截器开发"><a class="markdownIt-Anchor" href="#yl-2-6拦截器开发">#</a> YL-2-6. 拦截器开发</h3>
<p>​		基础功能基本上已经完成了制作，下面进行拦截器的开发。开发时先在 web 工程中制作，然后将所有功能挪入 starter 模块中</p>
<p><strong>步骤一：开发拦截器</strong></p>
<p>​		使用自动装配加载统计功能的业务类，并在拦截器中调用对应功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpCountInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IpCountService ipCountService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">                             HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ipCountService.count();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤二：配置拦截器</strong></p>
<p>​		配置 mvc 拦截器，设置拦截对应的请求路径。此处拦截所有请求，用户可以根据使用需要设置要拦截的请求。甚至可以在此处加载 IpCountProperties 中的属性，通过配置设置拦截器拦截的请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(ipCountInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpCountInterceptor <span class="title">ipCountInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IpCountInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先 clean 然后 install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		在 web 程序端导入对应的 starter 后功能开启，去掉坐标后功能消失，实现自定义 starter 的效果。</p>
<p>​		到此当前案例全部完成，自定义 stater 的开发其实在第一轮开发中就已经完成了，就是创建独立模块导出独立功能，需要使用的位置导入对应的 starter 即可。如果是在企业中开发，记得不仅需要将开发完成的 starter 模块 install 到自己的本地仓库中，开发完毕后还要 deploy 到私服上，否则别人就无法使用了。</p>
<h3 id="yl-2-7功能性完善开启yml提示功能"><a class="markdownIt-Anchor" href="#yl-2-7功能性完善开启yml提示功能">#</a> YL-2-7. 功能性完善 —— 开启 yml 提示功能</h3>
<p>​		我们在使用 springboot 的配置属性时，都可以看到提示，尤其是导入了对应的 starter 后，也会有对应的提示信息出现。但是现在我们的 starter 没有对应的提示功能，这种设定就非常的不友好，本节解决自定义 starter 功能如何开启配置提示的问题。</p>
<p>​		springboot 提供有专用的工具实现此功能，仅需要导入下列坐标。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​		程序编译后，在 META-INF 目录中会生成对应的提示文件，然后拷贝生成出的文件到自己开发的 META-INF 目录中，并对其进行编辑。打开生成的文件，可以看到如下信息。其中 groups 属性定义了当前配置的提示信息总体描述，当前配置属于哪一个属性封装类，properties 属性描述了当前配置中每一个属性的具体设置，包含名称、类型、描述、默认值等信息。hints 属性默认是空白的，没有进行设置。hints 属性可以参考 springboot 源码中的制作，设置当前属性封装类专用的提示信息，下例中为日志输出模式属性 model 设置了两种可选提示信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;groups&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;properties&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.cycle&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;java.lang.Long&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;日志显示周期&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span>,</span><br><span class="line">      <span class="string">&quot;defaultValue&quot;</span>: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.cycle-reset&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;java.lang.Boolean&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;是否周期内重置数据&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span>,</span><br><span class="line">      <span class="string">&quot;defaultValue&quot;</span>: <span class="keyword">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.model&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;日志输出模式  detail：详细模式  simple：极简模式&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;hints&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.model&quot;</span>,</span><br><span class="line">      <span class="string">&quot;values&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;value&quot;</span>: <span class="string">&quot;detail&quot;</span>,</span><br><span class="line">          <span class="string">&quot;description&quot;</span>: <span class="string">&quot;详细模式.&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;value&quot;</span>: <span class="string">&quot;simple&quot;</span>,</span><br><span class="line">          <span class="string">&quot;description&quot;</span>: <span class="string">&quot;极简模式.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>自定义 starter 其实就是做一个独立的功能模块，核心技术是利用自动配置的效果在加载模块后加载对应的功能</li>
<li>通常会为自定义 starter 的自动配置功能添加足够的条件控制，而不会做成 100% 加载对功能的效果</li>
<li>本例中使用 map 保存数据，如果换用 redis 方案，在 starter 开发模块中就要导入 redis 对应的 starter</li>
<li>对于配置属性务必开启提示功能，否则使用者无法感知配置应该如何书写</li>
</ol>
<h2 id="yl-3springboot程序启动流程解析"><a class="markdownIt-Anchor" href="#yl-3springboot程序启动流程解析">#</a> YL-3.SpringBoot 程序启动流程解析</h2>
<p>​		原理篇学习到这里即将结束，最后一章说一下 springboot 程序的启动流程。对于 springboot 技术来说，它用于加速 spring 程序的开发，核心本质还是 spring 程序的运行，所以于其说是 springboot 程序的启动流程，不如说是 springboot 对 spring 程序的启动流程做了哪些更改。</p>
<p>​		其实不管是 springboot 程序还是 spring 程序，启动过程本质上都是在做容器的初始化，并将对应的 bean 初始化出来放入容器。在 spring 环境中，每个 bean 的初始化都要开发者自己添加设置，但是切换成 springboot 程序后，自动配置功能的添加帮助开发者提前预设了很多 bean 的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得略微复杂，但是核心本质还是在做一件事，初始化容器。作为开发者只要搞清楚 springboot 提供了哪些参数设置的环节，同时初始化容器的过程中都做了哪些事情就行了。</p>
<p>​		springboot 初始化的参数根据参数的提供方，划分成如下 3 个大类，每个大类的参数又被封装了各种各样的对象，具体如下：</p>
<ul>
<li>环境属性（Environment）</li>
<li>系统配置（spring.factories）</li>
<li>参数（Arguments、application.properties）</li>
</ul>
<p>​		以下通过代码流向介绍了 springboot 程序启动时每一环节做的具体事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Springboot30StartupApplication【<span class="number">10</span>】-&gt;SpringApplication.run(Springboot30StartupApplication.class, args);</span><br><span class="line">    SpringApplication【<span class="number">1332</span>】-&gt;<span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">        SpringApplication【<span class="number">1343</span>】-&gt;<span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">            SpringApplication【<span class="number">1343</span>】-&gt;SpringApplication(primarySources)</span><br><span class="line">            # 加载各种配置信息，初始化各种配置对象</span><br><span class="line">                SpringApplication【<span class="number">266</span>】-&gt;<span class="keyword">this</span>(<span class="keyword">null</span>, primarySources);</span><br><span class="line">                    SpringApplication【<span class="number">280</span>】-&gt;<span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span></span></span><br><span class="line"><span class="function">                        SpringApplication【281】-&gt;<span class="keyword">this</span>.resourceLoader </span>= resourceLoader;</span><br><span class="line">                        # 初始化资源加载器</span><br><span class="line">                        SpringApplication【<span class="number">283</span>】-&gt;<span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">                        # 初始化配置类的类名信息（格式转换）</span><br><span class="line">                        SpringApplication【<span class="number">284</span>】-&gt;<span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">                        # 确认当前容器加载的类型</span><br><span class="line">                        SpringApplication【<span class="number">285</span>】-&gt;<span class="keyword">this</span>.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();</span><br><span class="line">                        # 获取系统配置引导信息</span><br><span class="line">                        SpringApplication【<span class="number">286</span>】-&gt;setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">                        # 获取ApplicationContextInitializer.class对应的实例</span><br><span class="line">                        SpringApplication【<span class="number">287</span>】-&gt;setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">                        # 初始化监听器，对初始化过程及运行过程进行干预</span><br><span class="line">                        SpringApplication【<span class="number">288</span>】-&gt;<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">                        # 初始化了引导类类名信息，备用</span><br><span class="line">            SpringApplication【<span class="number">1343</span>】-&gt;<span class="keyword">new</span> SpringApplication(primarySources).run(args)</span><br><span class="line">            # 初始化容器，得到ApplicationContext对象</span><br><span class="line">                SpringApplication【<span class="number">323</span>】-&gt;StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">                # 设置计时器</span><br><span class="line">                SpringApplication【<span class="number">324</span>】-&gt;stopWatch.start();</span><br><span class="line">                # 计时开始</span><br><span class="line">                SpringApplication【<span class="number">325</span>】-&gt;DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">                # 系统引导信息对应的上下文对象</span><br><span class="line">                SpringApplication【<span class="number">327</span>】-&gt;configureHeadlessProperty();</span><br><span class="line">                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）</span><br><span class="line">                    java.awt.headless=<span class="keyword">true</span></span><br><span class="line">                SpringApplication【<span class="number">328</span>】-&gt;SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">                # 获取当前注册的所有监听器</span><br><span class="line">                SpringApplication【<span class="number">329</span>】-&gt;listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line">                # 监听器执行了对应的操作步骤</span><br><span class="line">                SpringApplication【<span class="number">331</span>】-&gt;ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">                # 获取参数</span><br><span class="line">                SpringApplication【<span class="number">333</span>】-&gt;ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">                # 将前期读取的数据加载成了一个环境对象，用来描述信息</span><br><span class="line">                SpringApplication【<span class="number">333</span>】-&gt;configureIgnoreBeanInfo(environment);</span><br><span class="line">                # 做了一个配置，备用</span><br><span class="line">                SpringApplication【<span class="number">334</span>】-&gt;Banner printedBanner = printBanner(environment);</span><br><span class="line">                # 初始化logo</span><br><span class="line">                SpringApplication【<span class="number">335</span>】-&gt;context = createApplicationContext();</span><br><span class="line">                # 创建容器对象，根据前期配置的容器类型进行判定并创建</span><br><span class="line">                SpringApplication【<span class="number">363</span>】-&gt;context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">                # 设置启动模式</span><br><span class="line">                SpringApplication【<span class="number">337</span>】-&gt;prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">                # 对容器进行设置，参数来源于前期的设定</span><br><span class="line">                SpringApplication【<span class="number">338</span>】-&gt;refreshContext(context);</span><br><span class="line">                # 刷新容器环境</span><br><span class="line">                SpringApplication【<span class="number">339</span>】-&gt;afterRefresh(context, applicationArguments);</span><br><span class="line">                # 刷新完毕后做后处理</span><br><span class="line">                SpringApplication【<span class="number">340</span>】-&gt;stopWatch.stop();</span><br><span class="line">                # 计时结束</span><br><span class="line">                SpringApplication【<span class="number">341</span>】-&gt;<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">                # 判定是否记录启动时间的日志</span><br><span class="line">                SpringApplication【<span class="number">342</span>】-&gt;    <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">                # 创建日志对应的对象，输出日志信息，包含启动时间</span><br><span class="line">                SpringApplication【<span class="number">344</span>】-&gt;listeners.started(context);</span><br><span class="line">                # 监听器执行了对应的操作步骤</span><br><span class="line">                SpringApplication【<span class="number">345</span>】-&gt;callRunners(context, applicationArguments);</span><br><span class="line">                # 调用运行器</span><br><span class="line">                SpringApplication【<span class="number">353</span>】-&gt;listeners.running(context);</span><br><span class="line">                # 监听器执行了对应的操作步骤</span><br></pre></td></tr></table></figure>
<p>​		上述过程描述了 springboot 程序启动过程中做的所有的事情，这个时候好奇宝宝们就会提出一个问题。如果想干预 springboot 的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入 springboot 的启动流程呢？</p>
<p>​		遇到这样的问题，大部分技术是这样设计的，设计若干个标准接口，对应程序中的所有标准过程。当你想干预某个过程时，实现接口就行了。例如 spring 技术中 bean 的生命周期管理就是采用标准接口进行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Abc</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//销毁操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		springboot 启动过程由于存在着大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。那 springboot 如何解决这个问题呢？它采用了一种最原始的设计模式来解决这个问题，这就是监听器模式，使用监听器来解决这个问题。</p>
<p>​		springboot 将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：</p>
<ul>
<li>org.springframework.boot.context.event.ApplicationStartingEvent
<ul>
<li>应用启动事件，在应用运行但未进行任何处理时，将发送 ApplicationStartingEvent</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent
<ul>
<li>环境准备事件，当 Environment 被使用，且上下文创建之前，将发送 ApplicationEnvironmentPreparedEvent</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationContextInitializedEvent
<ul>
<li>上下文初始化事件</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationPreparedEvent
<ul>
<li>应用准备事件，在开始刷新之前，bean 定义被加载之后发送 ApplicationPreparedEvent</li>
</ul>
</li>
<li>org.springframework.context.event.ContextRefreshedEvent
<ul>
<li>上下文刷新事件</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationStartedEvent
<ul>
<li>应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 ApplicationStartedEvent</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationReadyEvent
<ul>
<li>应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 ApplicationReadyEvent，用于通知应用已经准备处理请求</li>
</ul>
</li>
<li>org.springframework.context.event.ContextClosedEvent（上下文关闭事件，对应容器关闭）</li>
</ul>
<p>​		上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户还可以根据需要自定义开发当前事件触发时要做的其他动作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定监听器，在应用启动开始事件时进行功能追加</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationStartingEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationStartingEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//自定义事件处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		按照上述方案处理，用户就可以干预 springboot 启动过程的所有工作节点，设置自己的业务系统中独有的功能点。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot 启动流程是先初始化容器需要的各种配置，并加载成各种对象，初始化容器时读取这些对象，创建容器</li>
<li>整体流程采用事件监听的机制进行过程控制，开发者可以根据需要自行扩展，添加对应的监听器绑定具体事件，就可以在事件触发位置执行开发者的业务代码</li>
</ol>
<h2 id="原理篇完结"><a class="markdownIt-Anchor" href="#原理篇完结">#</a> 原理篇完结</h2>
<p>​		原理篇到这里就要结束了，springboot2 整套课程的基础篇、实用篇和原理篇就全部讲完了。</p>
<p>​		原理篇个人感觉略微有点偷懒，怎么说呢？学习原理篇需要的前置铺垫知识太多，比如最后一节讲到启动流程时，看到 reflush 方法时我就想现在在看这套课程的小伙伴是否真的懂这个过程呢？但是如果把这些东西都讲了，那估计要补充的知识就太多了，就是将 spring 的很多知识加入到这里面重新讲解了，会出现喧宾夺主的现象。很纠结，(´・︵・`)</p>
<p>​		课程做到这里就要和各位小伙伴先 say 顾拜了，感谢各位小伙伴的支持，也欢迎各位小伙伴持续关注黑马程序员出品的各种视频教程。黑马程序员的每位老师做课程都是认真的，都是为了各位致力于 IT 研发事业的小伙伴能够学习之路上少遇沟沟坎坎，顺利到达成功的彼岸。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LXR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://laz0825.cn/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%8E%9F%E7%90%86%E7%AF%87/">http://laz0825.cn/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%8E%9F%E7%90%86%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://laz0825.cn" target="_blank">LXR的小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/%E6%95%99%E7%A8%8B/">教程</a><a class="post-meta__tags" href="/tags/SpringBoot/">SpringBoot</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://img13.360buyimg.com/ddimg/jfs/t1/201014/9/2100/116055/611b9a15E22fe0582/06f08140ca9867a4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://i.loli.net/2021/08/10/5AkuxvBo9hc2fWJ.png" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/08/10/5AkuxvBo9hc2fWJ.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://i.loli.net/2021/08/10/fchQveXJWzVGFOB.png" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/08/10/fchQveXJWzVGFOB.png" alt="QQ"/></a><div class="post-qr-code-desc">QQ</div></li><li class="reward-item"><a href="https://i.loli.net/2021/08/10/RPmVMNrvWG3Jn5o.jpg" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/08/10/RPmVMNrvWG3Jn5o.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/passages/LXR%E3%81%AE%E7%83%A4%E7%AE%B1%E5%85%A5%E9%97%A8%E9%A3%9F%E8%B0%B1/"><img class="prev-cover" src="https://img12.360buyimg.com/ddimg/jfs/t1/180055/33/19859/177816/611b99f3Eed9e9100/8f69131f658b2167.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LXRの烤箱入门食谱</div></div></a></div><div class="next-post pull-right"><a href="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/"><img class="next-cover" src="https://img10.360buyimg.com/ddimg/jfs/t1/177566/27/19894/230223/611b9ce3Ed619bf5c/66b1f15329bf0e41.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot讲义-开发实用篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/passages/SpringBoot讲义-开发实用篇/" title="SpringBoot讲义-开发实用篇"><img class="cover" src="https://img10.360buyimg.com/ddimg/jfs/t1/177566/27/19894/230223/611b9ce3Ed619bf5c/66b1f15329bf0e41.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-02</div><div class="title">SpringBoot讲义-开发实用篇</div></div></a></div><div><a href="/passages/SpringBoot讲义-运维实用篇/" title="SpringBoot讲义-运维实用篇"><img class="cover" src="https://img10.360buyimg.com/ddimg/jfs/t1/193230/7/18721/177179/611b9da6Ed923d39f/dba3bc711f204884.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-02</div><div class="title">SpringBoot讲义-运维实用篇</div></div></a></div><div><a href="/passages/SpringBoot讲义-基础篇/" title="SpringBoot讲义-基础篇"><img class="cover" src="https://img11.360buyimg.com/ddimg/jfs/t1/192325/24/18145/223455/611b9cdcE8aa8b18e/64c75bf4bdd4a961.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-02</div><div class="title">SpringBoot讲义-基础篇</div></div></a></div><div><a href="/passages/MySql基础篇/" title="MySql基础篇"><img class="cover" src="https://img12.360buyimg.com/ddimg/jfs/t1/202544/25/1857/225134/611b9cdcE5d5e564f/582033b23f0396a2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-28</div><div class="title">MySql基础篇</div></div></a></div><div><a href="/passages/MyBatis-Plus/" title="MyBatis-Plus"><img class="cover" src="https://img11.360buyimg.com/ddimg/jfs/t1/187530/21/18789/334891/611b9cdfEef003be3/0ccc9f5752896181.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-28</div><div class="title">MyBatis-Plus</div></div></a></div><div><a href="/passages/MyBatis/" title="MyBatis笔记"><img class="cover" src="https://img13.360buyimg.com/ddimg/jfs/t1/177753/39/19615/271529/611b9cdfEd3a0207e/3719a98759543c1a.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-15</div><div class="title">MyBatis笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s3.bmp.ovh/imgs/2022/01/48416141b447da0f.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LXR</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LAZ-0825"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:1172623892@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://s3.bmp.ovh/imgs/2022/01/1c676af554a53516.png" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/LAZ-0825/LAZ-0825.github.io/discussions" target="_blank" title="有疑问的话这点里可以找到我"><i class="fas fa-comment-dots"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">如果你在浏览博客时有什么问题的话，可以到 <a target="_blank" rel="noopener" href="https://github.com/LAZ-0825/LAZ-0825.github.io/discussions" style="color:#49b1f5">Github Discussions</a> 或者 <a href="/Message/" style="color:#49b1f5">留言板</a> 进行反馈。</div><timing> </timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#springboot%E5%8E%9F%E7%90%86%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text"> SpringBoot 原理篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%E7%99%BD%E5%AB%96%E5%8F%91%E8%A8%80"><span class="toc-number">1.0.1.</span> <span class="toc-text"> 前言（白嫖发言）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yl-1%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text"> YL-1. 自动配置工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-1-1bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text"> YL-1-1.bean 的加载方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6bean%E6%A0%87%E7%AD%BE"><span class="toc-number">1.1.1.1.</span> <span class="toc-text"> 方式一：配置文件 + &lt;bean&#x2F;&gt;  标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%89%AB%E6%8F%8F%E6%B3%A8%E8%A7%A3%E5%AE%9A%E4%B9%89bean"><span class="toc-number">1.1.1.2.</span> <span class="toc-text"> 方式二：配置文件扫描 + 注解定义 bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%A3%B0%E6%98%8E%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">1.1.1.3.</span> <span class="toc-text"> 方式三：注解方式声明配置类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8factroybean%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text"> 使用 FactroyBean 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E6%A0%BC%E5%BC%8F%E5%AF%BC%E5%85%A5xml%E6%A0%BC%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%9A%84bean"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text"> 注解格式导入 XML 格式配置的 bean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#proxybeanmethods%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.1.3.3.</span> <span class="toc-text"> proxyBeanMethods 属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E5%9B%9B%E4%BD%BF%E7%94%A8import%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5bean"><span class="toc-number">1.1.1.4.</span> <span class="toc-text"> 方式四：使用 @Import 注解注入 bean</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8import%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">1.1.1.4.1.</span> <span class="toc-text"> 使用 @Import 注解注入配置类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%94%E7%BC%96%E7%A8%8B%E5%BD%A2%E5%BC%8F%E6%B3%A8%E5%86%8Cbean"><span class="toc-number">1.1.1.5.</span> <span class="toc-text"> 方式五：编程形式注册 bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E5%85%AD%E5%AF%BC%E5%85%A5%E5%AE%9E%E7%8E%B0%E4%BA%86importselector%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB"><span class="toc-number">1.1.1.6.</span> <span class="toc-text"> 方式六：导入实现了 ImportSelector 接口的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%83%E5%AF%BC%E5%85%A5%E5%AE%9E%E7%8E%B0%E4%BA%86importbeandefinitionregistrar%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB"><span class="toc-number">1.1.1.7.</span> <span class="toc-text"> 方式七：导入实现了 ImportBeanDefinitionRegistrar 接口的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E5%85%AB%E5%AF%BC%E5%85%A5%E5%AE%9E%E7%8E%B0%E4%BA%86beandefinitionregistrypostprocessor%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB"><span class="toc-number">1.1.1.8.</span> <span class="toc-text"> 方式八：导入实现了 BeanDefinitionRegistryPostProcessor 接口的类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-1-2bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text"> YL-1-2.bean 的加载控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-1-3bean%E7%9A%84%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.3.</span> <span class="toc-text"> YL-1-3.bean 的依赖属性配置管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-1-4%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text"> YL-1-4. 自动配置原理（工作流程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-1-5%E5%8F%98%E6%9B%B4%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.5.</span> <span class="toc-text"> YL-1-5. 变更自动配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yl-2%E8%87%AA%E5%AE%9A%E4%B9%89starter%E5%BC%80%E5%8F%91"><span class="toc-number">1.2.</span> <span class="toc-text"> YL-2. 自定义 starter 开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-2-1%E6%A1%88%E4%BE%8B%E8%AE%B0%E5%BD%95%E7%B3%BB%E7%BB%9F%E8%AE%BF%E5%AE%A2%E7%8B%AC%E7%AB%8Bip%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text"> YL-2-1. 案例：记录系统访客独立 IP 访问次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-2-2ip%E8%AE%A1%E6%95%B0%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E8%87%AA%E5%AE%9A%E4%B9%89starter"><span class="toc-number">1.2.2.</span> <span class="toc-text"> YL-2-2.IP 计数业务功能开发（自定义 starter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-2-3%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%BC%80%E5%8F%91"><span class="toc-number">1.2.3.</span> <span class="toc-text"> YL-2-3. 定时任务报表开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-2-4%E4%BD%BF%E7%94%A8%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE%E5%8A%9F%E8%83%BD%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text"> YL-2-4. 使用属性配置设置功能参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-2-5%E4%BD%BF%E7%94%A8%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text"> YL-2-5. 使用属性配置设置定时器参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-2-6%E6%8B%A6%E6%88%AA%E5%99%A8%E5%BC%80%E5%8F%91"><span class="toc-number">1.2.6.</span> <span class="toc-text"> YL-2-6. 拦截器开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yl-2-7%E5%8A%9F%E8%83%BD%E6%80%A7%E5%AE%8C%E5%96%84%E5%BC%80%E5%90%AFyml%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.7.</span> <span class="toc-text"> YL-2-7. 功能性完善 —— 开启 yml 提示功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yl-3springboot%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text"> YL-3.SpringBoot 程序启动流程解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E7%AF%87%E5%AE%8C%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text"> 原理篇完结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/passages/%E9%BB%91%E7%A5%9E%E8%AF%9D%E6%82%9F%E7%A9%BA%E6%B8%B8%E7%8E%A9%E6%80%BB%E7%BB%93/" title="newPage"><img src="https://img14.360buyimg.com/ddimg/jfs/t1/187473/16/18834/174354/611b996eE22db810d/4ee24eafcaa64e51.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="newPage"/></a><div class="content"><a class="title" href="/passages/%E9%BB%91%E7%A5%9E%E8%AF%9D%E6%82%9F%E7%A9%BA%E6%B8%B8%E7%8E%A9%E6%80%BB%E7%BB%93/" title="newPage">newPage</a><time datetime="2024-10-27T05:40:14.000Z" title="发表于 2024-10-27 13:40:14">2024-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/passages/LXR%E3%81%AE%E5%BE%AE%E6%B3%A2%E7%82%89%E5%85%A5%E9%97%A8%E9%A3%9F%E8%B0%B1/" title="LXRの微波炉入门食谱"><img src="https://img11.360buyimg.com/ddimg/jfs/t1/183062/38/19882/223186/611b99f3E2f98da7e/93bc79b9241d9f92.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LXRの微波炉入门食谱"/></a><div class="content"><a class="title" href="/passages/LXR%E3%81%AE%E5%BE%AE%E6%B3%A2%E7%82%89%E5%85%A5%E9%97%A8%E9%A3%9F%E8%B0%B1/" title="LXRの微波炉入门食谱">LXRの微波炉入门食谱</a><time datetime="2022-12-22T04:39:10.000Z" title="发表于 2022-12-22 12:39:10">2022-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/passages/LXR%E3%81%AE%E7%83%A4%E7%AE%B1%E5%85%A5%E9%97%A8%E9%A3%9F%E8%B0%B1/" title="LXRの烤箱入门食谱"><img src="https://img12.360buyimg.com/ddimg/jfs/t1/180055/33/19859/177816/611b99f3Eed9e9100/8f69131f658b2167.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LXRの烤箱入门食谱"/></a><div class="content"><a class="title" href="/passages/LXR%E3%81%AE%E7%83%A4%E7%AE%B1%E5%85%A5%E9%97%A8%E9%A3%9F%E8%B0%B1/" title="LXRの烤箱入门食谱">LXRの烤箱入门食谱</a><time datetime="2022-12-13T10:07:46.000Z" title="发表于 2022-12-13 18:07:46">2022-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%8E%9F%E7%90%86%E7%AF%87/" title="SpringBoot讲义-原理篇"><img src="https://img13.360buyimg.com/ddimg/jfs/t1/201014/9/2100/116055/611b9a15E22fe0582/06f08140ca9867a4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot讲义-原理篇"/></a><div class="content"><a class="title" href="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%8E%9F%E7%90%86%E7%AF%87/" title="SpringBoot讲义-原理篇">SpringBoot讲义-原理篇</a><time datetime="2022-09-02T14:28:45.000Z" title="发表于 2022-09-02 22:28:45">2022-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/" title="SpringBoot讲义-开发实用篇"><img src="https://img10.360buyimg.com/ddimg/jfs/t1/177566/27/19894/230223/611b9ce3Ed619bf5c/66b1f15329bf0e41.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot讲义-开发实用篇"/></a><div class="content"><a class="title" href="/passages/SpringBoot%E8%AE%B2%E4%B9%89-%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/" title="SpringBoot讲义-开发实用篇">SpringBoot讲义-开发实用篇</a><time datetime="2022-09-02T14:28:33.000Z" title="发表于 2022-09-02 22:28:33">2022-09-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img13.360buyimg.com/ddimg/jfs/t1/201014/9/2100/116055/611b9a15E22fe0582/06f08140ca9867a4.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By LXR</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="icp"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/"><span>晋ICP备2022002077号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '37e259bf33b2d462f827',
      clientSecret: '1a2768d8e34462798bcea1deaa6ab0379aacaf0a',
      repo: 'LAZBLOG-speak',
      owner: 'LAZ-0825',
      admin: ['LAZ-0825'],
      id: '43ae22ffc5d82eca984ce85463adac3b',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: true,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script data-pjax src="https://butterfly.lete114.top/js/Lete.js"></script><script src="/js/foot.js"></script><script src="/js/timing.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><script defer src="https://cdn.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script src="https://cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script src="/js/ip_content.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdnurl.eu.org/2022/01/13/pC5gaOws.png" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>